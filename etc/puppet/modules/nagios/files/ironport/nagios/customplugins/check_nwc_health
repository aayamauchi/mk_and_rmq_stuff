#! /bin/env perl
# check_nwc_health is a plugin which is used to monitor network components.
# Originally it was written to check interface usage and hardware health (cpu, memory, power supply, fans, temperature) of Cisco switches. Today it covers the major manufacturers.
# author: lausser http://exchange.nagios.org/directory/Owner/lausser/1
# license: GNU General Public Licence (see http://www.fsf.org/licensing/licenses/gpl.txt)

package Nagios::MiniPlugin;

use warnings;
use strict;
use Getopt::Long qw(:config no_ignore_case bundling);

our @STATUS_CODES = qw(OK WARNING CRITICAL UNKNOWN DEPENDENT);

require Exporter;
our @ISA = qw(Exporter);
our @EXPORT = (@STATUS_CODES, qw(nagios_exit nagios_die check_messages));
our @EXPORT_OK = qw(%ERRORS);

use constant OK         => 0;
use constant WARNING    => 1;
use constant CRITICAL   => 2;
use constant UNKNOWN    => 3;
use constant DEPENDENT  => 4;

our %ERRORS = (
    'OK'        => OK,
    'WARNING'   => WARNING,
    'CRITICAL'  => CRITICAL,
    'UNKNOWN'   => UNKNOWN,
    'DEPENDENT' => DEPENDENT,
);

our %STATUS_TEXT = reverse %ERRORS;

sub new {
  my $class = shift;
  my %params = @_;
  my $self = {
       perfdata => [],
       messages => {
         ok => [],
         warning => [],
         critical => [],
         unknown => [],
       },
       args => [],
       opts => Nagios::MiniPlugin::Getopt->new(%params),
  };
  foreach (qw(shortname usage version url plugin blurb extra
      license timeout)) {
    $self->{$_} = $params{$_};
  }
  bless $self, $class;
}

sub add_arg {
  my $self = shift;
  $self->{opts}->add_arg(@_);
}

sub getopts { 
       my $self = shift;
       $self->{opts}->getopts();
}

sub override_opt { 
   my $self = shift;
   $self->{opts}->override_opt(@_);
}

sub create_opt { 
   my $self = shift;
   $self->{opts}->create_opt(@_);
}

sub opts {
       my $self = shift;
       return $self->{opts};
}

sub add_message {
  my $self = shift;
  my ($code, @messages) = @_;
  $code = (qw(ok warning critical unknown))[$code] if $code =~ /^\d+$/;
  $code = lc $code;
  push @{$self->{messages}->{$code}}, @messages;
}

sub add_perfdata {
  my ($self, %args) = @_;
  #if ($args{label} =~ /\s/) {
    $args{label} = '\''.$args{label}.'\'';
  #}
  if (! exists $args{places}) {
    $args{places} = 2;
  }
  my $format = '%d';
  if ($args{value} =~ /\./) {
    $format = '%.'.$args{places}.'f';
  }
  my $str = $args{label}.'='.sprintf $format, $args{value};
  if ($args{uom}) {
    $str .= $args{uom};
  }
  if ($args{warning}) {
    $str .= ';'.$args{warning};
  }
  if ($args{critical}) {
    $str .= ';'.$args{critical};
  }
  push @{$self->{perfdata}}, $str;
}

sub clear_messages {
  my $self = shift;
  my $code = shift;
  $code = (qw(ok warning critical unknown))[$code] if $code =~ /^\d+$/;
  $code = lc $code;
  $self->{messages}->{$code} = [];
}

sub check_messages {
  my $self = shift;
  my %args = @_;

  # Add object messages to any passed in as args
  for my $code (qw(critical warning unknown ok)) {
    my $messages = $self->{messages}->{$code} || [];
    if ($args{$code}) {
      unless (ref $args{$code} eq 'ARRAY') {
        if ($code eq 'ok') {
          $args{$code} = [ $args{$code} ];
        }
      }
      push @{$args{$code}}, @$messages;
    } else {
      $args{$code} = $messages;
    }
  }
  my %arg = %args;
  $arg{join} = ' ' unless defined $arg{join};

  # Decide $code
  my $code = OK;
  $code ||= CRITICAL  if @{$arg{critical}};
  $code ||= WARNING   if @{$arg{warning}};
  $code ||= UNKNOWN   if @{$arg{unknown}};
  return $code unless wantarray;

  # Compose message
  my $message = '';
  if ($arg{join_all}) {
      $message = join( $arg{join_all},
          map { @$_ ? join( $arg{'join'}, @$_) : () }
              $arg{critical},
              $arg{warning},
              $arg{unknown},
              $arg{ok} ? (ref $arg{ok} ? $arg{ok} : [ $arg{ok} ]) : []
      );
  }

  else {
      $message ||= join( $arg{'join'}, @{$arg{critical}} )
          if $code == CRITICAL;
      $message ||= join( $arg{'join'}, @{$arg{warning}} )
          if $code == WARNING;
      $message ||= join( $arg{'join'}, @{$arg{unknown}} )
          if $code == UNKNOWN;
      $message ||= ref $arg{ok} ? join( $arg{'join'}, @{$arg{ok}} ) : $arg{ok}
          if $arg{ok};
  }

  return ($code, $message);
}

sub nagios_exit {
  my $self = shift;
  my ($code, $message, $arg) = @_;
  $code = $ERRORS{$code} if defined $code && exists $ERRORS{$code};
  $code = UNKNOWN unless defined $code && exists $STATUS_TEXT{$code};
  $message = '' unless defined $message;
  if (ref $message && ref $message eq 'ARRAY') {
      $message = join(' ', map { chomp; $_ } @$message);
  } else {
      chomp $message;
  }
  my $output = "$STATUS_TEXT{$code}";
  $output .= " - $message" if defined $message && $message ne '';
  if (scalar (@{$self->{perfdata}})) {
    $output .= " | ".join(" ", @{$self->{perfdata}});
  }
  $output .= "\n";
  print $output;
  exit $code;
}

sub set_thresholds {
  my $self = shift;
  my %params = @_;
  $self->{mywarning} = $self->opts->warning || $params{warning} || 0;
  $self->{mycritical} = $self->opts->critical || $params{critical} || 0;
}

sub force_thresholds {
  my $self = shift;
  my %params = @_;
  $self->{mywarning} = $params{warning} || 0;
  $self->{mycritical} = $params{critical} || 0;
}

sub get_thresholds {
  my $self = shift;
  return ($self->{mywarning}, $self->{mycritical});
}

sub check_thresholds {
  my $self = shift;
  my @params = @_;
  my $level = $ERRORS{OK};
  my $warningrange;
  my $criticalrange;
  my $value;
  if (scalar(@params) > 1) {
    my %params = @params;
    $value = $params{check};
    $warningrange = (defined $params{warning}) ?
        $params{warning} : $self->{mywarning};
    $criticalrange = (defined $params{critical}) ?
        $params{critical} : $self->{mycritical};
  } else {
    $value = $params[0];
    $warningrange = $self->{mywarning};
    $criticalrange = $self->{mycritical};
  }
  if ($warningrange =~ /^(\d+)$/) {
    # warning = 10, warn if > 10 or < 0
    $level = $ERRORS{WARNING}
        if ($value > $1 || $value < 0);
  } elsif ($warningrange =~ /^(\d+):$/) {
    # warning = 10:, warn if < 10
    $level = $ERRORS{WARNING}
        if ($value < $1);
  } elsif ($warningrange =~ /^~:(\d+)$/) {
    # warning = ~:10, warn if > 10
    $level = $ERRORS{WARNING}
        if ($value > $1);
  } elsif ($warningrange =~ /^(\d+):(\d+)$/) {
    # warning = 10:20, warn if < 10 or > 20
    $level = $ERRORS{WARNING}
        if ($value < $1 || $value > $2);
  } elsif ($warningrange =~ /^@(\d+):(\d+)$/) {
    # warning = @10:20, warn if >= 10 and <= 20
    $level = $ERRORS{WARNING}
        if ($value >= $1 && $value <= $2);
  }
  if ($criticalrange =~ /^(\d+)$/) {
    # critical = 10, crit if > 10 or < 0
    $level = $ERRORS{CRITICAL}
        if ($value > $1 || $value < 0);
  } elsif ($criticalrange =~ /^(\d+):$/) {
    # critical = 10:, crit if < 10
    $level = $ERRORS{CRITICAL}
        if ($value < $1);
  } elsif ($criticalrange =~ /^~:(\d+)$/) {
    # critical = ~:10, crit if > 10
    $level = $ERRORS{CRITICAL}
        if ($value > $1);
  } elsif ($criticalrange =~ /^(\d+):(\d+)$/) {
    # critical = 10:20, crit if < 10 or > 20
    $level = $ERRORS{CRITICAL}
        if ($value < $1 || $value > $2);
  } elsif ($criticalrange =~ /^@(\d+):(\d+)$/) {
    # critical = @10:20, crit if >= 10 and <= 20
    $level = $ERRORS{CRITICAL}
        if ($value >= $1 && $value <= $2);
  }
  return $level;
}


package Nagios::MiniPlugin::Getopt;

use strict;
use File::Basename;
use Data::Dumper;
use Getopt::Long qw(:config no_ignore_case bundling);

# Standard defaults
my %DEFAULT = (
  timeout => 15,
  verbose => 0,
  license =>
"This nagios plugin is free software, and comes with ABSOLUTELY NO WARRANTY.
It may be used, redistributed and/or modified under the terms of the GNU
General Public Licence (see http://www.fsf.org/licensing/licenses/gpl.txt).",
);
# Standard arguments
my @ARGS = ({
    spec => 'usage|?',
    help => "-?, --usage\n   Print usage information",
  }, {
    spec => 'help|h',
    help => "-h, --help\n   Print detailed help screen",
  }, {
    spec => 'version|V',
    help => "-V, --version\n   Print version information",
  }, {
    #spec => 'extra-opts:s@',
    #help => "--extra-opts=[<section>[@<config_file>]]\n   Section and/or config_file from which to load extra options (may repeat)",
  }, {
    spec => 'timeout|t=i',
    help => sprintf("-t, --timeout=INTEGER\n   Seconds before plugin times out (default: %s)", $DEFAULT{timeout}),
    default => $DEFAULT{timeout},
  }, {
    spec => 'verbose|v+',
    help => "-v, --verbose\n   Show details for command-line debugging (can repeat up to 3 times)",
    default => $DEFAULT{verbose},
  },
);
# Standard arguments we traditionally display last in the help output
my %DEFER_ARGS = map { $_ => 1 } qw(timeout verbose);

sub _init
{
  my $self = shift;
  my %params = @_;
  # Check params
  my $plugin = basename($ENV{NAGIOS_PLUGIN} || $0);
  #my %attr = validate( @_, {
  my %attr = (
    usage => 1,
    version => 0,
    url => 0,
    plugin => { default => $plugin },
    blurb => 0,
    extra => 0,
    'extra-opts' => 0,
    license => { default => $DEFAULT{license} },
    timeout => { default => $DEFAULT{timeout} },
  );

  # Add attr to private _attr hash (except timeout)
  $self->{timeout} = delete $attr{timeout};
  $self->{_attr} = { %attr };
  foreach (keys %{$self->{_attr}}) {
    if (exists $params{$_}) {
      $self->{_attr}->{$_} = $params{$_};
    } else {
      $self->{_attr}->{$_} = $self->{_attr}->{$_}->{default} 
          if ref ($self->{_attr}->{$_}) eq 'HASH' &&
              exists $self->{_attr}->{$_}->{default};
    }
  }
  # Chomp _attr values
  chomp foreach values %{$self->{_attr}};

  # Setup initial args list
  $self->{_args} = [ grep { exists $_->{spec} } @ARGS ];

  $self
}

sub new
{
  my $class = shift;
  my $self = bless {}, $class;
  $self->_init(@_);
}

sub add_arg {
       my $self = shift;
       my %arg = @_;
       push (@{$self->{_args}}, \%arg);
}

sub getopts { 
  my $self = shift;
  my %commandline = ();
  my @params = map { $_->{spec} } @{$self->{_args}};
  if (! GetOptions(\%commandline, @params)) {
    $self->print_help();
    exit 0;
  } else {
    no strict 'refs';
    do { $self->print_help(); exit 0; } if $commandline{help};
    do { $self->print_version(); exit 0 } if $commandline{version};
    do { $self->print_usage(); exit 3 } if $commandline{usage};
    foreach (map { $_->{spec} =~ /^([\w\-]+)/; $1; } @{$self->{_args}}) {
      my $field = $_;
      *{"$field"} = sub {
        return $self->{opts}->{$field};
      };
    }
    foreach (map { $_->{spec} =~ /^([\w\-]+)/; $1; }
        grep { exists $_->{required} && $_->{required} } @{$self->{_args}}) {
      do { $self->print_usage(); exit 0 } if ! exists $commandline{$_};
    }
    foreach (grep { exists $_->{default} } @{$self->{_args}}) {
      $_->{spec} =~ /^([\w\-]+)/;
      my $spec = $1;
      $self->{opts}->{$spec} = $_->{default};
    }
    foreach (keys %commandline) {
      $self->{opts}->{$_} = $commandline{$_};
    }
  }
}

sub create_opt {
  my $self = shift;
  my $key = shift;
  no strict 'refs';
  *{"$key"} = sub {
      return $self->{opts}->{$key};
  };
}

sub override_opt {
  my $self = shift;
  my $key = shift;
  my $value = shift;
  $self->{opts}->{$key} = $value;
}

sub get {
       my $self = shift;
       my $opt = shift;
       return $self->{opts}->{$opt};
}

sub print_help {
  my $self = shift;
  $self->print_version();
  printf "\n%s\n", $self->{_attr}->{license};
  printf "\n%s\n\n", $self->{_attr}->{blurb};
  $self->print_usage();
  foreach (@{$self->{_args}}) {
    printf " %s\n", $_->{help};
  }
  exit 0;
}

sub print_usage {
  my $self = shift;
  printf $self->{_attr}->{usage}, $self->{_attr}->{plugin};
  print "\n";
}

sub print_version {
  my $self = shift;
  printf "%s %s", $self->{_attr}->{plugin}, $self->{_attr}->{version};
  printf " [%s]", $self->{_attr}->{url} if $self->{_attr}->{url};
  print "\n";
}

sub print_license {
  my $self = shift;
  printf "%s\n", $self->{_attr}->{license};
  print "\n";
}


package UPNP::AVM::FritzBox7390::Component::InterfaceSubsystem;
our @ISA = qw(NWC::IFMIB);

use strict;
use constant { OK => 0, WARNING => 1, CRITICAL => 2, UNKNOWN => 3 };

sub new {
  my $class = shift;
  my %params = @_;
  my $self = {
    interface_cache => {},
    interfaces => [],
    blacklisted => 0,
    info => undef,
    extendedinfo => undef,
  };
  bless $self, $class;
  $self->init(%params);
  return $self;
}

sub init {
  my $self = shift;
  my %params = @_;
  if ($self->mode =~ /device::interfaces::list/) {
    $self->update_interface_cache(1);
    foreach my $ifidxdescr (keys %{$self->{interface_cache}}) {
      my ($ifIndex, $ifDescr) = split('#', $ifidxdescr, 2);
      push(@{$self->{interfaces}},
          NWC::IFMIB::Component::InterfaceSubsystem::Interface->new(
              #ifIndex => $self->{interface_cache}->{$ifDescr},
              #ifDescr => $ifDescr,
              ifIndex => $ifIndex,
              ifDescr => $ifDescr,
          ));
    }
  } else {
    $self->{ifDescr} = "WAN";
    $self->{ExternalIPAddress} = SOAP::Lite
      -> proxy(sprintf 'http://%s:%s/upnp/control/WANCommonIFC1',
        $self->opts->hostname, $self->opts->port)
      -> uri('urn:schemas-upnp-org:service:WANIPConnection:1')
      -> GetExternalIPAddress()
      -> result;
    $self->{ConnectionStatus} = SOAP::Lite
      -> proxy(sprintf 'http://%s:%s/upnp/control/WANCommonIFC1',
        $self->opts->hostname, $self->opts->port)
      -> uri('urn:schemas-upnp-org:service:WANIPConnection:1')
      -> GetStatusInfo()
      -> valueof("//GetStatusInfoResponse/NewConnectionStatus");;
    $self->{PhysicalLinkStatus} = SOAP::Lite
      -> proxy(sprintf 'http://%s:%s/upnp/control/WANCommonIFC1',
        $self->opts->hostname, $self->opts->port)
      -> uri('urn:schemas-upnp-org:service:WANCommonInterfaceConfig:1')
      -> GetCommonLinkProperties()
      -> valueof("//GetCommonLinkPropertiesResponse/NewPhysicalLinkStatus");
    $self->{Layer1UpstreamMaxBitRate} = SOAP::Lite
      -> proxy(sprintf 'http://%s:%s/upnp/control/WANCommonIFC1',
        $self->opts->hostname, $self->opts->port)
      -> uri('urn:schemas-upnp-org:service:WANCommonInterfaceConfig:1')
      -> GetCommonLinkProperties()
      -> valueof("//GetCommonLinkPropertiesResponse/NewLayer1UpstreamMaxBitRate");
    $self->{Layer1DownstreamMaxBitRate} = SOAP::Lite
      -> proxy(sprintf 'http://%s:%s/upnp/control/WANCommonIFC1',
        $self->opts->hostname, $self->opts->port)
      -> uri('urn:schemas-upnp-org:service:WANCommonInterfaceConfig:1')
      -> GetCommonLinkProperties()
      -> valueof("//GetCommonLinkPropertiesResponse/NewLayer1DownstreamMaxBitRate");
    $self->{TotalBytesSent} = SOAP::Lite
      -> proxy(sprintf 'http://%s:%s/upnp/control/WANCommonIFC1',
        $self->opts->hostname, $self->opts->port)
      -> uri('urn:schemas-upnp-org:service:WANCommonInterfaceConfig:1')
      -> GetTotalBytesSent()
      -> result;
    $self->{TotalBytesReceived} = SOAP::Lite
      -> proxy(sprintf 'http://%s:%s/upnp/control/WANCommonIFC1',
        $self->opts->hostname, $self->opts->port)
      -> uri('urn:schemas-upnp-org:service:WANCommonInterfaceConfig:1')
      -> GetTotalBytesReceived()
      -> result;
  
    if ($self->mode =~ /device::interfaces::usage/) {
      $self->valdiff({name => $self->{ifDescr}}, qw(TotalBytesSent TotalBytesReceived));
      $self->{inputUtilization} = $self->{delta_TotalBytesReceived} * 8 * 100 /
          ($self->{delta_timestamp} * $self->{Layer1DownstreamMaxBitRate});
      $self->{outputUtilization} = $self->{delta_TotalBytesSent} * 8 * 100 /
          ($self->{delta_timestamp} * $self->{Layer1UpstreamMaxBitRate});
      $self->{inputRate} = $self->{delta_TotalBytesReceived} / $self->{delta_timestamp};
      $self->{outputRate} = $self->{delta_TotalBytesSent} / $self->{delta_timestamp};
      my $factor = 1/8; # default Bits
      if ($self->opts->units) {
        if ($self->opts->units eq "GB") {
          $factor = 1024 * 1024 * 1024;
        } elsif ($self->opts->units eq "MB") {
          $factor = 1024 * 1024;
        } elsif ($self->opts->units eq "KB") {
          $factor = 1024;
        } elsif ($self->opts->units eq "GBi") {
          $factor = 1024 * 1024 * 1024 / 8;
        } elsif ($self->opts->units eq "MBi") {
          $factor = 1024 * 1024 / 8;
        } elsif ($self->opts->units eq "KBi") {
          $factor = 1024 / 8;
        } elsif ($self->opts->units eq "B") {
          $factor = 1;
        } elsif ($self->opts->units eq "Bit") {
          $factor = 1/8;
        }
      }
      $self->{inputRate} /= $factor;
      $self->{outputRate} /= $factor;
      $self->{Layer1DownstreamMaxKBRate} =
          ($self->{Layer1DownstreamMaxBitRate} / 8) / 1024;
      $self->{Layer1UpstreamMaxKBRate} =
          ($self->{Layer1UpstreamMaxBitRate} / 8) / 1024;
    }
  }
}

sub check {
  my $self = shift;
  $self->add_info('checking interfaces');
  if ($self->mode =~ /device::interfaces::usage/) {
    my $info = sprintf 'interface %s usage is in:%.2f%% (%s) out:%.2f%% (%s)',
        $self->{ifDescr},
        $self->{inputUtilization},
        sprintf("%.2f%s/s", $self->{inputRate},
            ($self->opts->units ? $self->opts->units : 'Bits')),
        $self->{outputUtilization},
        sprintf("%.2f%s/s", $self->{outputRate},
            ($self->opts->units ? $self->opts->units : 'Bits'));
    $self->add_info($info);
    $self->set_thresholds(warning => 80, critical => 90);
    my $in = $self->check_thresholds($self->{inputUtilization});
    my $out = $self->check_thresholds($self->{outputUtilization});
    my $level = ($in > $out) ? $in : ($out > $in) ? $out : $in;
    $self->add_message($level, $info);
    $self->add_perfdata(
        label => $self->{ifDescr}.'_usage_in',
        value => $self->{inputUtilization},
        uom => '%',
        warning => $self->{warning},
        critical => $self->{critical},
    );
    $self->add_perfdata(
        label => $self->{ifDescr}.'_usage_out',
        value => $self->{outputUtilization},
        uom => '%',
        warning => $self->{warning},
        critical => $self->{critical},
    );
    $self->add_perfdata(
        label => $self->{ifDescr}.'_traffic_in',
        value => $self->{inputRate},
        uom => $self->opts->units,
    );
    $self->add_perfdata(
        label => $self->{ifDescr}.'_traffic_out',
        value => $self->{outputRate},
        uom => $self->opts->units,
    );
  }
}

sub dump {
  my $self = shift;
  printf "[WAN]\n";
  foreach (qw(TotalBytesSent TotalBytesReceived Layer1DownstreamMaxBitRate Layer1UpstreamMaxBitRate Layer1DownstreamMaxKBRate Layer1UpstreamMaxKBRate)) {
    printf "%s: %s\n", $_, $self->{$_};
  }
}

package UPNP::AVM::FritzBox7390::Component::SmartHomeSubsystem;

our @ISA = qw(UPNP::AVM::FritzBox7390);

use strict;
use constant { OK => 0, WARNING => 1, CRITICAL => 2, UNKNOWN => 3 };

sub new {
  my $class = shift;
  my %params = @_;
  my $self = {
    blacklisted => 0,
    info => undef,
    extendedinfo => undef,
    smart_home_devices => [],
  };
  bless $self, $class;
  $self->init(%params);
  return $self;
}

sub init {
  my $self = shift;
  if ($self->mode =~ /smarthome::device::list/) {
    $self->update_device_cache(1);
    foreach my $id (keys %{$self->{device_cache}}) {
      my $name = $self->{device_cache}->{$id}->{name};
      printf "%02d %s\n", $id, $name;
    }
  } elsif ($self->mode =~ /smarthome::device/) {
    $self->update_device_cache(0);
    my @indices = $self->get_device_indices();
    foreach my $id (map {$_->[0]} @indices) {
      my %tmp_dev = (id => $id, name => $self->{device_cache}->{$id}->{name});
      push(@{$self->{smart_home_devices}},
          UPNP::AVM::FritzBox7390::Component::SmartHomeSubsystem::Device->new(%tmp_dev));
    }
  }
}

sub check {
  my $self = shift;
  foreach (@{$self->{smart_home_devices}}) {
    $_->check();
  }
}

sub create_device_cache_file {
  my $self = shift;
  my $extension = "";
  if ($self->opts->community) {
    $extension .= Digest::MD5::md5_hex($self->opts->community);
  }
  $extension =~ s/\//_/g;
  $extension =~ s/\(/_/g;
  $extension =~ s/\)/_/g;
  $extension =~ s/\*/_/g;
  $extension =~ s/\s/_/g;
  return sprintf "%s/%s_interface_cache_%s", $NWC::Device::statefilesdir,
      $self->opts->hostname, lc $extension;
}

sub update_device_cache {
  my $self = shift;
  my $force = shift;
  my $statefile = $self->create_device_cache_file();
  my $update = time - 3600;
  if ($force || ! -f $statefile || ((stat $statefile)[9]) < ($update)) {
    $self->debug('force update of device cache');
    $self->{device_cache} = {};
    my $html = $self->http_get('/net/home_auto_overview.lua');
    my $tree  = HTML::TreeBuilder->new_from_content(Encode::decode_utf8($html));
    my $table = $tree->look_down(_tag => 'table', id => 'tHAdevices');
    my @rows = @{$table->content()};
    foreach my $row (@rows[1..$#rows]) {
      # skip the tr/th
      my %tmp_device = ();
      foreach (map {$_->as_HTML()} @{$row->content()}) {
        if (/class="c1".*img id=".*?(\d+)".*title="(.*?)"/) {
          $tmp_device{id} = $1;
        } elsif (/class="c2".*title="(.*?)"/) {
          $tmp_device{name} = $1;
        }
      }
      $self->{device_cache}->{$tmp_device{id}}->{name} = $tmp_device{name};
    }
    $self->save_device_cache();
  }
  $self->load_device_cache();
}

sub save_device_cache {
  my $self = shift;
  $self->create_statefilesdir();
  my $statefile = $self->create_device_cache_file();
  my $tmpfile = $NWC::Device::statefilesdir.'/check_nwc_health_tmp_'.$$;
  my $fh = IO::File->new();
  $fh->open(">$tmpfile");
  $fh->print(Data::Dumper::Dumper($self->{device_cache}));
  $fh->flush();
  $fh->close();
  my $ren = rename $tmpfile, $statefile;
  $self->debug(sprintf "saved %s to %s",
      Data::Dumper::Dumper($self->{device_cache}), $statefile);

}

sub load_device_cache {
  my $self = shift;
  my $statefile = $self->create_device_cache_file();
  if ( -f $statefile) {
    our $VAR1;
    eval {
      require $statefile;
    };
    if($@) {
      printf "rumms\n";
    }
    $self->debug(sprintf "load %s", Data::Dumper::Dumper($VAR1));
    $self->{device_cache} = $VAR1;
    eval {
      foreach (keys %{$self->{device_cache}}) {
        /^\d+$/ || die "newrelease";
      }
    };
    if($@) {
      $self->{device_cache} = {};
      unlink $statefile;
      delete $INC{$statefile};
      $self->update_device_cache(1);
    }
  }
}

sub get_device_indices {
  my $self = shift;
  my @indices = ();
  foreach my $id (keys %{$self->{device_cache}}) {
    my $name = $self->{device_cache}->{$id}->{name};
    if ($self->opts->name) {
      if ($self->opts->regexp) {
        my $pattern = $self->opts->name;
        if ($name =~ /$pattern/i) {
          push(@indices, [$id]);
        }
      } else {
        if ($self->opts->name =~ /^\d+$/) {
          if ($id == 1 * $self->opts->name) {
            push(@indices, [1 * $self->opts->name]);
          }
        } else {
          if (lc $name eq lc $self->opts->name) {
            push(@indices, [$id]);
          }
        }
      }
    } else {
      push(@indices, [$id]);
    }
  }
  return @indices;
}


package UPNP::AVM::FritzBox7390::Component::SmartHomeSubsystem::Device;

our @ISA = qw(UPNP::AVM::FritzBox7390::Component::SmartHomeSubsystem);

use strict;
use constant { OK => 0, WARNING => 1, CRITICAL => 2, UNKNOWN => 3 };

sub new {
  my $class = shift;
  my %params = @_;
  my $self = {
    blacklisted => 0,
    info => undef,
    extendedinfo => undef,
  };
  foreach my $param (qw(id model switched connected ain name)) {
    $self->{$param} = $params{$param};
  }
  bless $self, $class;
  $self->init(%params);
  return $self;
}

sub init {
  my $self = shift;
  if ($self->mode =~ /smarthome::device::status/) {
    my $device = $self->http_get(
        sprintf '/net/home_auto_energy_view.lua?device=%d&sub_tab=10', $self->{id});
    $device =~ /Modell<.*?><nobr>(.*?)<\/nobr>/; $self->{model} = $1;
    $device =~ /\(AIN\)<.*?><nobr>(.*?)<\/nobr>/; $self->{ain} = $1;
    $device =~ /Name<.*?><nobr>(.*?)<\/nobr>/; $self->{name} = $1;
    $device =~ /<img id="uiDeviceConnectState.*?\/images\/led_(.*?)\.gif"/; $self->{connected} = $1 eq "green" ? 1 : 0;
    $device =~ /<img id="uiDeviceSwitchState.*?\/images\/led_(.*?)\.gif"/; $self->{switched} = $1 eq "green" ? 1 : 0;
  } elsif ($self->mode =~ /smarthome::device::energy/) {
    my $json = JSON->new->allow_nonref;
    my $html = $self->http_get(
        sprintf '/net/home_auto_query.lua?id=%d&command=OutletStates', $self->{id});
    my $energy = $self->http_get(
        sprintf '/net/home_auto_query.lua?id=%d&command=EnergyStats_10&xhr=1&t%d=nocache', $self->{id}, time);
    $energy = $json->decode($energy);
    my @watts = map { /value_(\d+)/; [$1, $energy->{$_}] } grep /watt_value/, keys %{$energy}; @watts = ([0, 0]) if $#watts == -1;
    $self->{last_watt} = (map { $_->[1] / 100; } sort { $a->[0] <=> $b->[0] } @watts)[0];
    my @volts = map { /value_(\d+)/; [$1, $energy->{$_}] } grep /volt_value/, keys %{$energy}; @volts = ([0, 0]) if $#volts == -1;
    $self->{last_volt} = (map { $_->[1] / 1000; } sort { $a->[0] <=> $b->[0] } @volts)[0];
    $self->{max_watt} = $energy->{EnStats_max_value} / 100;
    $self->{min_watt} = $energy->{EnStats_min_value} / 100;
  } elsif ($self->mode =~ /smarthome::device::consumption/) {
    my $html = $self->http_get(
        sprintf '/net/home_auto_energy_view.lua?device=%d&sub_tab=10', $self->{id});
    my $tree  = HTML::TreeBuilder->new_from_content(Encode::decode_utf8($html));
    my $table = $tree->look_down(_tag => 'table', id => 'tHAconsumption');
    my @rows = @{$table->content()};
    foreach (map {$_->as_HTML();} @rows[1..$#rows]) {
      if (/Pro Tag.*?>([\d,]+)<.*?>([\d,]+)<.*?>([\d,]+)</) {
        $self->{d}->{euro} = $1;
        $self->{d}->{kwh} = $2;
        $self->{d}->{kgco2} = $3;
      } elsif (/Pro Monat.*?>([\d,]+)<.*?>([\d,]+)<.*?>([\d,]+)</) {
        $self->{m}->{euro} = $1;
        $self->{m}->{kwh} = $2;
        $self->{m}->{kgco2} = $3;
      } elsif (/Pro Jahr.*?>([\d,]+)<.*?>([\d,]+)<.*?>([\d,]+)</) {
        $self->{y}->{euro} = $1;
        $self->{y}->{kwh} = $2;
        $self->{y}->{kgco2} = $3;
      }
    }
    foreach my $t (qw(d m y)) {
      foreach my $u (qw(kwh euro kgco2)) {
        $self->{$t}->{$u} =~ s/,/./g;
      }
    }
  }
}

sub check {
  my $self = shift;
  if ($self->mode =~ /smarthome::device::status/) {
    my $info = sprintf "device %s is %sconnected and switched %s",
        $self->{name}, $self->{connected} ? "" : "not ", $self->{switched} ? "on" : "off";
    $self->add_info($info);
    if (! $self->{connected} || ! $self->{switched}) {
      $self->add_message(CRITICAL, $info);
    } else {
      $self->add_message(OK, sprintf "device %s ok", $self->{name});
    }
  } elsif ($self->mode =~ /smarthome::device::energy/) {
    my $info = sprintf "device %s consumes %.2f watts at %.2f volts",
        $self->{name}, $self->{last_watt}, $self->{last_volt};
    $self->add_info($info);
    $self->set_thresholds(
        warning => 80 / 100 * 220 * 10, 
        critical => 90 / 100 * 220 * 10);
    $self->add_message($self->check_thresholds($self->{last_watt}), $info);
    $self->add_perfdata(
        label => 'watt',
        value => $self->{last_watt},
        warning => $self->{warning},
        critical => $self->{critical},
    );
    $self->add_perfdata(
        label => 'watt_min',
        value => $self->{min_watt},
    );
    $self->add_perfdata(
        label => 'watt_max',
        value => $self->{max_watt},
    );
    $self->add_perfdata(
        label => 'volt',
        value => $self->{last_volt},
    );
  } elsif ($self->mode =~ /smarthome::device::consumption/) {
    my $i = 'kwh';
    my $info = '';
    $self->set_thresholds(warning => 1000, critical => 1000);
    if (! $self->opts->units || $self->opts->units eq 'kwh') {
      $i = 'kwh';
      $info = sprintf '%s consumes %.2f kwh per day', $self->{name}, $self->{d}->{kwh};
    } elsif ($self->opts->units eq 'euro') {
      $i = 'euro';
      $info = sprintf '%s costs %.2f euro per day', $self->{name}, $self->{d}->{euro};
    } elsif ($self->opts->units eq 'kgco2') {
      $i = 'kgco2';
      $info = sprintf '%s produces %.2f kg co2 per day', $self->{name}, $self->{d}->{kgco2};
    }
    $self->add_message($self->check_thresholds($self->{m}->{$i}), $info);
    foreach (qw(day)) {
      $self->add_perfdata(
          label => $i.'_'.$_,
          value => $self->{substr($_,0,1)}->{$i},
          warning => $self->{warning},
          critical => $self->{critical},
      );
    }
    foreach (qw(month year)) {
      $self->add_perfdata(
          label => $i.'_'.$_,
          value => $self->{substr($_,0,1)}->{$i},
      );
    }
  }
}
package UPNP::AVM::FritzBox7390;

use strict;

use constant { OK => 0, WARNING => 1, CRITICAL => 2, UNKNOWN => 3 };

our @ISA = qw(UPNP::AVM);

sub init {
  my $self = shift;
  foreach my $module (qw(HTML::TreeBuilder LWP::UserAgent Encode Digest::MD5 JSON)) {
    if (! eval "require $module") {
      $self->add_message(UNKNOWN,
          "could not find $module module");
    }
  }
  $self->{sid} = undef;
  $self->{components} = {
    interface_subsystem => undef,
    smarthome_subsystem => undef,
  };
  if (! $self->check_messages()) {
    ##$self->set_serial();
    if ($self->mode =~ /device::hardware::health/) {
      $self->analyze_environmental_subsystem();
      #$self->auto_blacklist();
      $self->check_environmental_subsystem();
    } elsif ($self->mode =~ /device::hardware::load/) {
      $self->analyze_cpu_subsystem();
      #$self->auto_blacklist();
      $self->check_cpu_subsystem();
    } elsif ($self->mode =~ /device::hardware::memory/) {
      $self->analyze_mem_subsystem();
      #$self->auto_blacklist();
      $self->check_mem_subsystem();
    } elsif ($self->mode =~ /device::interfaces/) {
      $self->analyze_interface_subsystem();
      $self->check_interface_subsystem();
    } elsif ($self->mode =~ /device::smarthome/) {
      $self->analyze_smarthome_subsystem();
      $self->check_smarthome_subsystem();
    }
  }
}

sub http_get {
  my $self = shift;
  my $page = shift;
  my $ua = LWP::UserAgent->new;
  if (! $self->{sid}) {
    my $loginurl = sprintf "http://%s/login_sid.lua", $self->opts->hostname;
    my $resp = $ua->get($loginurl);
    my $content = $resp->content();
    my $challenge = ($content =~ /<Challenge>(.*?)<\/Challenge>/ && $1);
    my $input = $challenge . '-' . $self->opts->community;
    Encode::from_to($input, 'ascii', 'utf16le');
    my $challengeresponse = $challenge . '-' . lc(Digest::MD5::md5_hex($input));
    $resp = HTTP::Request->new(POST => $loginurl);
    $resp->content_type("application/x-www-form-urlencoded");
    $resp->content("response=$challengeresponse");
    my $loginresp = $ua->request($resp);
    $content = $loginresp->content();
    $self->{sid} = ($content =~ /<SID>(.*?)<\/SID>/ && $1);
    if (! $loginresp->is_success()) {
      $self->add_message(CRITICAL, $loginresp->status_line());
    }
  }
  if ($page =~ /\?/) {
    $page .= "&sid=$self->{sid}";
  } else {
    $page .= "?sid=$self->{sid}";
  }
  my $ecourl = sprintf "http://%s/%s", $self->opts->hostname, $page;
  my $resp = $ua->get($ecourl);
  if (! $resp->is_success()) {
    $self->add_message(CRITICAL, $resp->status_line());
  }
  return $resp->content();
}

sub analyze_smarthome_subsystem {
  my $self = shift;
  $self->{components}->{smarthome_subsystem} =
      UPNP::AVM::FritzBox7390::Component::SmartHomeSubsystem->new();
}

sub analyze_interface_subsystem {
  my $self = shift;
  $self->{components}->{interface_subsystem} =
      UPNP::AVM::FritzBox7390::Component::InterfaceSubsystem->new();
}

sub analyze_cpu_subsystem {
  my $self = shift;
  my $html = $self->http_get('system/ecostat.lua');
  my $cpu = (grep /StatCPU/, split(/\n/, $html))[0];
  my @cpu = ($cpu =~ /= "(.*?)"/ && split(/,/, $1));
  $self->{cpu_usage} = $cpu[0];
}

sub analyze_mem_subsystem {
  my $self = shift;
  my $html = $self->http_get('system/ecostat.lua');
  my $ramcacheused = (grep /StatRAMCacheUsed/, split(/\n/, $html))[0];
  my @ramcacheused = ($ramcacheused =~ /= "(.*?)"/ && split(/,/, $1));
  $self->{ram_cache_used} = $ramcacheused[0];
  my $ramphysfree = (grep /StatRAMPhysFree/, split(/\n/, $html))[0];
  my @ramphysfree = ($ramphysfree =~ /= "(.*?)"/ && split(/,/, $1));
  $self->{ram_phys_free} = $ramphysfree[0];
  my $ramstrictlyused = (grep /StatRAMStrictlyUsed/, split(/\n/, $html))[0];
  my @ramstrictlyused = ($ramstrictlyused =~ /= "(.*?)"/ && split(/,/, $1));
  $self->{ram_strictly_used} = $ramstrictlyused[0];
  $self->{ram_used} = $self->{ram_strictly_used} + $self->{ram_cache_used};
}

sub check_smarthome_subsystem {
  my $self = shift;
  $self->{components}->{smarthome_subsystem}->check();
  $self->{components}->{smarthome_subsystem}->dump()
      if $self->opts->verbose >= 2;
}

sub check_interface_subsystem {
  my $self = shift;
  $self->{components}->{interface_subsystem}->check();
  $self->{components}->{interface_subsystem}->dump()
      if $self->opts->verbose >= 2;
}

sub check_cpu_subsystem {
  my $self = shift;
  $self->add_info('checking cpus');
  $self->blacklist('c', undef);
  my $info = sprintf 'cpu usage is %.2f%%', $self->{cpu_usage};
  $self->add_info($info);
  $self->set_thresholds(warning => 40, critical => 60);
  $self->add_message($self->check_thresholds($self->{cpu_usage}), $info);
  $self->add_perfdata(
      label => 'cpu_usage',
      value => $self->{cpu_usage},
      uom => '%',
      warning => $self->{warning},
      critical => $self->{critical},
  );
}

sub check_mem_subsystem {
  my $self = shift;
  $self->add_info('checking memory');
  $self->blacklist('m', undef);
  my $info = sprintf 'memory usage is %.2f%%', $self->{ram_used};
  $self->add_info($info);
  $self->set_thresholds(warning => 80, critical => 90);
  $self->add_message($self->check_thresholds($self->{ram_used}), $info);
  $self->add_perfdata(
      label => 'memory_usage',
      value => $self->{ram_used},
      uom => '%',
      warning => $self->{warning},
      critical => $self->{critical},
  );
}





package UPNP::AVM;

use strict;

use constant { OK => 0, WARNING => 1, CRITICAL => 2, UNKNOWN => 3 };

our @ISA = qw(UPNP);

sub init {
  my $self = shift;
  $self->{components} = {
      interface_subsystem => undef,
  };
  if ($self->{productname} =~ /7390/) {
    bless $self, 'UPNP::AVM::FritzBox7390';
    $self->debug('using UPNP::AVM::FritzBox7390');
  }
  $self->init();
}

package UPNP;

use strict;

use constant { OK => 0, WARNING => 1, CRITICAL => 2, UNKNOWN => 3 };

our @ISA = qw(NWC::Device);

sub init {
  my $self = shift;
  $self->{components} = {
      interface_subsystem => undef,
  };
  $self->{serial} = 'unknown';
  $self->{product} = 'unknown';
  $self->{romversion} = 'unknown';
  if (eval "require SOAP::Lite") {
    require XML::LibXML;
  } else {
    $self->add_message(CRITICAL,
        'could not find SOAP::Lite module');
  }
  if (! $self->check_messages()) {
    eval {
      my $igddesc = sprintf "http://%s:%s/igddesc.xml",
          $self->opts->hostname, $self->opts->port;
      my $parser = XML::LibXML->new();
      my $doc = $parser->parse_file($igddesc);
      my $root = $doc->documentElement();
      my $xpc = XML::LibXML::XPathContext->new( $root );
      $xpc->registerNs('n', 'urn:schemas-upnp-org:device-1-0');
      $self->{productname} = $xpc->findvalue('(//n:device)[position()=1]/n:friendlyName' );
    };
    if ($@) {
      $self->add_message(CRITICAL, $@);
    }
  }
  if (! $self->check_messages()) {
    if ($self->mode =~ /device::uptime/) {
      my $som = SOAP::Lite
          -> proxy(sprintf 'http://%s:%s/upnp/control/WANCommonIFC1',
              $self->opts->hostname, $self->opts->port)
          -> uri('urn:schemas-upnp-org:service:WANIPConnection:1')
          -> GetStatusInfo();
      $self->{uptime} = $som->valueof("//GetStatusInfoResponse/NewUptime");
      $self->{uptime} /= 60;
      my $info = sprintf 'device is up since %d minutes', $self->{uptime};
      $self->add_info($info);
      $self->set_thresholds(warning => '15:', critical => '5:');
      $self->add_message($self->check_thresholds($self->{uptime}), $info);
      $self->add_perfdata(
          label => 'uptime',
          value => $self->{uptime},
          warning => $self->{warning},
          critical => $self->{critical},
      );
      my ($code, $message) = $self->check_messages(join => ', ', join_all => ' , ');
      $NWC::Device::plugin->nagios_exit($code, $message);
    } elsif ($self->{productname} =~ /Fritz/i) {
      bless $self, 'UPNP::AVM';
      $self->debug('using UPNP::AVM');
    } else {
      $self->no_such_mode();
    }
    $self->init();
  }
}

package Server::Linux;

use strict;

use constant { OK => 0, WARNING => 1, CRITICAL => 2, UNKNOWN => 3 };

our @ISA = qw(NWC::Device);

sub init {
  my $self = shift;
  $self->{components} = {
      interface_subsystem => undef,
  };
  $self->{serial} = 'unknown';
  $self->{product} = 'unknown';
  $self->{romversion} = 'unknown';
  if (! $self->check_messages()) {
    if ($self->mode =~ /device::interfaces/) {
      $self->analyze_interface_subsystem();
      $self->check_interface_subsystem();
    }
  }
}

sub analyze_interface_subsystem {
  my $self = shift;
  $self->{components}->{interface_subsystem} =
      Server::Linux::Component::InterfaceSubsystem->new();
}

sub check_interface_subsystem {
  my $self = shift;
  $self->{components}->{interface_subsystem}->check();
  $self->{components}->{interface_subsystem}->dump()
      if $self->opts->verbose >= 2;
}

package Server::Linux::Component::InterfaceSubsystem;
our @ISA = qw(Server::Linux);

use strict;
use constant { OK => 0, WARNING => 1, CRITICAL => 2, UNKNOWN => 3 };

sub new {
  my $class = shift;
  my %params = @_;
  my $self = {
    interfaces => [],
    blacklisted => 0,
    info => undef,
    extendedinfo => undef,
  };
  bless $self, $class;
  $self->init(%params);
  return $self;
}

sub init {
  my $self = shift;
  my %params = @_;
  if ($self->mode =~ /device::interfaces::list/) {
    foreach (glob "/sys/class/net/*") {
      my $name = $_;
      next if ! -d $name;
      $name =~ s/.*\///g;
      my $tmpif = {
        ifDescr => $name,
      };
      push(@{$self->{interfaces}},
        Server::Linux::Component::InterfaceSubsystem::Interface->new(%{$tmpif}));
    }
  } else {
    foreach (glob "/sys/class/net/*") {
      my $name = $_;
      $name =~ s/.*\///g;
      if ($self->opts->name) {
        if ($self->opts->regexp) {
          my $pattern = $self->opts->name;
          if ($name !~ /$pattern/i) {
            next;
          }
        } elsif (lc $name ne lc $self->opts->name) {
          next;
        }
      }
      *SAVEERR = *STDERR;
      open ERR ,'>/dev/null';
      *STDERR = *ERR;
      my $tmpif = {
        ifDescr => $name,
        ifSpeed => (-f "/sys/class/net/$name/speed" ? do { local (@ARGV, $/) = "/sys/class/net/$name/speed"; my $x = <>; close ARGV; $x} * 1024*1024 : undef),
        ifInOctets => do { local (@ARGV, $/) = "/sys/class/net/$name/statistics/rx_bytes"; my $x = <>; close ARGV; $x},
        ifInDiscards => do { local (@ARGV, $/) = "/sys/class/net/$name/statistics/rx_dropped"; my $x = <>; close ARGV; $x},
        ifInErrors => do { local (@ARGV, $/) = "/sys/class/net/$name/statistics/rx_errors"; my $x = <>; close ARGV; $x},
        ifOutOctets => do { local (@ARGV, $/) = "/sys/class/net/$name/statistics/tx_bytes"; my $x = <>; close ARGV; $x},
        ifOutDiscards => do { local (@ARGV, $/) = "/sys/class/net/$name/statistics/tx_dropped"; my $x = <>; close ARGV; $x},
        ifOutErrors => do { local (@ARGV, $/) = "/sys/class/net/$name/statistics/tx_errors"; my $x = <>; close ARGV; $x},
      };
      *STDERR = *SAVEERR;
      foreach (keys %{$tmpif}) {
        chomp($tmpif->{$_}) if defined $tmpif->{$_};
      }
      if (defined $self->opts->ifspeed) {
        $tmpif->{ifSpeed} = $self->opts->ifspeed * 1024*1024;
      }
      if (! defined $tmpif->{ifSpeed}) {
        $self->add_message(UNKNOWN, sprintf "There is no /sys/class/net/%s/speed. Use --ifspeed", $name);
      } else {
        push(@{$self->{interfaces}},
          Server::Linux::Component::InterfaceSubsystem::Interface->new(%{$tmpif}));
      }
    }
  }
}

sub check {
  my $self = shift;
  my $errorfound = 0;
  $self->add_info('checking interfaces');
  $self->blacklist('ff', '');
  if (scalar(@{$self->{interfaces}}) == 0) {
    $self->add_message(UNKNOWN, 'no interfaces');
    return;
  }
  if ($self->mode =~ /device::interfaces::list/) {
    foreach (sort {$a->{ifDescr} cmp $b->{ifDescr}} @{$self->{interfaces}}) {
      $_->list();
    }
  } else {
    if (scalar (@{$self->{interfaces}}) == 0) {
    } else {
      foreach (@{$self->{interfaces}}) {
        $_->check();
      }
    }
  }
}

sub dump {
  my $self = shift;
  foreach (@{$self->{interfaces}}) {
    $_->dump();
  }
}


package Server::Linux::Component::InterfaceSubsystem::Interface;
our @ISA = qw(Server::Linux::Component::InterfaceSubsystem);

use strict;
use constant { OK => 0, WARNING => 1, CRITICAL => 2, UNKNOWN => 3 };

sub new {
  my $class = shift;
  my %params = @_;
  my $self = {
    ifDescr => $params{ifDescr},
    ifSpeed => $params{ifSpeed},
    ifInOctets => $params{ifInOctets},
    ifInDiscards => $params{ifInDiscards},
    ifInErrors => $params{ifInErrors},
    ifOutOctets => $params{ifOutOctets},
    ifOutDiscards => $params{ifOutDiscards},
    ifOutErrors => $params{ifOutErrors},
    blacklisted => 0,
    info => undef,
    extendedinfo => undef,
  };
  foreach my $key (keys %params) {
    $self->{$key} = 0 if ! defined $params{$key};
  }
  bless $self, $class;
  $self->init();
  return $self;
}

sub init {
  my $self = shift;
  if ($self->mode =~ /device::interfaces::traffic/) {
    $self->valdiff({name => $self->{ifDescr}}, qw(ifInOctets ifInDiscards ifInErrors ifOutOctets ifOutDiscards ifOutErrors));
  } elsif ($self->mode =~ /device::interfaces::usage/) {
    $self->valdiff({name => $self->{ifDescr}}, qw(ifInOctets ifOutOctets));
    if ($self->{ifSpeed} == 0) {
      # vlan graffl
      $self->{inputUtilization} = 0;
      $self->{outputUtilization} = 0;
    } else {
      $self->{inputUtilization} = $self->{delta_ifInOctets} * 8 * 100 /
          ($self->{delta_timestamp} * $self->{ifSpeed});
      $self->{outputUtilization} = $self->{delta_ifOutOctets} * 8 * 100 /
          ($self->{delta_timestamp} * $self->{ifSpeed});
    }
    $self->{inputRate} = $self->{delta_ifInOctets} / $self->{delta_timestamp};
    $self->{outputRate} = $self->{delta_ifOutOctets} / $self->{delta_timestamp};
    my $factor = 1/8; # default Bits
    if ($self->opts->units) {
      if ($self->opts->units eq "GB") {
        $factor = 1024 * 1024 * 1024;
      } elsif ($self->opts->units eq "MB") {
        $factor = 1024 * 1024;
      } elsif ($self->opts->units eq "KB") {
        $factor = 1024;
      } elsif ($self->opts->units eq "GBi") {
        $factor = 1024 * 1024 * 1024 / 8;
      } elsif ($self->opts->units eq "MBi") {
        $factor = 1024 * 1024 / 8;
      } elsif ($self->opts->units eq "KBi") {
        $factor = 1024 / 8;
      } elsif ($self->opts->units eq "B") {
        $factor = 1;
      } elsif ($self->opts->units eq "Bit") {
        $factor = 1/8;
      }
    }
    $self->{inputRate} /= $factor;
    $self->{outputRate} /= $factor;
  } elsif ($self->mode =~ /device::interfaces::errors/) {
    $self->valdiff({name => $self->{ifDescr}}, qw(ifInErrors ifOutErrors ifInDiscards ifOutDiscards));
    $self->{inputErrorRate} = $self->{delta_ifInErrors} 
        / $self->{delta_timestamp};
    $self->{outputErrorRate} = $self->{delta_ifOutErrors} 
        / $self->{delta_timestamp};
    $self->{inputDiscardRate} = $self->{delta_ifInDiscards} 
        / $self->{delta_timestamp};
    $self->{outputDiscardRate} = $self->{delta_ifOutDiscards} 
        / $self->{delta_timestamp};
    $self->{inputRate} = ($self->{delta_ifInErrors} + $self->{delta_ifInDiscards}) 
        / $self->{delta_timestamp};
    $self->{outputRate} = ($self->{delta_ifOutErrors} + $self->{delta_ifOutDiscards}) 
        / $self->{delta_timestamp};
  } elsif ($self->mode =~ /device::interfaces::operstatus/) {
  }
  return $self;
}

sub check {
  my $self = shift;
  $self->blacklist('if', $self->{ifDescr});
  if ($self->mode =~ /device::interfaces::traffic/) {
  } elsif ($self->mode =~ /device::interfaces::usage/) {
    my $info = sprintf 'interface %s usage is in:%.2f%% (%s) out:%.2f%% (%s)',
        $self->{ifDescr}, 
        $self->{inputUtilization}, 
        sprintf("%.2f%s/s", $self->{inputRate},
            ($self->opts->units ? $self->opts->units : 'Bits')),
        $self->{outputUtilization},
        sprintf("%.2f%s/s", $self->{outputRate},
            ($self->opts->units ? $self->opts->units : 'Bits'));
    $self->add_info($info);
    $self->set_thresholds(warning => 80, critical => 90);
    my $in = $self->check_thresholds($self->{inputUtilization});
    my $out = $self->check_thresholds($self->{outputUtilization});
    my $level = ($in > $out) ? $in : ($out > $in) ? $out : $in;
    $self->add_message($level, $info);
    $self->add_perfdata(
        label => $self->{ifDescr}.'_usage_in',
        value => $self->{inputUtilization},
        uom => '%',
        warning => $self->{warning},
        critical => $self->{critical},
    );
    $self->add_perfdata(
        label => $self->{ifDescr}.'_usage_out',
        value => $self->{outputUtilization},
        uom => '%',
        warning => $self->{warning},
        critical => $self->{critical},
    );
    $self->add_perfdata(
        label => $self->{ifDescr}.'_traffic_in',
        value => $self->{inputRate},
        uom => $self->opts->units,
    );
    $self->add_perfdata(
        label => $self->{ifDescr}.'_traffic_out',
        value => $self->{outputRate},
        uom => $self->opts->units,
    );
  } elsif ($self->mode =~ /device::interfaces::errors/) {
    my $info = sprintf 'interface %s errors in:%.2f/s out:%.2f/s '.
        'discards in:%.2f/s out:%.2f/s',
        $self->{ifDescr},
        $self->{inputErrorRate} , $self->{outputErrorRate},
        $self->{inputDiscardRate} , $self->{outputDiscardRate};
    $self->add_info($info);
    $self->set_thresholds(warning => 1, critical => 10);
    my $in = $self->check_thresholds($self->{inputRate});
    my $out = $self->check_thresholds($self->{outputRate});
    my $level = ($in > $out) ? $in : ($out > $in) ? $out : $in;
    $self->add_message($level, $info);
    $self->add_perfdata(
        label => $self->{ifDescr}.'_errors_in',
        value => $self->{inputErrorRate},
        warning => $self->{warning},
        critical => $self->{critical},
    );
    $self->add_perfdata(
        label => $self->{ifDescr}.'_errors_out',
        value => $self->{outputErrorRate},
        warning => $self->{warning},
        critical => $self->{critical},
    );
    $self->add_perfdata(
        label => $self->{ifDescr}.'_discards_in',
        value => $self->{inputDiscardRate},
        warning => $self->{warning},
        critical => $self->{critical},
    );
    $self->add_perfdata(
        label => $self->{ifDescr}.'_discards_out',
        value => $self->{outputDiscardRate},
        warning => $self->{warning},
        critical => $self->{critical},
    );
  }
}

sub list {
  my $self = shift;
  printf "%s\n", $self->{ifDescr};
}

sub dump {
  my $self = shift;
  printf "[IF_%s]\n", $self->{ifDescr};
  foreach (qw(ifDescr ifSpeed ifInOctets ifInDiscards ifInErrors ifOutOctets ifOutDiscards ifOutErrors)) {
    printf "%s: %s\n", $_, defined $self->{$_} ? $self->{$_} : 'undefined';
  }
#  printf "info: %s\n", $self->{info};
  printf "\n";
}

package NWC::CiscoIOS::Component::CpuSubsystem;
our @ISA = qw(NWC::CiscoIOS);

use strict;
use constant { OK => 0, WARNING => 1, CRITICAL => 2, UNKNOWN => 3 };

sub new {
  my $class = shift;
  my %params = @_;
  my $self = {
    cpus => [],
    blacklisted => 0,
    info => undef,
    extendedinfo => undef,
  };
  bless $self, $class;
  $self->init(%params);
  return $self;
}

sub init {
  my $self = shift;
  my %params = @_;
  my $type = 0;
  foreach ($self->get_snmp_table_objects(
      'CISCO-PROCESS-MIB', 'cpmCPUTotalTable')) {
    $_->{cpmCPUTotalIndex} ||= $type++;
    push(@{$self->{cpus}},
        NWC::CiscoIOS::Component::CpuSubsystem::Cpu->new(%{$_}));
  }
  if (scalar(@{$self->{cpus}}) == 0) {
    # maybe too old. i fake a cpu. be careful. this is a really bad hack
    my $response = $self->get_request(
        -varbindlist => [
            $NWC::Device::mibs_and_oids->{'OLD-CISCO-CPU-MIB'}->{avgBusy1},
            $NWC::Device::mibs_and_oids->{'OLD-CISCO-CPU-MIB'}->{avgBusy5},
            $NWC::Device::mibs_and_oids->{'OLD-CISCO-CPU-MIB'}->{busyPer},
        ]
    );
    if (exists $response->{$NWC::Device::mibs_and_oids->{'OLD-CISCO-CPU-MIB'}->{avgBusy1}}) {
      push(@{$self->{cpus}},
          NWC::CiscoIOS::Component::CpuSubsystem::Cpu->new(
              cpmCPUTotalPhysicalIndex => 0, #fake
              cpmCPUTotalIndex => 0, #fake
              cpmCPUTotal5sec => 0, #fake
              cpmCPUTotal5secRev => 0, #fake
              cpmCPUTotal1min => $response->{$NWC::Device::mibs_and_oids->{'OLD-CISCO-CPU-MIB'}->{avgBusy1}},
              cpmCPUTotal1minRev => $response->{$NWC::Device::mibs_and_oids->{'OLD-CISCO-CPU-MIB'}->{avgBusy1}},
              cpmCPUTotal5min => $response->{$NWC::Device::mibs_and_oids->{'OLD-CISCO-CPU-MIB'}->{avgBusy5}},
              cpmCPUTotal5minRev => $response->{$NWC::Device::mibs_and_oids->{'OLD-CISCO-CPU-MIB'}->{avgBusy5}},
              cpmCPUMonInterval => 0, #fake
              cpmCPUTotalMonIntervalValue => 0, #fake
              cpmCPUInterruptMonIntervalValue => 0, #fake
      ));
    }
  }
}

sub check {
  my $self = shift;
  my $errorfound = 0;
  $self->add_info('checking cpus');
  $self->blacklist('ff', '');
  if (scalar (@{$self->{cpus}}) == 0) {
  } else {
    foreach (@{$self->{cpus}}) {
      $_->check();
    }
  }
}


sub dump {
  my $self = shift;
  foreach (@{$self->{cpus}}) {
    $_->dump();
  }
}


package NWC::CiscoIOS::Component::CpuSubsystem::Cpu;
our @ISA = qw(NWC::CiscoIOS::Component::CpuSubsystem);

use strict;
use constant { OK => 0, WARNING => 1, CRITICAL => 2, UNKNOWN => 3 };

sub new {
  my $class = shift;
  my %params = @_;
  my $self = {
    blacklisted => 0,
    info => undef,
    extendedinfo => undef,
  };
  foreach my $param (qw(cpmCPUTotalIndex cpmCPUTotalPhysicalIndex
      cpmCPUTotal5sec cpmCPUTotal1min cpmCPUTotal5min
      cpmCPUTotal5secRev cpmCPUTotal1minRev cpmCPUTotal5minRev
      cpmCPUMonInterval cpmCPUTotalMonIntervalValue
      cpmCPUInterruptMonIntervalValue)) {
    if (exists $params{$param}) {
      $self->{$param} = $params{$param};
    }
  }
  bless $self, $class;
  if (exists $params{cpmCPUTotal5minRev}) {
    $self->{usage} = $params{cpmCPUTotal5minRev};
  } else {
    $self->{usage} = $params{cpmCPUTotal5min};
  }
  if ($self->{cpmCPUTotalPhysicalIndex}) {
    my $entPhysicalName = '1.3.6.1.2.1.47.1.1.1.1.7';
    $self->{entPhysicalName} = $self->get_request(
        -varbindlist => [$entPhysicalName.'.'.$self->{cpmCPUTotalPhysicalIndex}]
    );
    $self->{entPhysicalName} = $self->{entPhysicalName}->{$entPhysicalName.'.'.$self->{cpmCPUTotalPhysicalIndex}};
  } else {
    $self->{entPhysicalName} = $self->{cpmCPUTotalIndex};
  }
  return $self;
}

sub check {
  my $self = shift;
  $self->blacklist('c', $self->{cpmCPUTotalPhysicalIndex});
  my $info = sprintf 'cpu %s usage (5 min avg.) is %.2f%%',
      $self->{entPhysicalName}, $self->{usage};
  $self->add_info($info);
  $self->set_thresholds(warning => 80, critical => 90);
  $self->add_message($self->check_thresholds($self->{usage}), $info);
  $self->add_perfdata(
      label => 'cpu_'.$self->{entPhysicalName}.'_usage',
      value => $self->{usage},
      uom => '%',
      warning => $self->{warning},
      critical => $self->{critical},
  );
}

sub dump {
  my $self = shift;
  printf "[CPU_%s]\n", $self->{cpmCPUTotalPhysicalIndex};
  foreach (qw(cpmCPUTotalIndex cpmCPUTotalPhysicalIndex cpmCPUTotal5sec cpmCPUTotal1min cpmCPUTotal5min cpmCPUTotal5secRev cpmCPUTotal1minRev cpmCPUTotal5minRev cpmCPUMonInterval cpmCPUTotalMonIntervalValue cpmCPUInterruptMonIntervalValue)) {
    if (exists $self->{$_}) {
      printf "%s: %s\n", $_, $self->{$_};
    }
  }
  printf "info: %s\n", $self->{info};
  printf "\n";
}

package NWC::CiscoIOS::Component::MemSubsystem;
our @ISA = qw(NWC::CiscoIOS);

use strict;
use constant { OK => 0, WARNING => 1, CRITICAL => 2, UNKNOWN => 3 };

sub new {
  my $class = shift;
  my %params = @_;
  my $self = {
    runtime => $params{runtime},
    rawdata => $params{rawdata},
    mems => [],
    blacklisted => 0,
    info => undef,
    extendedinfo => undef,
  };
  bless $self, $class;
  $self->init(%params);
  return $self;
}

sub init {
  my $self = shift;
  my %params = @_;
  my $snmpwalk = $params{rawdata};
  my $ignore_redundancy = $params{ignore_redundancy};
  my $type = 0;
  foreach ($self->get_snmp_table_objects(
     'CISCO-MEMORY-POOL-MIB', 'ciscoMemoryPoolTable')) {
    $_->{ciscoMemoryPoolType} ||= $type++;
    push(@{$self->{mems}},
        NWC::CiscoIOS::Component::MemSubsystem::Mem->new(%{$_}));
  }
}

sub check {
  my $self = shift;
  my $errorfound = 0;
  $self->add_info('checking mems');
  $self->blacklist('ff', '');
  if (scalar (@{$self->{mems}}) == 0) {
  } else {
    foreach (@{$self->{mems}}) {
      $_->check();
    }
  }
}


sub dump {
  my $self = shift;
  foreach (@{$self->{mems}}) {
    $_->dump();
  }
}


package NWC::CiscoIOS::Component::MemSubsystem::Mem;
our @ISA = qw(NWC::CiscoIOS::Component::MemSubsystem);

use strict;
use constant { OK => 0, WARNING => 1, CRITICAL => 2, UNKNOWN => 3 };

sub new {
  my $class = shift;
  my %params = @_;
  my $self = {
    blacklisted => 0,
    info => undef,
    extendedinfo => undef,
  };
  foreach my $param (qw(ciscoMemoryPoolTable ciscoMemoryPoolEntry
      ciscoMemoryPoolType ciscoMemoryPoolName ciscoMemoryPoolAlternate
      ciscoMemoryPoolValid ciscoMemoryPoolUsed ciscoMemoryPoolFree
      ciscoMemoryPoolLargestFree)) {
    $self->{$param} = $params{$param};
  }
  bless $self, $class;
  $self->{usage} = 100 * $params{ciscoMemoryPoolUsed} /
      ($params{ciscoMemoryPoolFree} + $params{ciscoMemoryPoolUsed});
  return $self;
}

sub check {
  my $self = shift;
  $self->blacklist('m', $self->{ciscoMemoryPoolType});
  my $info = sprintf 'mempool %s usage is %.2f%%',
      $self->{ciscoMemoryPoolName}, $self->{usage};
  $self->add_info($info);
  if ($self->{ciscoMemoryPoolName} eq 'lsmpi_io' && 
      $self->get_snmp_object('MIB-II', 'sysDescr', 0) =~ /IOS.*XE/i) {
    # https://supportforums.cisco.com/docs/DOC-16425
    $self->force_thresholds(warning => 100, critical => 100);
  } else {
    $self->set_thresholds(warning => 80, critical => 90);
  }
  $self->add_message($self->check_thresholds($self->{usage}), $info);

  $self->add_perfdata(
      label => $self->{ciscoMemoryPoolName}.'_usage',
      value => $self->{usage},
      uom => '%',
      warning => $self->{warning},
      critical => $self->{critical}
  );
}

sub dump {
  my $self = shift;
  printf "[MEMPOOL_%s]\n", $self->{ciscoMemoryPoolType};
  foreach (qw(ciscoMemoryPoolType ciscoMemoryPoolName ciscoMemoryPoolAlternate ciscoMemoryPoolValid ciscoMemoryPoolUsed ciscoMemoryPoolFree ciscoMemoryPoolLargestFree)) {
    printf "%s: %s\n", $_, $self->{$_};
  }
  printf "info: %s\n", $self->{info};
  printf "\n";
}

package NWC::CiscoIOS::Component::EnvironmentalSubsystem;
our @ISA = qw(NWC::CiscoIOS);

use strict;
use constant { OK => 0, WARNING => 1, CRITICAL => 2, UNKNOWN => 3 };

sub new {
  my $class = shift;
  my %params = @_;
  my $self = {
    runtime => $params{runtime},
    rawdata => $params{rawdata},
    method => $params{method},
    condition => $params{condition},
    status => $params{status},
    fan_subsystem => undef,
    temperature_subsystem => undef,
    powersupply_subsystem => undef,
    voltage_subsystem => undef,
    blacklisted => 0,
    info => undef,
    extendedinfo => undef,
  };
  bless $self, $class;
  $self->init(%params);
  return $self;
}

sub init {
  my $self = shift;
  my %params = @_;
  #
  # 1.3.6.1.4.1.9.9.13.1.1.0 ciscoEnvMonPresent (irgendein typ of envmon)
  # 
  $self->{fan_subsystem} =
      NWC::CiscoIOS::Component::FanSubsystem->new(%params);
  $self->{temperature_subsystem} =
      NWC::CiscoIOS::Component::TemperatureSubsystem->new(%params);
  $self->{powersupply_subsystem} = 
      NWC::CiscoIOS::Component::SupplySubsystem->new(%params);
  $self->{voltage_subsystem} =
      NWC::CiscoIOS::Component::VoltageSubsystem->new(%params);
}

sub check {
  my $self = shift;
  my $errorfound = 0;
  $self->{fan_subsystem}->check();
  $self->{temperature_subsystem}->check();
  $self->{voltage_subsystem}->check();
  $self->{powersupply_subsystem}->check();
  if (! $self->check_messages()) {
    $self->add_message(OK, "environmental hardware working fine");
  }
}

sub dump {
  my $self = shift;
  $self->{fan_subsystem}->dump();
  $self->{temperature_subsystem}->dump();
  $self->{voltage_subsystem}->dump();
  $self->{powersupply_subsystem}->dump();
}


package NWC::CiscoIOS::Component::TemperatureSubsystem;
our @ISA = qw(NWC::CiscoIOS::Component::EnvironmentalSubsystem);

use strict;
use constant { OK => 0, WARNING => 1, CRITICAL => 2, UNKNOWN => 3 };

sub new {
  my $class = shift;
  my %params = @_;
  my $self = {
    temperatures => [],
    blacklisted => 0,
    info => undef,
    extendedinfo => undef,
  };
  bless $self, $class;
  $self->init(%params);
  return $self;
}

sub init {
  my $self = shift;
  my $tempcnt = 0;
  foreach ($self->get_snmp_table_objects(
      'CISCO-ENVMON-MIB', 'ciscoEnvMonTemperatureStatusTable')) {
    $_->{ciscoEnvMonTemperatureStatusIndex} = $tempcnt++ if (! exists $_->{ciscoEnvMonTemperatureStatusIndex});
    push(@{$self->{temperatures}},
        NWC::CiscoIOS::Component::TemperatureSubsystem::Temperature->new(%{$_}));
  }
}

sub check {
  my $self = shift;
  my $errorfound = 0;
  $self->add_info('checking temperatures');
  $self->blacklist('t', '');
  if (scalar (@{$self->{temperatures}}) == 0) {
  } else {
    foreach (@{$self->{temperatures}}) {
      $_->check();
    }
  }
}


sub dump {
  my $self = shift;
  foreach (@{$self->{temperatures}}) {
    $_->dump();
  }
}


package NWC::CiscoIOS::Component::TemperatureSubsystem::Temperature;
our @ISA = qw(NWC::CiscoIOS::Component::TemperatureSubsystem);

use strict;
use constant { OK => 0, WARNING => 1, CRITICAL => 2, UNKNOWN => 3 };

sub new {
  my $class = shift;
  my %params = @_;
  my $self = {
    blacklisted => 0,
    info => undef,
    extendedinfo => undef,
  };
  foreach my $param (qw(ciscoEnvMonTemperatureStatusIndex
      ciscoEnvMonTemperatureStatusDescr ciscoEnvMonTemperatureStatusValue
      ciscoEnvMonTemperatureThreshold ciscoEnvMonTemperatureLastShutdown
      ciscoEnvMonTemperatureState)) {
    $self->{$param} = $params{$param};
  }
  $self->{ciscoEnvMonTemperatureStatusIndex} ||= 0;
  $self->{ciscoEnvMonTemperatureLastShutdown} ||= 0;
  if ($self->{ciscoEnvMonTemperatureStatusValue}) {
    bless $self, $class;
  } else {
    bless $self, $class.'::Simple';
  }
  return $self;
}

sub check {
  my $self = shift;
  $self->blacklist('t', $self->{ciscoEnvMonTemperatureStatusIndex});
  if ($self->{ciscoEnvMonTemperatureStatusValue} >
      $self->{ciscoEnvMonTemperatureThreshold}) {
    $self->add_info(sprintf 'temperature %d %s is too high (%d of %d max = %s)',
        $self->{ciscoEnvMonTemperatureStatusIndex},
        $self->{ciscoEnvMonTemperatureStatusDescr},
        $self->{ciscoEnvMonTemperatureStatusValue},
        $self->{ciscoEnvMonTemperatureThreshold},
        $self->{ciscoEnvMonTemperatureState});
    if ($self->{ciscoEnvMonTemperatureState} eq 'warning') {
      $self->add_message(WARNING, $self->{info});
    } elsif ($self->{ciscoEnvMonTemperatureState} eq 'critical') {
      $self->add_message(CRITICAL, $self->{info});
    }
  } else {
    $self->add_info(sprintf 'temperature %d %s is %d (of %d max = normal)',
        $self->{ciscoEnvMonTemperatureStatusIndex},
        $self->{ciscoEnvMonTemperatureStatusDescr},
        $self->{ciscoEnvMonTemperatureStatusValue},
        $self->{ciscoEnvMonTemperatureThreshold},
        $self->{ciscoEnvMonTemperatureState});
  }
  $self->add_perfdata(
      label => sprintf('temp_%s', $self->{ciscoEnvMonTemperatureStatusIndex}),
      value => $self->{ciscoEnvMonTemperatureStatusValue},
      warning => $self->{ciscoEnvMonTemperatureThreshold},
      critical => undef,
  );
}

sub dump {
  my $self = shift;
  printf "[TEMP_%s]\n", $self->{ciscoEnvMonTemperatureStatusIndex};
  foreach (qw(ciscoEnvMonTemperatureStatusIndex ciscoEnvMonTemperatureStatusDescr ciscoEnvMonTemperatureStatusValue ciscoEnvMonTemperatureThreshold ciscoEnvMonTemperatureLastShutdown ciscoEnvMonTemperatureState)) {
    printf "%s: %s\n", $_, $self->{$_};
  }
  printf "info: %s\n", $self->{info};
  printf "\n";
}

package NWC::CiscoIOS::Component::TemperatureSubsystem::Temperature::Simple;
our @ISA = qw(NWC::CiscoIOS::Component::TemperatureSubsystem::Temperature);

use strict;
use constant { OK => 0, WARNING => 1, CRITICAL => 2, UNKNOWN => 3 };

sub new {
  my $class = shift;
  my %params = @_;
  my $self = {
    runtime => $params{runtime},
    ciscoEnvMonTemperatureStatusIndex => $params{ciscoEnvMonTemperatureStatusIndex} || 0,
    ciscoEnvMonTemperatureStatusDescr => $params{ciscoEnvMonTemperatureStatusDescr},
    ciscoEnvMonTemperatureState => $params{ciscoEnvMonTemperatureState},
    blacklisted => 0,
    info => undef,
    extendedinfo => undef,
  };
  bless $self, $class;
  return $self;
}

sub check {
  my $self = shift;
  $self->blacklist('t', $self->{ciscoEnvMonTemperatureStatusIndex});
  $self->add_info(sprintf 'temperature %d %s is %s',
      $self->{ciscoEnvMonTemperatureStatusIndex},
      $self->{ciscoEnvMonTemperatureStatusDescr},
      $self->{ciscoEnvMonTemperatureState});
  if ($self->{ciscoEnvMonTemperatureState} ne 'normal') {
    if ($self->{ciscoEnvMonTemperatureState} eq 'warning') {
      $self->add_message(WARNING, $self->{info});
    } elsif ($self->{ciscoEnvMonTemperatureState} eq 'critical') {
      $self->add_message(CRITICAL, $self->{info});
    }
  } else {
  }
}

sub dump {
  my $self = shift;
  printf "[TEMP_%s]\n", $self->{ciscoEnvMonTemperatureStatusIndex};
  foreach (qw(ciscoEnvMonTemperatureStatusIndex ciscoEnvMonTemperatureStatusDescr ciscoEnvMonTemperatureState)) {
    printf "%s: %s\n", $_, $self->{$_};
  }
  printf "info: %s\n", $self->{info};
  printf "\n";
}


package NWC::CiscoIOS::Component::SupplySubsystem;
our @ISA = qw(NWC::CiscoIOS::Component::EnvironmentalSubsystem);

use strict;
use constant { OK => 0, WARNING => 1, CRITICAL => 2, UNKNOWN => 3 };

sub new {
  my $class = shift;
  my %params = @_;
  my $self = {
    supplies => [],
    blacklisted => 0,
    info => undef,
    extendedinfo => undef,
  };
  bless $self, $class;
  $self->init(%params);
  return $self;
}

sub init {
  my $self = shift;
  foreach ($self->get_snmp_table_objects(
      'CISCO-ENVMON-MIB', 'ciscoEnvMonSupplyStatusTable')) {
    push(@{$self->{supplies}},
        NWC::CiscoIOS::Component::SupplySubsystem::Supply->new(%{$_}));
  }
}

sub check {
  my $self = shift;
  my $errorfound = 0;
  $self->add_info('checking supplies');
  $self->blacklist('ps', '');
  if (scalar (@{$self->{supplies}}) == 0) {
  } else {
    foreach (@{$self->{supplies}}) {
      $_->check();
    }
  }
}


sub dump {
  my $self = shift;
  foreach (@{$self->{supplies}}) {
    $_->dump();
  }
}


package NWC::CiscoIOS::Component::SupplySubsystem::Supply;
our @ISA = qw(NWC::CiscoIOS::Component::SupplySubsystem);

use strict;
use constant { OK => 0, WARNING => 1, CRITICAL => 2, UNKNOWN => 3 };

sub new {
  my $class = shift;
  my %params = @_;
  my $self = {
    blacklisted => 0,
    info => undef,
    extendedinfo => undef,
  };
  foreach my $param (qw(ciscoEnvMonSupplyStatusIndex
      ciscoEnvMonSupplyStatusDescr ciscoEnvMonSupplyState
      ciscoEnvMonSupplySource)) {
    $self->{$param} = $params{$param};
  }
  $self->{ciscoEnvMonSupplyStatusIndex} ||= 0;
  bless $self, $class;
  return $self;
}

sub check {
  my $self = shift;
  $self->blacklist('f', $self->{ciscoEnvMonSupplyStatusIndex});
  $self->add_info(sprintf 'powersupply %d (%s) is %s',
      $self->{ciscoEnvMonSupplyStatusIndex},
      $self->{ciscoEnvMonSupplyStatusDescr},
      $self->{ciscoEnvMonSupplyState});
  if ($self->{ciscoEnvMonSupplyState} eq 'notPresent') {
  } elsif ($self->{ciscoEnvMonSupplyState} ne 'normal') {
    $self->add_message(CRITICAL, $self->{info});
  }
}

sub dump {
  my $self = shift;
  printf "[PS_%s]\n", $self->{ciscoEnvMonSupplyStatusIndex};
  foreach (qw(ciscoEnvMonSupplyStatusIndex ciscoEnvMonSupplyStatusDescr ciscoEnvMonSupplyState ciscoEnvMonSupplySource)) {
    printf "%s: %s\n", $_, $self->{$_};
  }
  printf "info: %s\n", $self->{info};
  printf "\n";
}

package NWC::CiscoIOS::Component::VoltageSubsystem;
our @ISA = qw(NWC::CiscoIOS::Component::EnvironmentalSubsystem);

use strict;
use constant { OK => 0, WARNING => 1, CRITICAL => 2, UNKNOWN => 3 };

sub new {
  my $class = shift;
  my %params = @_;
  my $self = {
    voltages => [],
    blacklisted => 0,
    info => undef,
    extendedinfo => undef,
  };
  bless $self, $class;
  $self->init(%params);
  return $self;
}

sub init {
  my $self = shift;
  my $index = 0;
  foreach ($self->get_snmp_table_objects(
      'CISCO-ENVMON-MIB', 'ciscoEnvMonVoltageStatusTable')) {
    $_->{ciscoEnvMonVoltageStatusIndex} ||= $index++;
    push(@{$self->{voltages}},
        NWC::CiscoIOS::Component::VoltageSubsystem::Voltage->new(%{$_}));
  }
}

sub check {
  my $self = shift;
  my $errorfound = 0;
  $self->add_info('checking voltages');
  $self->blacklist('ff', '');
  if (scalar (@{$self->{voltages}}) == 0) {
  } else {
    foreach (@{$self->{voltages}}) {
      $_->check();
    }
  }
}


sub dump {
  my $self = shift;
  foreach (@{$self->{voltages}}) {
    $_->dump();
  }
}


package NWC::CiscoIOS::Component::VoltageSubsystem::Voltage;
our @ISA = qw(NWC::CiscoIOS::Component::VoltageSubsystem);

use strict;
use constant { OK => 0, WARNING => 1, CRITICAL => 2, UNKNOWN => 3 };

sub new {
  my $class = shift;
  my %params = @_;
  my $self = {
    blacklisted => 0,
    info => undef,
    extendedinfo => undef,
  };
  foreach my $param (qw(ciscoEnvMonVoltageStatusTable
      ciscoEnvMonVoltageStatusEntry ciscoEnvMonVoltageStatusIndex
      ciscoEnvMonVoltageStatusDescr ciscoEnvMonVoltageStatusValue
      ciscoEnvMonVoltageThresholdLow ciscoEnvMonVoltageThresholdHigh
      ciscoEnvMonVoltageLastShutdown ciscoEnvMonVoltageState)) {
    $self->{$param} = $params{$param};
  }
  bless $self, $class;
  return $self;
}

sub check {
  my $self = shift;
  $self->blacklist('v', $self->{ciscoEnvMonVoltageStatusIndex});
  $self->add_info(sprintf 'voltage %d (%s) is %s',
      $self->{ciscoEnvMonVoltageStatusIndex},
      $self->{ciscoEnvMonVoltageStatusDescr},
      $self->{ciscoEnvMonVoltageState});
  if ($self->{ciscoEnvMonVoltageState} eq 'notPresent') {
  } elsif ($self->{ciscoEnvMonVoltageState} ne 'normal') {
    $self->add_message(CRITICAL, $self->{info});
  }
  $self->add_perfdata(
      label => sprintf('mvolt_%s', $self->{ciscoEnvMonVoltageStatusIndex}),
      value => $self->{ciscoEnvMonVoltageStatusValue},
      warning => $self->{ciscoEnvMonVoltageThresholdLow},
      critical => $self->{ciscoEnvMonVoltageThresholdHigh},
  );
}

sub dump {
  my $self = shift;
  printf "[VOLTAGE_%s]\n", $self->{ciscoEnvMonVoltageStatusIndex};
  foreach (qw(ciscoEnvMonVoltageStatusTable ciscoEnvMonVoltageStatusEntry ciscoEnvMonVoltageStatusIndex ciscoEnvMonVoltageStatusDescr ciscoEnvMonVoltageStatusValue ciscoEnvMonVoltageThresholdLow ciscoEnvMonVoltageThresholdHigh ciscoEnvMonVoltageLastShutdown ciscoEnvMonVoltageState)) {
    printf "%s: %s\n", $_, $self->{$_};
  }
  printf "info: %s\n", $self->{info};
  printf "\n";
}

package NWC::CiscoIOS::Component::FanSubsystem;
our @ISA = qw(NWC::CiscoIOS::Component::EnvironmentalSubsystem);

use strict;
use constant { OK => 0, WARNING => 1, CRITICAL => 2, UNKNOWN => 3 };

sub new {
  my $class = shift;
  my %params = @_;
  my $self = {
    fans => [],
    blacklisted => 0,
    info => undef,
    extendedinfo => undef,
  };
  bless $self, $class;
  $self->init(%params);
  return $self;
}

sub init {
  my $self = shift;
  foreach ($self->get_snmp_table_objects(
      'CISCO-ENVMON-MIB', 'ciscoEnvMonFanStatusTable')) {
    push(@{$self->{fans}},
        NWC::CiscoIOS::Component::FanSubsystem::Fan->new(%{$_}));
  }
}

sub check {
  my $self = shift;
  my $errorfound = 0;
  $self->add_info('checking fans');
  $self->blacklist('ff', '');
  if (scalar (@{$self->{fans}}) == 0) {
  } else {
    foreach (@{$self->{fans}}) {
      $_->check();
    }
  }
}


sub dump {
  my $self = shift;
  foreach (@{$self->{fans}}) {
    $_->dump();
  }
}


package NWC::CiscoIOS::Component::FanSubsystem::Fan;
our @ISA = qw(NWC::CiscoIOS::Component::FanSubsystem);

use strict;
use constant { OK => 0, WARNING => 1, CRITICAL => 2, UNKNOWN => 3 };

sub new {
  my $class = shift;
  my %params = @_;
  my $self = {
    blacklisted => 0,
    info => undef,
    extendedinfo => undef,
  };
  foreach my $param (qw(ciscoEnvMonFanStatusIndex
      ciscoEnvMonFanStatusDescr ciscoEnvMonFanState)) {
    $self->{$param} = $params{$param};
  }
  $self->{ciscoEnvMonFanStatusIndex} ||= 0;
  bless $self, $class;
  return $self;
}

sub check {
  my $self = shift;
  $self->blacklist('f', $self->{ciscoEnvMonFanStatusIndex});
  $self->add_info(sprintf 'fan %d (%s) is %s',
      $self->{ciscoEnvMonFanStatusIndex},
      $self->{ciscoEnvMonFanStatusDescr},
      $self->{ciscoEnvMonFanState});
  if ($self->{ciscoEnvMonFanState} eq 'notPresent') {
  } elsif ($self->{ciscoEnvMonFanState} ne 'normal') {
    $self->add_message(CRITICAL, $self->{info});
  }
}

sub dump {
  my $self = shift;
  printf "[FAN_%s]\n", $self->{ciscoEnvMonFanStatusIndex};
  foreach (qw(ciscoEnvMonFanStatusIndex ciscoEnvMonFanStatusDescr 
      ciscoEnvMonFanState)) {
    printf "%s: %s\n", $_, $self->{$_};
  }
  printf "info: %s\n", $self->{info};
  printf "\n";
}

package NWC::CiscoIOS::Component::ConnectionSubsystem;
our @ISA = qw(NWC::CiscoIOS);

use strict;
use constant { OK => 0, WARNING => 1, CRITICAL => 2, UNKNOWN => 3 };

sub new {
  my $class = shift;
  my %params = @_;
  my $self = {
    runtime => $params{runtime},
    rawdata => $params{rawdata},
    connectionstates => [],
    blacklisted => 0,
    info => undef,
    extendedinfo => undef,
  };
  bless $self, $class;
  $self->init(%params);
  return $self;
}

sub init {
  my $self = shift;
  my %params = @_;
  my $snmpwalk = $params{rawdata};
  my $type = 0;
  foreach ($self->get_snmp_table_objects(
     'CISCO-FIREWALL-MIB', 'cfwConnectionStatTable')) {
    push(@{$self->{connectionstates}},
        NWC::CiscoIOS::Component::ConnectionSubsystem::ConnectionState->new(%{$_}));
  }
}

sub check {
  my $self = shift;
  my $errorfound = 0;
  $self->add_info('checking connection states');
  $self->blacklist('cs', '');
  if (scalar (@{$self->{connectionstates}}) == 0) {
  } else {
    foreach (@{$self->{connectionstates}}) {
      $_->check();
    }
  }
}


sub dump {
  my $self = shift;
  foreach (@{$self->{connectionstates}}) {
    $_->dump();
  }
}


package NWC::CiscoIOS::Component::ConnectionSubsystem::ConnectionState;
our @ISA = qw(NWC::CiscoIOS::Component::ConnectionSubsystem);

use strict;
use constant { OK => 0, WARNING => 1, CRITICAL => 2, UNKNOWN => 3 };

sub new {
  my $class = shift;
  my %params = @_;
  my $self = {
    blacklisted => 0,
    info => undef,
    extendedinfo => undef,
  };
  foreach (qw(cfwConnectionStatService cfwConnectionStatType cfwConnectionStatDescription
      cfwConnectionStatCount cfwConnectionStatValue)) {
    $self->{$_} = $params{$_} || "";
  }
  bless $self, $class;
  return $self;
}

sub check {
  my $self = shift;
  $self->blacklist('c', $self->{cfwConnectionStatDescription});
  if ($self->{cfwConnectionStatDescription} !~ /number of connections currently in use/i) {
    $self->add_blacklist(sprintf 'c:%s', $self->{cfwConnectionStatDescription});
    $self->add_info(sprintf '%d connections currently in use',
        $self->{cfwConnectionStatValue}||$self->{cfwConnectionStatCount}, $self->{usage});
  } else {
    my $info = sprintf '%d connections currently in use',
        $self->{cfwConnectionStatValue}, $self->{usage};
    $self->add_info($info);
    $self->set_thresholds(warning => 500000, critical => 750000);
    $self->add_message($self->check_thresholds($self->{cfwConnectionStatValue}), $info);
    $self->add_perfdata(
        label => 'connections',
        value => $self->{cfwConnectionStatValue},
        warning => $self->{warning},
        critical => $self->{critical}
    );
  }
}

sub dump {
  my $self = shift;
  printf "[CONNECTIONSTATS_%s]\n", $self->{cfwConnectionStatType};
  foreach (qw(cfwConnectionStatService cfwConnectionStatType cfwConnectionStatDescription
      cfwConnectionStatCount cfwConnectionStatValue)) {
    printf "%s: %s\n", $_, $self->{$_};
  }
  printf "info: %s\n", $self->{info};
  printf "\n";
}

package NWC::CiscoIOS;

use strict;

use constant { OK => 0, WARNING => 1, CRITICAL => 2, UNKNOWN => 3 };

our @ISA = qw(NWC::Cisco);

sub init {
  my $self = shift;
  $self->{components} = {
      powersupply_subsystem => undef,
      fan_subsystem => undef,
      temperature_subsystem => undef,
      cpu_subsystem => undef,
      memory_subsystem => undef,
      disk_subsystem => undef,
      environmental_subsystem => undef,
      connection_subsystem => undef,
  };
  $self->{serial} = 'unknown';
  $self->{product} = 'unknown';
  $self->{romversion} = 'unknown';
  # serial is 1.3.6.1.2.1.47.1.1.1.1.11.1
  #$self->collect();
  if (! $self->check_messages()) {
    ##$self->set_serial();
    if ($self->mode =~ /device::hardware::health/) {
      $self->analyze_environmental_subsystem();
      #$self->auto_blacklist();
      $self->check_environmental_subsystem();
    } elsif ($self->mode =~ /device::hardware::load/) {
      $self->analyze_cpu_subsystem();
      #$self->auto_blacklist();
      $self->check_cpu_subsystem();
    } elsif ($self->mode =~ /device::hardware::memory/) {
      $self->analyze_mem_subsystem();
      #$self->auto_blacklist();
      $self->check_mem_subsystem();
    } elsif ($self->mode =~ /device::shinken::interface/) {
      $self->analyze_interface_subsystem();
      $self->shinken_interface_subsystem();
    } elsif ($self->mode =~ /device::hsrp/) {
      $self->analyze_hsrp_subsystem();
      $self->check_hsrp_subsystem();
    } elsif ($self->mode =~ /device::users/) {
      $self->analyze_connection_subsystem();
      $self->check_connection_subsystem();
    }
  }
}

sub analyze_hsrp_subsystem {
  my $self = shift;
  $self->{components}->{hsrp_subsystem} =
      NWC::HSRP::Component::HSRPSubsystem->new();
}

sub analyze_environmental_subsystem {
  my $self = shift;
  $self->{components}->{environmental_subsystem} =
      NWC::CiscoIOS::Component::EnvironmentalSubsystem->new();
}

sub analyze_cpu_subsystem {
  my $self = shift;
  $self->{components}->{cpu_subsystem} =
      NWC::CiscoIOS::Component::CpuSubsystem->new();
}

sub analyze_mem_subsystem {
  my $self = shift;
  $self->{components}->{mem_subsystem} =
      NWC::CiscoIOS::Component::MemSubsystem->new();
}

sub analyze_connection_subsystem {
  my $self = shift;
  $self->{components}->{connection_subsystem} =
      NWC::CiscoIOS::Component::ConnectionSubsystem->new();
}

package NWC::CiscoNXOS::Component::CpuSubsystem;
our @ISA = qw(NWC::CiscoNXOS);

use strict;
use constant { OK => 0, WARNING => 1, CRITICAL => 2, UNKNOWN => 3 };

sub new {
  my $class = shift;
  my %params = @_;
  my $self = {
    cpus => [],
    blacklisted => 0,
    info => undef,
    extendedinfo => undef,
  };
  bless $self, $class;
  $self->init(%params);
  return $self;
}

sub init {
  my $self = shift;
  my %params = @_;
  my $type = 0;
  foreach ($self->get_snmp_table_objects(
      'CISCO-PROCESS-MIB', 'cpmCPUTotalTable')) {
    $_->{cpmCPUTotalIndex} ||= $type++;
    push(@{$self->{cpus}},
        NWC::CiscoNXOS::Component::CpuSubsystem::Cpu->new(%{$_}));
  }
  if (scalar(@{$self->{cpus}}) == 0) {
    # maybe too old. i fake a cpu. be careful. this is a really bad hack
    my $response = $self->get_request(
        -varbindlist => [
            $NWC::Device::mibs_and_oids->{'OLD-CISCO-CPU-MIB'}->{avgBusy1},
            $NWC::Device::mibs_and_oids->{'OLD-CISCO-CPU-MIB'}->{avgBusy5},
            $NWC::Device::mibs_and_oids->{'OLD-CISCO-CPU-MIB'}->{busyPer},
        ]
    );
    if (exists $response->{$NWC::Device::mibs_and_oids->{'OLD-CISCO-CPU-MIB'}->{avgBusy1}}) {
      push(@{$self->{cpus}},
          NWC::CiscoNXOS::Component::CpuSubsystem::Cpu->new(
              cpmCPUTotalPhysicalIndex => 0, #fake
              cpmCPUTotalIndex => 0, #fake
              cpmCPUTotal5sec => 0, #fake
              cpmCPUTotal5secRev => 0, #fake
              cpmCPUTotal1min => $response->{$NWC::Device::mibs_and_oids->{'OLD-CISCO-CPU-MIB'}->{avgBusy1}},
              cpmCPUTotal1minRev => $response->{$NWC::Device::mibs_and_oids->{'OLD-CISCO-CPU-MIB'}->{avgBusy1}},
              cpmCPUTotal5min => $response->{$NWC::Device::mibs_and_oids->{'OLD-CISCO-CPU-MIB'}->{avgBusy5}},
              cpmCPUTotal5minRev => $response->{$NWC::Device::mibs_and_oids->{'OLD-CISCO-CPU-MIB'}->{avgBusy5}},
              cpmCPUMonInterval => 0, #fake
              cpmCPUTotalMonIntervalValue => 0, #fake
              cpmCPUInterruptMonIntervalValue => 0, #fake
      ));
    }
  }
}

sub check {
  my $self = shift;
  my $errorfound = 0;
  $self->add_info('checking cpus');
  $self->blacklist('ff', '');
  if (scalar (@{$self->{cpus}}) == 0) {
  } else {
    foreach (@{$self->{cpus}}) {
      $_->check();
    }
  }
}


sub dump {
  my $self = shift;
  foreach (@{$self->{cpus}}) {
    $_->dump();
  }
}


package NWC::CiscoNXOS::Component::CpuSubsystem::Cpu;
our @ISA = qw(NWC::CiscoNXOS::Component::CpuSubsystem);

use strict;
use constant { OK => 0, WARNING => 1, CRITICAL => 2, UNKNOWN => 3 };

sub new {
  my $class = shift;
  my %params = @_;
  my $self = {
    blacklisted => 0,
    info => undef,
    extendedinfo => undef,
  };
  foreach my $param (qw(cpmCPUTotalIndex cpmCPUTotalPhysicalIndex
      cpmCPUTotal5sec cpmCPUTotal1min cpmCPUTotal5min
      cpmCPUTotal5secRev cpmCPUTotal1minRev cpmCPUTotal5minRev
      cpmCPUMonInterval cpmCPUTotalMonIntervalValue
      cpmCPUInterruptMonIntervalValue)) {
    $self->{$param} = $params{$param};
  }
  bless $self, $class;
  $self->{usage} = $params{cpmCPUTotal5minRev};
  if ($self->{cpmCPUTotalPhysicalIndex}) {
    my $entPhysicalName = '1.3.6.1.2.1.47.1.1.1.1.7';
    $self->{entPhysicalName} = $self->get_request(
        -varbindlist => [$entPhysicalName.'.'.$self->{cpmCPUTotalPhysicalIndex}]
    );
    $self->{entPhysicalName} = $self->{entPhysicalName}->{$entPhysicalName.'.'.$self->{cpmCPUTotalPhysicalIndex}};
  } else {
    $self->{entPhysicalName} = $self->{cpmCPUTotalIndex};
  }
  return $self;
}

sub check {
  my $self = shift;
  $self->blacklist('c', $self->{cpmCPUTotalPhysicalIndex});
  my $info = sprintf 'cpu %s usage (5 min avg.) is %.2f%%',
      $self->{entPhysicalName}, $self->{usage};
  $self->add_info($info);
  $self->set_thresholds(warning => 80, critical => 90);
  $self->add_message($self->check_thresholds($self->{usage}), $info);
  $self->add_perfdata(
      label => 'cpu_'.$self->{entPhysicalName}.'_usage',
      value => $self->{usage},
      uom => '%',
      warning => $self->{warning},
      critical => $self->{critical},
  );
}

sub dump {
  my $self = shift;
  printf "[CPU_%s]\n", $self->{cpmCPUTotalPhysicalIndex};
  foreach (qw(cpmCPUTotalIndex cpmCPUTotalPhysicalIndex cpmCPUTotal5sec cpmCPUTotal1min cpmCPUTotal5min cpmCPUTotal5secRev cpmCPUTotal1minRev cpmCPUTotal5minRev cpmCPUMonInterval cpmCPUTotalMonIntervalValue cpmCPUInterruptMonIntervalValue)) {
    printf "%s: %s\n", $_, $self->{$_};
  }
  printf "info: %s\n", $self->{info};
  printf "\n";
}

package NWC::CiscoNXOS::Component::MemSubsystem;
our @ISA = qw(NWC::CiscoNXOS);

use strict;
use constant { OK => 0, WARNING => 1, CRITICAL => 2, UNKNOWN => 3 };

sub new {
  my $class = shift;
  my %params = @_;
  my $self = {
    runtime => $params{runtime},
    rawdata => $params{rawdata},
    mems => [],
    blacklisted => 0,
    info => undef,
    extendedinfo => undef,
  };
  bless $self, $class;
  $self->init(%params);
  return $self;
}

sub init {
  my $self = shift;
  my %params = @_;
  my $snmpwalk = $params{rawdata};
  my $ignore_redundancy = $params{ignore_redundancy};
  my $type = 0;
  $self->{cseSysMemoryUtilization} = $self->get_snmp_object('CISCO-SYSTEM-EXT-MIB', 'cseSysMemoryUtilization');
}

sub check {
  my $self = shift;
  my $errorfound = 0;
  $self->add_info('checking memory');
  $self->blacklist('m', '');
  if (defined $self->{cseSysMemoryUtilization}) {
    my $info = sprintf 'memory usage is %.2f%%',
        $self->{cseSysMemoryUtilization};
    $self->add_info($info);
    $self->set_thresholds(warning => 80, critical => 90);
    $self->add_message($self->check_thresholds($self->{cseSysMemoryUtilization}), $info);
    $self->add_perfdata(
        label => 'memory_usage',
        value => $self->{cseSysMemoryUtilization},
        uom => '%',
        warning => $self->{warning},
        critical => $self->{critical}
    );
  } else {
    $self->add_message(UNKNOWN, 'cannot aquire momory usage');
  }
}

sub dump {
  my $self = shift;
  printf "[MEMORY]\n";
  foreach (qw(cseSysMemoryUtilization)) {
    printf "%s: %s\n", $_, $self->{$_};
  }
  printf "info: %s\n", $self->{info};
  printf "\n";
}

package NWC::CiscoNXOS::Component::EnvironmentalSubsystem;
our @ISA = qw(NWC::CiscoNXOS);

use strict;
use constant { OK => 0, WARNING => 1, CRITICAL => 2, UNKNOWN => 3 };

sub new {
  my $class = shift;
  my %params = @_;
  my $self = {
    runtime => $params{runtime},
    rawdata => $params{rawdata},
    method => $params{method},
    condition => $params{condition},
    status => $params{status},
    sensor_subsystem => undef,
    blacklisted => 0,
    info => undef,
    extendedinfo => undef,
  };
  bless $self, $class;
  $self->init(%params);
  return $self;
}

sub init {
  my $self = shift;
  my %params = @_;
  $self->{sensor_subsystem} =
      NWC::CiscoNXOS::Component::SensorSubsystem->new(%params);
}

sub check {
  my $self = shift;
  my $errorfound = 0;
  $self->{sensor_subsystem}->check();
  if (! $self->check_messages()) {
    $self->add_message(OK, "environmental hardware working fine");
  }
}

sub dump {
  my $self = shift;
  $self->{sensor_subsystem}->dump();
}


package NWC::CiscoNXOS::Component::SensorSubsystem;
our @ISA = qw(NWC::CiscoNXOS::Component::EnvironmentalSubsystem);

use strict;
use constant { OK => 0, WARNING => 1, CRITICAL => 2, UNKNOWN => 3 };

sub new {
  my $class = shift;
  my %params = @_;
  my $self = {
    sensors => [],
    sensorthresholds => [],
    blacklisted => 0,
    info => undef,
    extendedinfo => undef,
  };
  bless $self, $class;
  $self->init(%params);
  return $self;
}

sub init {
  my $self = shift;
  my $sensors = {};
  foreach ($self->get_snmp_table_objects(
      'CISCO-ENTITY-SENSOR-MIB', 'entSensorValueTable')) {
    my $sensor = NWC::CiscoNXOS::Component::SensorSubsystem::Sensor->new(%{$_});
    $sensors->{$sensor->{entPhysicalIndex}} = $sensor;
  }
  foreach ($self->get_snmp_table_objects(
      'CISCO-ENTITY-SENSOR-MIB', 'entSensorThresholdTable')) {
    my $threshold = NWC::CiscoNXOS::Component::SensorSubsystem::SensorThreshold->new(%{$_});
    if (exists $sensors->{$threshold->{entPhysicalIndex}}) {
      push(@{$sensors->{$threshold->{entPhysicalIndex}}->{thresholds}},
          $threshold);
    } else {
      printf STDERR "sensorthreshold without sensor\n";
    }
  }
#printf "%s\n", Data::Dumper::Dumper($sensors);
  foreach my $sensorid (sort {$a <=> $b} keys %{$sensors}) {
    push(@{$self->{sensors}}, $sensors->{$sensorid});
  }
}

sub check {
  my $self = shift;
  my $errorfound = 0;
  $self->add_info('checking sensors');
  $self->blacklist('t', '');
  if (scalar (@{$self->{sensors}}) == 0) {
  } else {
    foreach (@{$self->{sensors}}) {
      $_->check();
    }
  }
}


sub dump {
  my $self = shift;
  foreach (@{$self->{sensors}}) {
    $_->dump();
  }
}


package NWC::CiscoNXOS::Component::SensorSubsystem::Sensor;
our @ISA = qw(NWC::CiscoNXOS::Component::SensorSubsystem);

use strict;
use constant { OK => 0, WARNING => 1, CRITICAL => 2, UNKNOWN => 3 };

sub new {
  my $class = shift;
  my %params = @_;
  my $self = {
    blacklisted => 0,
    info => undef,
    extendedinfo => undef,
  };
  foreach my $param (qw(entSensorType entSensorScale entSensorPrecision
      entSensorValue entSensorStatus entSensorMeasuredEntity indices)) {
    $self->{$param} = $params{$param};
  }
  $self->{entPhysicalIndex} = $params{indices}[0];
  # www.thaiadmin.org%2Fboard%2Findex.php%3Faction%3Ddlattach%3Btopic%3D45832.0%3Battach%3D23494&ei=kV9zT7GHJ87EsgbEvpX6DQ&usg=AFQjCNHuHiS2MR9TIpYtu7C8bvgzuqxgMQ&cad=rja
  # zu klaeren. entPhysicalIndex entspricht dem entPhysicalindex der ENTITY-MIB.
  # In der stehen alle moeglichen Powersupplies etc.
  # Was bedeutet aber dann entSensorMeasuredEntity? gibt's eh nicht in meinen
  # Beispiel-walks
  $self->{thresholds} = [];
  $self->{entSensorMeasuredEntity} ||= 'undef';
  bless $self, $class;
  return $self;
}

sub check {
  my $self = shift;
  $self->blacklist('se', $self->{entPhysicalIndex});
  $self->add_info(sprintf '%s sensor %s is %s',
      $self->{entSensorType},
      $self->{entPhysicalIndex},
      $self->{entSensorStatus});
  if ($self->{entSensorStatus} eq "nonoperational") {
    $self->add_message(CRITICAL, $self->{info});
  } elsif ($self->{entSensorStatus} eq "unavailable") {
  } elsif (scalar(grep { $_->{entSensorThresholdEvaluation} eq "true" }
        @{$self->{thresholds}})) {
    $self->add_message(CRITICAL,
        sprintf "%s sensor %s threshold evaluation is true", 
        $self->{entSensorType},
        $self->{entPhysicalIndex});
  } else {
  }
  if (scalar(@{$self->{thresholds}} == 2)) {
    my $warning = (map { $_->{entSensorThresholdValue} } 
        grep { $_->{entSensorThresholdSeverity} eq "minor" }
        @{$self->{thresholds}})[0];
    my $critical = (map { $_->{entSensorThresholdValue} } 
        grep { $_->{entSensorThresholdSeverity} eq "major" }
        @{$self->{thresholds}})[0];
    $self->add_perfdata(
        label => sprintf('sens_%s_%s', $self->{entSensorType}, $self->{entPhysicalIndex}),
        value => $self->{entSensorValue},
        warning => $warning,
        critical => $critical,
    );
  } else {
    $self->add_perfdata(
        label => sprintf('sens_%s_%s', $self->{entSensorType}, $self->{entPhysicalIndex}),
        value => $self->{entSensorValue},
        warning => $self->{ciscoEnvMonSensorThreshold},
        critical => undef,
    );
  }
}

sub dump {
  my $self = shift;
  printf "[SENSOR_%s]\n", $self->{entPhysicalIndex};
  foreach (qw(entSensorType entSensorScale entSensorPrecision
      entSensorValue entSensorStatus entSensorMeasuredEntity)) {
    printf "%s: %s\n", $_, $self->{$_};
  }
  printf "info: %s\n", $self->{info};
  foreach my $threshold (@{$self->{thresholds}}) {
    $threshold->dump();
  }
  printf "\n";
}

package NWC::CiscoNXOS::Component::SensorSubsystem::SensorThreshold;
our @ISA = qw(NWC::CiscoNXOS::Component::SensorSubsystem);

use strict;
use constant { OK => 0, WARNING => 1, CRITICAL => 2, UNKNOWN => 3 };

sub new {
  my $class = shift;
  my %params = @_;
  my $self = {
    blacklisted => 0,
    info => undef,
    extendedinfo => undef,
  };
  foreach my $param (qw(entSensorThresholdRelation entSensorThresholdValue
      entSensorThresholdSeverity entSensorThresholdNotificationEnable
      entSensorThresholdEvaluation indices)) {
    $self->{$param} = $params{$param};
  }
  $self->{entPhysicalIndex} = $params{indices}[0];
  $self->{entSensorThresholdIndex} = $params{indices}[1];
  bless $self, $class;
  return $self;
}

sub dump {
  my $self = shift;
  printf "[SENSOR_THRESHOLD_%s_%s]\n", 
      $self->{entPhysicalIndex}, $self->{entSensorThresholdIndex};
  foreach (qw(entSensorThresholdRelation entSensorThresholdValue
      entSensorThresholdSeverity entSensorThresholdNotificationEnable
      entSensorThresholdEvaluation)) {
    printf "%s: %s\n", $_, $self->{$_};
  }
}


package NWC::CiscoNXOS;

use strict;

use constant { OK => 0, WARNING => 1, CRITICAL => 2, UNKNOWN => 3 };

our @ISA = qw(NWC::Cisco);

sub init {
  my $self = shift;
  $self->{components} = {
      powersupply_subsystem => undef,
      fan_subsystem => undef,
      temperature_subsystem => undef,
      cpu_subsystem => undef,
      memory_subsystem => undef,
      disk_subsystem => undef,
      environmental_subsystem => undef,
  };
  $self->{serial} = 'unknown';
  $self->{product} = 'unknown';
  $self->{romversion} = 'unknown';
  # serial is 1.3.6.1.2.1.47.1.1.1.1.11.1
  #$self->collect();
  if (! $self->check_messages()) {
    ##$self->set_serial();
    if ($self->mode =~ /device::hardware::health/) {
      $self->analyze_environmental_subsystem();
      #$self->auto_blacklist();
      $self->check_environmental_subsystem();
    } elsif ($self->mode =~ /device::hardware::load/) {
      $self->analyze_cpu_subsystem();
      #$self->auto_blacklist();
      $self->check_cpu_subsystem();
    } elsif ($self->mode =~ /device::hardware::memory/) {
      $self->analyze_mem_subsystem();
      #$self->auto_blacklist();
      $self->check_mem_subsystem();
    } elsif ($self->mode =~ /device::shinken::interface/) {
      $self->analyze_interface_subsystem();
      $self->shinken_interface_subsystem();
    }
  }
}

sub analyze_environmental_subsystem {
  my $self = shift;
  $self->{components}->{environmental_subsystem} =
      NWC::CiscoNXOS::Component::EnvironmentalSubsystem->new();
}

sub analyze_cpu_subsystem {
  my $self = shift;
  $self->{components}->{cpu_subsystem} =
      NWC::CiscoNXOS::Component::CpuSubsystem->new();
}

sub analyze_mem_subsystem {
  my $self = shift;
  $self->{components}->{mem_subsystem} =
      NWC::CiscoNXOS::Component::MemSubsystem->new();
}

package NWC::CiscoWLC::Component::MemSubsystem;
our @ISA = qw(NWC::CiscoWLC);

use strict;
use constant { OK => 0, WARNING => 1, CRITICAL => 2, UNKNOWN => 3 };

sub new {
  my $class = shift;
  my %params = @_;
  my $self = {
    blacklisted => 0,
    info => undef,
    extendedinfo => undef,
  };
  bless $self, $class;
  $self->init(%params);
  return $self;
}

sub init {
  my $self = shift;
  my %params = @_;
  my $type = 0;
  $self->{total_memory} = $self->get_snmp_object(
      'AIRESPACE-SWITCHING-MIB', 'agentTotalMemory');
  $self->{free_memory} = $self->get_snmp_object(
      'AIRESPACE-SWITCHING-MIB', 'agentFreeMemory');
  $self->{memory_usage} = $self->{free_memory} ? 
      ($self->{free_memory} / $self->{total_memory} * 100) : 100;
}

sub check {
  my $self = shift;
  my $info = sprintf 'memory usage is %.2f%%',
      $self->{memory_usage};
  $self->add_info($info);
  $self->set_thresholds(warning => 80, critical => 90);
  $self->add_message($self->check_thresholds($self->{memory_usage}), $info);
  $self->add_perfdata(
      label => 'memory_usage',
      value => $self->{memory_usage},
      uom => '%',
      warning => $self->{warning},
      critical => $self->{critical},
  );
}

sub dump {
  my $self = shift;
  printf "[CPU]\n";
  foreach (qw(memory_usage total_memory free_memory)) {
    if (exists $self->{$_}) {
      printf "%s: %s\n", $_, $self->{$_};
    }
  }
  printf "info: %s\n", $self->{info};
  printf "\n";
}

package NWC::CiscoWLC::Component::CpuSubsystem;
our @ISA = qw(NWC::CiscoWLC);

use strict;
use constant { OK => 0, WARNING => 1, CRITICAL => 2, UNKNOWN => 3 };

sub new {
  my $class = shift;
  my %params = @_;
  my $self = {
    cpus => [],
    blacklisted => 0,
    info => undef,
    extendedinfo => undef,
  };
  bless $self, $class;
  $self->init(%params);
  return $self;
}

sub init {
  my $self = shift;
  my %params = @_;
  my $type = 0;
  $self->{cpu_utilization} = $self->get_snmp_object(
      'AIRESPACE-SWITCHING-MIB', 'agentCurrentCPUUtilization');
}

sub check {
  my $self = shift;
  my $info = sprintf 'cpu usage is %.2f%%',
      $self->{cpu_utilization};
  $self->add_info($info);
  $self->set_thresholds(warning => 80, critical => 90);
  $self->add_message($self->check_thresholds($self->{cpu_utilization}), $info);
  $self->add_perfdata(
      label => 'cpu_usage',
      value => $self->{cpu_utilization},
      uom => '%',
      warning => $self->{warning},
      critical => $self->{critical},
  );
}

sub dump {
  my $self = shift;
  printf "[CPU]\n";
  foreach (qw(cpu_utilization)) {
    if (exists $self->{$_}) {
      printf "%s: %s\n", $_, $self->{$_};
    }
  }
  printf "info: %s\n", $self->{info};
  printf "\n";
}

package NWC::CiscoWLC::Component::EnvironmentalSubsystem;
our @ISA = qw(NWC::CiscoWLC);

use strict;
use constant { OK => 0, WARNING => 1, CRITICAL => 2, UNKNOWN => 3 };

sub new {
  my $class = shift;
  my %params = @_;
  my $self = {
    runtime => $params{runtime},
    rawdata => $params{rawdata},
    method => $params{method},
    condition => $params{condition},
    status => $params{status},
    fan_subsystem => undef,
    temperature_subsystem => undef,
    powersupply_subsystem => undef,
    voltage_subsystem => undef,
    blacklisted => 0,
    info => undef,
    extendedinfo => undef,
  };
  bless $self, $class;
  $self->init(%params);
  return $self;
}

sub init {
  my $self = shift;
  my %params = @_;
my $remarks = "
gentRadioUpDownTrapCount => '1.3.6.1.4.1.14179.1.1.2.5',
      agentApAssociateDisassociateTrapCount => '1.3.6.1.4.1.14179.1.1.2.6',
      agentApLoadProfileFailTrapCount => '1.3.6.1.4.1.14179.1.1.2.7',
      agentApNoiseProfileFailTrapCount => '1.3.6.1.4.1.14179.1.1.2.8',
      agentTrapLogTable => '1.3.6.1.4.1.14179.1.1.2.4',
      agentTrapLogEntry => '1.3.6.1.4.1.14179.1.1.2.4.1',
      agentTrapLogIndex => '1.3.6.1.4.1.14179.1.1.2.4.1.1',
      agentTrapLogSystemTime => '1.3.6.1.4.1.14179.1.1.2.4.1.2',
      agentTrapLogTrap => '1.3.6.1.4.1.14179.1.1.2.4.1.22',

";

  $self->{ps1_present} = $self->get_snmp_object(
      'AIRESPACE-SWITCHING-MIB', 'agentSwitchInfoPowerSupply1Present', 0);
  $self->{ps1_operational} = $self->get_snmp_object(
      'AIRESPACE-SWITCHING-MIB', 'agentSwitchInfoPowerSupply1Operational', 0);
  $self->{ps2_present} = $self->get_snmp_object(
      'AIRESPACE-SWITCHING-MIB', 'agentSwitchInfoPowerSupply2Present', 0);
  $self->{ps2_operational} = $self->get_snmp_object(
      'AIRESPACE-SWITCHING-MIB', 'agentSwitchInfoPowerSupply2Operational', 0);
  $self->{temp_environment} = $self->get_snmp_object(
      'AIRESPACE-WIRELESS-MIB', 'bsnOperatingTemperatureEnvironment', 0);
  $self->{temp_value} = $self->get_snmp_object(
      'AIRESPACE-WIRELESS-MIB', 'bsnSensorTemperature', 0);
  $self->{temp_alarm_low} = $self->get_snmp_object(
      'AIRESPACE-WIRELESS-MIB', 'bsnTemperatureAlarmLowLimit', 0);
  $self->{temp_alarm_high} = $self->get_snmp_object(
      'AIRESPACE-WIRELESS-MIB', 'bsnTemperatureAlarmHighLimit', 0);
}

sub check {
  my $self = shift;
  #$self->blacklist('t', $self->{cpmCPUTotalPhysicalIndex});
  my $tinfo = sprintf 'temperature is %.2fC (%s env %s-%s)',
      $self->{temp_value}, $self->{temp_environment},
      $self->{temp_alarm_low}, $self->{temp_alarm_high};
  $self->set_thresholds(
      warning => $self->{temp_alarm_low}.':'.$self->{temp_alarm_high},
      critical => $self->{temp_alarm_low}.':'.$self->{temp_alarm_high});
  $self->add_message($self->check_thresholds($self->{temp_value}), $tinfo);
  $self->add_perfdata(
      label => 'temperature',
      value => $self->{temp_value},
      warning => $self->{warning},
      critical => $self->{critical},
  );
  if ($self->{ps1_present} eq "true") {
    if ($self->{ps1_operational} ne "true") {
      $self->add_message(WARNING, "Powersupply 1 is not operational");
    }
  }
  if ($self->{ps2_present} eq "true") {
    if ($self->{ps2_operational} ne "true") {
      $self->add_message(WARNING, "Powersupply 2 is not operational");
    }
  }
  my $p1info = sprintf "PS1 is %spresent and %soperational",
      $self->{ps1_present} eq "true" ? "" : "not ",
      $self->{ps1_operational} eq "true" ? "" : "not ";
  my $p2info = sprintf "PS2 is %spresent and %soperational",
      $self->{ps2_present} eq "true" ? "" : "not ",
      $self->{ps2_operational} eq "true" ? "" : "not ";
  $self->add_info($tinfo.", ".$p1info.", ".$p2info);
}

sub dump {
  my $self = shift;
  printf "[TEMPERATURE]\n";
  foreach (qw(temp_environment temp_value temp_alarm_low temp_alarm_high)) {
    if (exists $self->{$_}) {
      printf "%s: %s\n", $_, $self->{$_};
    }
  }
  printf "[PS1]\n";
  foreach (qw(ps1_present ps1_operational)) {
    if (exists $self->{$_}) {
      printf "%s: %s\n", $_, $self->{$_};
    }
  }
  printf "[PS2]\n";
  foreach (qw(ps2_present ps2_operational)) {
    if (exists $self->{$_}) {
      printf "%s: %s\n", $_, $self->{$_};
    }
  }
  printf "info: %s\n", $self->{info};
  printf "\n";
}

package NWC::CiscoWLC::Component::WlanSubsystem;
our @ISA = qw(NWC::CiscoWLC);

use strict;
use constant { OK => 0, WARNING => 1, CRITICAL => 2, UNKNOWN => 3 };

sub new {
  my $class = shift;
  my %params = @_;
  my $self = {
    runtime => $params{runtime},
    rawdata => $params{rawdata},
    aps => [],
    ifs => [],
    ifloads => [],
    blacklisted => 0,
    info => undef,
    extendedinfo => undef,
  };
  bless $self, $class;
  $self->init(%params);
  return $self;
}

sub init {
  my $self = shift;
  my %params = @_;
  my $snmpwalk = $params{rawdata};
  my $ignore_redundancy = $params{ignore_redundancy};
  my $type = 0;
  $self->{name} = $self->get_snmp_object(
     'MIB-II', 'sysName', 0);
  foreach ($self->get_snmp_table_objects(
     'AIRESPACE-WIRELESS-MIB', 'bsnAPTable')) {
    if ($self->filter_name($_->{bsnAPName})) {
      push(@{$self->{aps}},
          NWC::CiscoWLC::Component::WlanSubsystem::AP->new(%{$_}));
    }
  }
  foreach ($self->get_snmp_table_objects(
     'AIRESPACE-WIRELESS-MIB', 'bsnAPIfTable')) {
    push(@{$self->{ifs}},
        NWC::CiscoWLC::Component::WlanSubsystem::IF->new(%{$_}));
  }
  foreach ($self->get_snmp_table_objects(
     'AIRESPACE-WIRELESS-MIB', 'bsnAPIfLoadParametersTable')) {
    push(@{$self->{ifloads}},
        NWC::CiscoWLC::Component::WlanSubsystem::IFLoad->new(%{$_}));
  }
  $self->assign_loads_to_ifs();
  $self->assign_ifs_to_aps();
}

sub check {
  my $self = shift;
  my $errorfound = 0;
  $self->add_info('checking access points');
  $self->blacklist('ap', '');
  $self->{numOfAPs} = scalar (@{$self->{aps}});
  $self->{apNameList} = [map { $_->{bsnAPName} } @{$self->{aps}}];
  if (scalar (@{$self->{aps}}) == 0) {
    $self->add_message(UNKNOWN, 'no access points found');
  } else {
    foreach (@{$self->{aps}}) {
      $_->check();
    }
    if ($self->mode =~ /device::wlan::aps::watch/) {
      $self->opts->override_opt('lookback', 1800) if ! $self->opts->lookback;
      $self->valdiff({name => $self->{name}, lastarray => 1},
          qw(apNameList numOfAPs));
      if (scalar(@{$self->{delta_found_apNameList}}) > 0) {
      #if (scalar(@{$self->{delta_found_apNameList}}) > 0 &&
      #    $self->{delta_timestamp} > $self->opts->lookback) {
        $self->add_message(WARNING, sprintf '%d new access points (%s)',
            scalar(@{$self->{delta_found_apNameList}}),
            join(", ", @{$self->{delta_found_apNameList}}));
      }
      if (scalar(@{$self->{delta_lost_apNameList}}) > 0) {
        $self->add_message(CRITICAL, sprintf '%d access points missing (%s)',
            scalar(@{$self->{delta_lost_apNameList}}),
            join(", ", @{$self->{delta_lost_apNameList}}));
      }
      $self->add_message(OK,
          sprintf 'found %d access points', scalar (@{$self->{aps}}));
      $self->add_perfdata(
          label => 'num_aps',
          value => scalar (@{$self->{aps}}),
      );
    } elsif ($self->mode =~ /device::wlan::aps::count/) {
      $self->set_thresholds(warning => '10:', critical => '5:');
      $self->add_message($self->check_thresholds(
          scalar (@{$self->{aps}})), 
          sprintf 'found %d access points', scalar (@{$self->{aps}}));
      $self->add_perfdata(
          label => 'num_aps',
          value => scalar (@{$self->{aps}}),
          warning => $self->{warning},
          critical => $self->{critical},
      );
    } elsif ($self->mode =~ /device::wlan::aps::status/) {
      if ($self->opts->report eq "short") {
        $self->clear_messages(OK);
        $self->add_message(OK, 'no problems') if ! $self->check_messages();
      }
    } elsif ($self->mode =~ /device::wlan::aps::list/) {
      foreach (@{$self->{aps}}) {
        printf "%s\n", $_->{bsnAPName};
      }
    }
  }
}

sub dump {
  my $self = shift;
  foreach (@{$self->{aps}}) {
    $_->dump();
  }
}

sub assign_ifs_to_aps {
  my $self = shift;
  foreach my $ap (@{$self->{aps}}) {
    $ap->{interfaces} = [];
    foreach my $if (@{$self->{ifs}}) {
      if ($if->{flat_indices} eq $ap->{bsnAPDot3MacAddress}.".".$if->{bsnAPIfSlotId}) {
        push(@{$ap->{interfaces}}, $if);
      }
    }
    $ap->{NumOfClients} = 0;
    map {$ap->{NumOfClients} += $_->{bsnAPIfLoadNumOfClients} }
        @{$ap->{interfaces}};
  }
}

sub assign_loads_to_ifs {
  my $self = shift;
  foreach my $if (@{$self->{ifs}}) {
    foreach my $load (@{$self->{ifloads}}) {
      if ($load->{flat_indices} eq $if->{flat_indices}) {
        map { $if->{$_} = $load->{$_} } grep { $_ !~ /indices/ } keys %{$load};
      }
    }
  }
}

package NWC::CiscoWLC::Component::WlanSubsystem::IF;
our @ISA = qw(NWC::CiscoWLC::Component::WlanSubsystem);

use strict;
use constant { OK => 0, WARNING => 1, CRITICAL => 2, UNKNOWN => 3 };

sub new {
  my $class = shift;
  my %params = @_;
  my $self = {
    blacklisted => 0,
    info => undef,
    extendedinfo => undef,
  };
  foreach (qw(bsnApIfNoOfUsers bsnAPIfPortNumber bsnAPIfAdminStatus bsnAPIfSlotId bsnAPIfType bsnAPIfOperStatus flat_indices)) {
    $self->{$_} = $params{$_};
  }
  bless $self, $class;
  return $self;
}

package NWC::CiscoWLC::Component::WlanSubsystem::IFLoad;
our @ISA = qw(NWC::CiscoWLC::Component::WlanSubsystem);

use strict;
use constant { OK => 0, WARNING => 1, CRITICAL => 2, UNKNOWN => 3 };

sub new {
  my $class = shift;
  my %params = @_;
  my $self = {
    blacklisted => 0,
    info => undef,
    extendedinfo => undef,
  };
  foreach (keys %params) {
    $self->{$_} = $params{$_};
  }
  bless $self, $class;
  return $self;
}

package NWC::CiscoWLC::Component::WlanSubsystem::AP;
our @ISA = qw(NWC::CiscoWLC::Component::WlanSubsystem);

use strict;
use constant { OK => 0, WARNING => 1, CRITICAL => 2, UNKNOWN => 3 };

sub new {
  my $class = shift;
  my %params = @_;
  my $self = {
    blacklisted => 0,
    info => undef,
    extendedinfo => undef,
  };
  foreach (qw(bsnAPName bsnAPLocation bsnAPModel bsnApIpAddress bsnAPSerialNumber
      bsnAPDot3MacAddress bsnAPIOSVersion bsnAPGroupVlanName bsnAPPrimaryMwarName
      bsnAPSecondaryMwarName bsnAPType bsnAPPortNumber bsnAPOperationStatus)) {
    $self->{$_} = $params{$_};
  }
  bless $self, $class;
  if ($self->{bsnAPDot3MacAddress} =~ /0x(\w{2})(\w{2})(\w{2})(\w{2})(\w{2})(\w{2})/) {
    $self->{bsnAPDot3MacAddress} = join(".", map { hex($_) } ($1, $2, $3, $4, $5, $6));
  }
  return $self;
}

sub check {
  my $self = shift;
  $self->blacklist('ap', $self->{bsnAPName});
  my $info = sprintf 'access point %s is %s (%d interfaces with %d clients)',
      $self->{bsnAPName}, $self->{bsnAPOperationStatus},
      scalar(@{$self->{interfaces}}), $self->{NumOfClients};
  $self->add_info($info);
  if ($self->mode =~ /device::wlan::aps::status/) {
    if ($self->{bsnAPOperationStatus} eq 'disassociating') {
      $self->add_message(CRITICAL, $info);
    } elsif ($self->{bsnAPOperationStatus} eq 'downloading') {
      # das verschwindet hoffentlich noch vor dem HARD-state
      $self->add_message(WARNING, $info);
    } elsif ($self->{bsnAPOperationStatus} eq 'associated') {
      $self->add_message(OK, $info);
    } else {
      $self->add_message(UNKNOWN, $info);
    }
  }
}

sub dump {
  my $self = shift;
  printf "[ACCESSPOINT_%s]\n", $self->{bsnAPName};
  foreach (qw(bsnAPName bsnAPLocation bsnAPModel bsnApIpAddress bsnAPSerialNumber
      bsnAPDot3MacAddress bsnAPIOSVersion bsnAPGroupVlanName bsnAPPrimaryMwarName
      bsnAPSecondaryMwarName bsnAPType bsnAPPortNumber bsnAPOperationStatus)) {
    printf "%s: %s\n", $_, $self->{$_};
  }
  printf "info: %s\n", $self->{info};
  printf "\n";
}

package NWC::CiscoWLC;

use strict;

use constant { OK => 0, WARNING => 1, CRITICAL => 2, UNKNOWN => 3 };

our @ISA = qw(NWC::Cisco);

sub init {
  my $self = shift;
  $self->{components} = {
      powersupply_subsystem => undef,
      fan_subsystem => undef,
      temperature_subsystem => undef,
      cpu_subsystem => undef,
      memory_subsystem => undef,
      disk_subsystem => undef,
      environmental_subsystem => undef,
  };
  $self->{serial} = 'unknown';
  $self->{product} = 'unknown';
  $self->{romversion} = 'unknown';
  # serial is 1.3.6.1.2.1.47.1.1.1.1.11.1
  #$self->collect();
  if (! $self->check_messages()) {
    ##$self->set_serial();
    if ($self->mode =~ /device::hardware::health/) {
      $self->analyze_environmental_subsystem();
      #$self->auto_blacklist();
      $self->check_environmental_subsystem();
    } elsif ($self->mode =~ /device::hardware::load/) {
      $self->analyze_cpu_subsystem();
      #$self->auto_blacklist();
      $self->check_cpu_subsystem();
    } elsif ($self->mode =~ /device::hardware::memory/) {
      $self->analyze_mem_subsystem();
      #$self->auto_blacklist();
      $self->check_mem_subsystem();
    } elsif ($self->mode =~ /device::wlan/) {
      $self->analyze_wlan_subsystem();
      $self->check_wlan_subsystem();
    } elsif ($self->mode =~ /device::shinken::interface/) {
      $self->analyze_interface_subsystem();
      $self->shinken_interface_subsystem();
    }
  }
}

sub analyze_environmental_subsystem {
  my $self = shift;
  $self->{components}->{environmental_subsystem} =
      NWC::CiscoWLC::Component::EnvironmentalSubsystem->new();
}

sub analyze_cpu_subsystem {
  my $self = shift;
  $self->{components}->{cpu_subsystem} =
      NWC::CiscoWLC::Component::CpuSubsystem->new();
}

sub analyze_mem_subsystem {
  my $self = shift;
  $self->{components}->{mem_subsystem} =
      NWC::CiscoWLC::Component::MemSubsystem->new();
}

sub analyze_wlan_subsystem {
  my $self = shift;
  $self->{components}->{wlan_subsystem} =
      NWC::CiscoWLC::Component::WlanSubsystem->new();
}

package NWC::CiscoAsyncOS::Component::KeySubsystem;
our @ISA = qw(NWC::CiscoAsyncOS::Component);

use strict;
use constant { OK => 0, WARNING => 1, CRITICAL => 2, UNKNOWN => 3 };

sub new {
  my $class = shift;
  my %params = @_;
  my $self = {
    keys => [],
    blacklisted => 0,
    info => undef,
    extendedinfo => undef,
  };
  bless $self, $class;
  $self->init(%params);
  return $self;
}

sub init {
  my $self = shift;
  foreach ($self->get_snmp_table_objects(
      'ASYNCOS-MAIL-MIB', 'keyExpirationTable')) {
    push(@{$self->{keys}},
        NWC::CiscoAsyncOS::Component::KeySubsystem::Key->new(%{$_}));
  }
}

sub check {
  my $self = shift;
  my $errorfound = 0;
  $self->add_info('checking keys');
  $self->blacklist('k', '');
  if (scalar (@{$self->{keys}}) == 0) {
  } else {
    foreach (@{$self->{keys}}) {
      $_->check();
    }
  }
}


sub dump {
  my $self = shift;
  foreach (@{$self->{keys}}) {
    $_->dump();
  }
}


package NWC::CiscoAsyncOS::Component::KeySubsystem::Key;
our @ISA = qw(NWC::CiscoAsyncOS::Component::KeySubsystem);

use strict;
use constant { OK => 0, WARNING => 1, CRITICAL => 2, UNKNOWN => 3 };

sub new {
  my $class = shift;
  my %params = @_;
  my $self = {
    blacklisted => 0,
    info => undef,
    extendedinfo => undef,
  };
  foreach (qw(keyExpirationIndex keyDescription keyIsPerpetual keySecondsUntilExpire)) {
    $self->{$_} = $params{$_};
  }
  bless $self, $class;
  return $self;
}

sub check {
  my $self = shift;
  $self->blacklist('k', $self->{keyExpirationIndex});
  $self->{keyDaysUntilExpire} = int($self->{keySecondsUntilExpire} / 86400);
  if ($self->{keyIsPerpetual} eq 'true') {
    $self->add_info(sprintf 'perpetual key %d (%s) never expires',
        $self->{keyExpirationIndex},
        $self->{keyDescription});
    $self->add_message(OK, $self->{info});
  } else {
    $self->add_info(sprintf 'key %d (%s) expires in %d days',
        $self->{keyExpirationIndex},
        $self->{keyDescription},
        $self->{keyDaysUntilExpire});
    $self->set_thresholds(warning => '14:', critical => '7:');
    $self->add_message($self->check_thresholds($self->{keyDaysUntilExpire}), $self->{info});
  }
  $self->add_perfdata(
      label => sprintf('lifetime_%s', $self->{keyDaysUntilExpire}),
      value => $self->{keyDaysUntilExpire},
      warning => $self->{warning},
      critical => $self->{critical},
  );
}

sub dump {
  my $self = shift;
  printf "[KEY%s]\n", $self->{keyExpirationIndex};
  foreach (qw(keyExpirationIndex keyDescription keyIsPerpetual keyDaysUntilExpire keySecondsUntilExpire)) {
    printf "%s: %s\n", $_, $self->{$_};
  }
  printf "info: %s\n", $self->{info};
  printf "\n";
}

package NWC::CiscoAsyncOS::Component::MemSubsystem;
our @ISA = qw(NWC::CiscoAsyncOS);

use strict;
use constant { OK => 0, WARNING => 1, CRITICAL => 2, UNKNOWN => 3 };

sub new {
  my $class = shift;
  my %params = @_;
  my $self = {
    cpus => [],
    blacklisted => 0,
    info => undef,
    extendedinfo => undef,
  };
  bless $self, $class;
  $self->init(%params);
  return $self;
}

sub init {
  my $self = shift;
  my %params = @_;
  $self->{perCentMemoryUtilization} = $self->get_snmp_object('ASYNCOS-MAIL-MIB', 'perCentMemoryUtilization');
  $self->{memoryAvailabilityStatus} = $self->get_snmp_object('ASYNCOS-MAIL-MIB', 'memoryAvailabilityStatus');
}

sub check {
  my $self = shift;
  my $errorfound = 0;
  $self->add_info('checking memory');
  $self->blacklist('m');
  my $info = sprintf 'memory usage is %.2f%% (%s)',
      $self->{perCentMemoryUtilization}, $self->{memoryAvailabilityStatus};
  $self->add_info($info);
  $self->set_thresholds(warning => 80, critical => 90);
  if ($self->check_thresholds($self->{perCentMemoryUtilization})) {
    $self->add_message($self->check_thresholds($self->{perCentMemoryUtilization}), $info);
  } elsif ($self->{memoryAvailabilityStatus} eq 'memoryShortage') {
    $self->add_message(WARNING, $info);
    $self->set_thresholds(warning => $self->{perCentMemoryUtilization}, critical => 90);
  } elsif ($self->{memoryAvailabilityStatus} eq 'memoryFull') {
    $self->add_message(CRITICAL, $info);
    $self->set_thresholds(warning => 80, critical => $self->{perCentMemoryUtilization});
  } else {
    $self->add_message(OK, $info);
  }
  $self->add_perfdata(
      label => 'memory_usage',
      value => $self->{perCentMemoryUtilization},
      uom => '%',
      warning => $self->{warning},
      critical => $self->{critical},
  );
}


sub dump {
  my $self = shift;
  printf "[MEMORY]\n";
  printf "perCentMemoryUtilization: %s\n", $self->{perCentMemoryUtilization};
  printf "memoryAvailabilityStatus: %s\n", $self->{memoryAvailabilityStatus};
}


package NWC::CiscoAsyncOS::Component::CpuSubsystem;
our @ISA = qw(NWC::CiscoAsyncOS);

use strict;
use constant { OK => 0, WARNING => 1, CRITICAL => 2, UNKNOWN => 3 };

sub new {
  my $class = shift;
  my %params = @_;
  my $self = {
    cpus => [],
    blacklisted => 0,
    info => undef,
    extendedinfo => undef,
  };
  bless $self, $class;
  $self->init(%params);
  return $self;
}

sub init {
  my $self = shift;
  my %params = @_;
  $self->{perCentCPUUtilization} = $self->get_snmp_object('ASYNCOS-MAIL-MIB', 'perCentCPUUtilization');
}

sub check {
  my $self = shift;
  my $errorfound = 0;
  $self->add_info('checking cpus');
  $self->blacklist('c');
  my $info = sprintf 'cpu usage is %.2f%%',
      $self->{perCentCPUUtilization};
  $self->add_info($info);
  $self->set_thresholds(warning => 80, critical => 90);
  $self->add_message($self->check_thresholds($self->{perCentCPUUtilization}), $info);
  $self->add_perfdata(
      label => 'cpu_usage',
      value => $self->{perCentCPUUtilization},
      uom => '%',
      warning => $self->{warning},
      critical => $self->{critical},
  );
}


sub dump {
  my $self = shift;
  printf "[CPU]\n";
  printf "perCentCPUUtilization: %s\n", $self->{perCentCPUUtilization};
}


package NWC::CiscoAsyncOS::Component::TemperatureSubsystem;
our @ISA = qw(NWC::CiscoAsyncOS::Component::EnvironmentalSubsystem);

use strict;
use constant { OK => 0, WARNING => 1, CRITICAL => 2, UNKNOWN => 3 };

sub new {
  my $class = shift;
  my %params = @_;
  my $self = {
    temperatures => [],
    blacklisted => 0,
    info => undef,
    extendedinfo => undef,
  };
  bless $self, $class;
  $self->init(%params);
  return $self;
}

sub init {
  my $self = shift;
  my $tempcnt = 0;
  foreach ($self->get_snmp_table_objects(
      'ASYNCOS-MAIL-MIB', 'temperatureTable')) {
    push(@{$self->{temperatures}},
        NWC::CiscoAsyncOS::Component::TemperatureSubsystem::Temperature->new(%{$_}));
  }
}

sub check {
  my $self = shift;
  my $errorfound = 0;
  $self->add_info('checking temperatures');
  $self->blacklist('t', '');
  if (scalar (@{$self->{temperatures}}) == 0) {
  } else {
    foreach (@{$self->{temperatures}}) {
      $_->check();
    }
  }
}


sub dump {
  my $self = shift;
  foreach (@{$self->{temperatures}}) {
    $_->dump();
  }
}


package NWC::CiscoAsyncOS::Component::TemperatureSubsystem::Temperature;
our @ISA = qw(NWC::CiscoAsyncOS::Component::TemperatureSubsystem);

use strict;
use constant { OK => 0, WARNING => 1, CRITICAL => 2, UNKNOWN => 3 };

sub new {
  my $class = shift;
  my %params = @_;
  my $self = {
    blacklisted => 0,
    info => undef,
    extendedinfo => undef,
  };
  foreach (qw(temperatureIndex degreesCelsius temperatureName)) {
    $self->{$_} = $params{$_};
  }
  bless $self, $class;
  return $self;
}

sub check {
  my $self = shift;
  $self->blacklist('t', $self->{temperatureIndex});
  $self->set_thresholds(warning => 60, critical => 70);
  $self->add_info(sprintf 'temperature %d (%s) is %s degree C',
        $self->{temperatureIndex},
        $self->{temperatureName},
        $self->{degreesCelsius});
  if ($self->check_thresholds($self->{degreesCelsius})) {
    $self->add_message($self->check_thresholds($self->{degreesCelsius}),
        $self->{info});
  }
  $self->add_perfdata(
      label => sprintf('temp_%s', $self->{temperatureIndex}),
      value => $self->{degreesCelsius},
      warning => $self->{warning},
      critical => $self->{critical},
  );
}

sub dump {
  my $self = shift;
  printf "[TEMP_%s]\n", $self->{temperatureIndex};
  foreach (qw(temperatureIndex degreesCelsius temperatureName)) {
    printf "%s: %s\n", $_, $self->{$_};
  }
  printf "info: %s\n", $self->{info};
  printf "\n";
}

package NWC::CiscoAsyncOS::Component::SupplySubsystem;
our @ISA = qw(NWC::CiscoAsyncOS::Component::EnvironmentalSubsystem);

use strict;
use constant { OK => 0, WARNING => 1, CRITICAL => 2, UNKNOWN => 3 };

sub new {
  my $class = shift;
  my %params = @_;
  my $self = {
    supplies => [],
    blacklisted => 0,
    info => undef,
    extendedinfo => undef,
  };
  bless $self, $class;
  $self->init(%params);
  return $self;
}

sub init {
  my $self = shift;
  foreach ($self->get_snmp_table_objects(
      'ASYNCOS-MAIL-MIB', 'powerSupplyTable')) {
    push(@{$self->{supplies}},
        NWC::CiscoAsyncOS::Component::SupplySubsystem::Supply->new(%{$_}));
  }
}

sub check {
  my $self = shift;
  my $errorfound = 0;
  $self->add_info('checking supplies');
  $self->blacklist('ps', '');
  if (scalar (@{$self->{supplies}}) == 0) {
  } else {
    foreach (@{$self->{supplies}}) {
      $_->check();
    }
  }
}


sub dump {
  my $self = shift;
  foreach (@{$self->{supplies}}) {
    $_->dump();
  }
}


package NWC::CiscoAsyncOS::Component::SupplySubsystem::Supply;
our @ISA = qw(NWC::CiscoAsyncOS::Component::SupplySubsystem);

use strict;
use constant { OK => 0, WARNING => 1, CRITICAL => 2, UNKNOWN => 3 };

sub new {
  my $class = shift;
  my %params = @_;
  my $self = {
    blacklisted => 0,
    info => undef,
    extendedinfo => undef,
  };
  foreach (qw(powerSupplyIndex powerSupplyStatus powerSupplyRedundancy
      powerSupplyName)) {
    $self->{$_} = $params{$_};
  }
  bless $self, $class;
  return $self;
}

sub check {
  my $self = shift;
  $self->blacklist('p', $self->{powerSupplyIndex});
  $self->add_info(sprintf 'powersupply %d (%s) has status %s',
      $self->{powerSupplyIndex},
      $self->{powerSupplyName},
      $self->{powerSupplyStatus});
  if ($self->{powerSupplyStatus} eq 'powerSupplyNotInstalled') {
  } elsif ($self->{powerSupplyStatus} ne 'powerSupplyHealthy') {
    $self->add_message(CRITICAL, $self->{info});
  }
}

sub dump {
  my $self = shift;
  printf "[PS_%s]\n", $self->{powerSupplyIndex};
  foreach (qw(powerSupplyIndex powerSupplyStatus powerSupplyRedundancy
      powerSupplyName)) {
    printf "%s: %s\n", $_, $self->{$_};
  }
  printf "info: %s\n", $self->{info};
  printf "\n";
}

package NWC::CiscoAsyncOS::Component::FanSubsystem;
our @ISA = qw(NWC::CiscoAsyncOS::Component::EnvironmentalSubsystem);

use strict;
use constant { OK => 0, WARNING => 1, CRITICAL => 2, UNKNOWN => 3 };

sub new {
  my $class = shift;
  my %params = @_;
  my $self = {
    fans => [],
    blacklisted => 0,
    info => undef,
    extendedinfo => undef,
  };
  bless $self, $class;
  $self->init(%params);
  return $self;
}

sub init {
  my $self = shift;
  foreach ($self->get_snmp_table_objects(
      'ASYNCOS-MAIL-MIB', 'fanTable')) {
    push(@{$self->{fans}},
        NWC::CiscoAsyncOS::Component::FanSubsystem::Fan->new(%{$_}));
  }
}

sub check {
  my $self = shift;
  my $errorfound = 0;
  $self->add_info('checking fans');
  $self->blacklist('ff', '');
  if (scalar (@{$self->{fans}}) == 0) {
  } else {
    foreach (@{$self->{fans}}) {
      $_->check();
    }
  }
}


sub dump {
  my $self = shift;
  foreach (@{$self->{fans}}) {
    $_->dump();
  }
}


package NWC::CiscoAsyncOS::Component::FanSubsystem::Fan;
our @ISA = qw(NWC::CiscoAsyncOS::Component::FanSubsystem);

use strict;
use constant { OK => 0, WARNING => 1, CRITICAL => 2, UNKNOWN => 3 };

sub new {
  my $class = shift;
  my %params = @_;
  my $self = {
    blacklisted => 0,
    info => undef,
    extendedinfo => undef,
  };
  foreach (qw(fanIndex fanRPMs fanName)) {
    $self->{$_} = $params{$_};
  }
  bless $self, $class;
  return $self;
}

sub check {
  my $self = shift;
  $self->blacklist('f', $self->{fanIndex});
  $self->add_info(sprintf 'fan %d (%s) has %s rpm',
      $self->{fanIndex},
      $self->{fanName},
      $self->{fanRPMs});
  $self->add_perfdata(
      label => sprintf('fan_c%s', $self->{fanIndex}),
      value => $self->{fanRPMs},
      warning => undef,
      critical => undef,
  );
}

sub dump {
  my $self = shift;
  printf "[FAN_%s]\n", $self->{fanIndex};
  foreach (qw(fanIndex fanRPMs fanName)) {
    printf "%s: %s\n", $_, $self->{$_};
  }
  printf "info: %s\n", $self->{info};
  printf "\n";
}

package NWC::CiscoAsyncOS::Component::RaidSubsystem;
our @ISA = qw(NWC::CiscoAsyncOS::Component::EnvironmentalSubsystem);

use strict;
use constant { OK => 0, WARNING => 1, CRITICAL => 2, UNKNOWN => 3 };

sub new {
  my $class = shift;
  my %params = @_;
  my $self = {
    raids => [],
    blacklisted => 0,
    info => undef,
    extendedinfo => undef,
  };
  bless $self, $class;
  $self->init(%params);
  return $self;
}

sub init {
  my $self = shift;
  $self->{raidEvents} = $self->get_snmp_object('ASYNCOS-MAIL-MIB', 'raidEvents');
  foreach ($self->get_snmp_table_objects(
      'ASYNCOS-MAIL-MIB', 'raidTable')) {
    push(@{$self->{raids}},
        NWC::CiscoAsyncOS::Component::RaidSubsystem::Raid->new(%{$_}));
  }
}

sub check {
  my $self = shift;
  my $errorfound = 0;
  $self->add_info('checking raids');
  $self->blacklist('r', '');
  if (scalar (@{$self->{raids}}) == 0) {
  } else {
    foreach (@{$self->{raids}}) {
      $_->check();
    }
  }
}


sub dump {
  my $self = shift;
  printf "raidEvents: %s\n", $self->{raidEvents};
  foreach (@{$self->{raids}}) {
    $_->dump();
  }
}


package NWC::CiscoAsyncOS::Component::RaidSubsystem::Raid;
our @ISA = qw(NWC::CiscoAsyncOS::Component::RaidSubsystem);

use strict;
use constant { OK => 0, WARNING => 1, CRITICAL => 2, UNKNOWN => 3 };

sub new {
  my $class = shift;
  my %params = @_;
  my $self = {
    blacklisted => 0,
    info => undef,
    extendedinfo => undef,
  };
  foreach (qw(raidIndex raidStatus raidID raidLastError)) {
    $self->{$_} = $params{$_};
  }
  bless $self, $class;
  return $self;
}

sub check {
  my $self = shift;
  $self->blacklist('r', $self->{raidIndex});
  $self->add_info(sprintf 'raid %d has status %s',
      $self->{raidIndex},
      $self->{raidStatus});
  if ($self->{raidStatus} eq 'driveHealthy') {
  } elsif ($self->{raidStatus} eq 'driveRebuild') {
    $self->add_message(WARNING, $self->{info});
  } elsif ($self->{raidStatus} eq 'driveFailure') {
    $self->add_message(CRITICAL, $self->{info});
  }
}

sub dump {
  my $self = shift;
  printf "[RAID_%s]\n", $self->{raidIndex};
  foreach (qw(raidIndex raidStatus raidID raidLastError)) {
    printf "%s: %s\n", $_, $self->{$_};
  }
  printf "info: %s\n", $self->{info};
  printf "\n";
}

package NWC::CiscoAsyncOS::Component::EnvironmentalSubsystem;
our @ISA = qw(NWC::CiscoAsyncOS);

use strict;
use constant { OK => 0, WARNING => 1, CRITICAL => 2, UNKNOWN => 3 };

sub new {
  my $class = shift;
  my %params = @_;
  my $self = {
    runtime => $params{runtime},
    rawdata => $params{rawdata},
    method => $params{method},
    condition => $params{condition},
    status => $params{status},
    fan_subsystem => undef,
    temperature_subsystem => undef,
    powersupply_subsystem => undef,
    raid_subsystem => undef,
    blacklisted => 0,
    info => undef,
    extendedinfo => undef,
  };
  bless $self, $class;
  $self->init(%params);
  return $self;
}

sub init {
  my $self = shift;
  my %params = @_;
  #
  # 1.3.6.1.4.1.9.9.13.1.1.0 ciscoEnvMonPresent (irgendein typ of envmon)
  # 
  $self->{fan_subsystem} =
      NWC::CiscoAsyncOS::Component::FanSubsystem->new(%params);
  $self->{temperature_subsystem} =
      NWC::CiscoAsyncOS::Component::TemperatureSubsystem->new(%params);
  $self->{powersupply_subsystem} = 
      NWC::CiscoAsyncOS::Component::SupplySubsystem->new(%params);
  $self->{raid_subsystem} = 
      NWC::CiscoAsyncOS::Component::RaidSubsystem->new(%params);
}

sub check {
  my $self = shift;
  my $errorfound = 0;
  $self->{fan_subsystem}->check();
  $self->{temperature_subsystem}->check();
  $self->{powersupply_subsystem}->check();
  $self->{raid_subsystem}->check();
  if (! $self->check_messages()) {
    $self->add_message(OK, "environmental hardware working fine");
  }
}

sub dump {
  my $self = shift;
  $self->{fan_subsystem}->dump();
  $self->{temperature_subsystem}->dump();
  $self->{powersupply_subsystem}->dump();
  $self->{raid_subsystem}->dump();
}


package NWC::CiscoAsyncOS;

use strict;

use constant { OK => 0, WARNING => 1, CRITICAL => 2, UNKNOWN => 3 };

our @ISA = qw(NWC::Cisco);

sub init {
  my $self = shift;
  $self->{components} = {
      powersupply_subsystem => undef,
      fan_subsystem => undef,
      temperature_subsystem => undef,
      cpu_subsystem => undef,
      memory_subsystem => undef,
      disk_subsystem => undef,
      environmental_subsystem => undef,
      connection_subsystem => undef,
      key_subsystem => undef,
  };
  $self->{serial} = 'unknown';
  $self->{product} = 'unknown';
  $self->{romversion} = 'unknown';
  # serial is 1.3.6.1.2.1.47.1.1.1.1.11.1
  #$self->collect();
  if (! $self->check_messages()) {
    ##$self->set_serial();
    if ($self->mode =~ /device::hardware::health/) {
      $self->analyze_environmental_subsystem();
      #$self->auto_blacklist();
      $self->check_environmental_subsystem();
    } elsif ($self->mode =~ /device::hardware::load/) {
      $self->analyze_cpu_subsystem();
      #$self->auto_blacklist();
      $self->check_cpu_subsystem();
    } elsif ($self->mode =~ /device::hardware::memory/) {
      $self->analyze_mem_subsystem();
      #$self->auto_blacklist();
      $self->check_mem_subsystem();
    } elsif ($self->mode =~ /device::licenses::/) {
      $self->analyze_key_subsystem();
      $self->check_key_subsystem();
    } elsif ($self->mode =~ /device::shinken::interface/) {
      $self->analyze_interface_subsystem();
      $self->shinken_interface_subsystem();
    }
  }
}

sub analyze_environmental_subsystem {
  my $self = shift;
  $self->{components}->{environmental_subsystem} =
      NWC::CiscoAsyncOS::Component::EnvironmentalSubsystem->new();
}

sub analyze_cpu_subsystem {
  my $self = shift;
  $self->{components}->{cpu_subsystem} =
      NWC::CiscoAsyncOS::Component::CpuSubsystem->new();
}

sub analyze_mem_subsystem {
  my $self = shift;
  $self->{components}->{mem_subsystem} =
      NWC::CiscoAsyncOS::Component::MemSubsystem->new();
}

sub analyze_key_subsystem {
  my $self = shift;
  $self->{components}->{key_subsystem} =
      NWC::CiscoAsyncOS::Component::KeySubsystem->new();
}

package NWC::Cisco;

use strict;

use constant { OK => 0, WARNING => 1, CRITICAL => 2, UNKNOWN => 3 };

our @ISA = qw(NWC::Device);

use constant trees => (
  '1.3.6.1.2.1',        # mib-2
  '1.3.6.1.4.1.9',      # cisco
  '1.3.6.1.4.1.9.1',      # ciscoProducts
  '1.3.6.1.4.1.9.2',      # local
  '1.3.6.1.4.1.9.3',      # temporary
  '1.3.6.1.4.1.9.4',      # pakmon
  '1.3.6.1.4.1.9.5',      # workgroup
  '1.3.6.1.4.1.9.6',      # otherEnterprises
  '1.3.6.1.4.1.9.7',      # ciscoAgentCapability
  '1.3.6.1.4.1.9.8',      # ciscoConfig
  '1.3.6.1.4.1.9.9',      # ciscoMgmt
  '1.3.6.1.4.1.9.10',      # ciscoExperiment
  '1.3.6.1.4.1.9.11',      # ciscoAdmin
  '1.3.6.1.4.1.9.12',      # ciscoModules
  '1.3.6.1.4.1.9.13',      # lightstream
  '1.3.6.1.4.1.9.14',      # ciscoworks
  '1.3.6.1.4.1.9.15',      # newport
  '1.3.6.1.4.1.9.16',      # ciscoPartnerProducts
  '1.3.6.1.4.1.9.17',      # ciscoPolicy
  '1.3.6.1.4.1.9.18',      # ciscoPolicyAuto
  '1.3.6.1.4.1.9.19',      # ciscoDomains
  '1.3.6.1.4.1.14179.1',   # airespace-switching-mib
  '1.3.6.1.4.1.14179.2',   # airespace-wireless-mib
);

sub init {
  my $self = shift;
  my %params = @_;
  $self->SUPER::init(%params);
  if ($self->{productname} =~ /Cisco NX-OS/i) {
    bless $self, 'NWC::CiscoNXOS';
    $self->debug('using NWC::CiscoNXOS');
  } elsif ($self->{productname} =~ /Cisco Controller/i) {
    bless $self, 'NWC::CiscoWLC';
    $self->debug('using NWC::WLC');
  } elsif ($self->{productname} =~ /Cisco.*(IronPort|AsyncOS)/i) {
    bless $self, 'NWC::CiscoAsyncOS';
    $self->debug('using NWC::AsyncOS');
  } elsif ($self->{productname} =~ /Cisco/i) {
    bless $self, 'NWC::CiscoIOS';
    $self->debug('using NWC::CiscoIOS');
  }
  $self->init();
}

package NWC::Nortel;

use strict;

use constant { OK => 0, WARNING => 1, CRITICAL => 2, UNKNOWN => 3 };

our @ISA = qw(NWC::Device);

sub init {
  my $self = shift;
  my %params = @_;
  $self->SUPER::init(%params);
  $self->{components} = {
      powersupply_subsystem => undef,
      fan_subsystem => undef,
      temperature_subsystem => undef,
      cpu_subsystem => undef,
      memory_subsystem => undef,
      disk_subsystem => undef,
      environmental_subsystem => undef,
  };
  $self->{serial} = 'unknown';
  $self->{product} = 'unknown';
  $self->{romversion} = 'unknown';
  # serial is 1.3.6.1.2.1.47.1.1.1.1.11.1
  #$self->collect();
  if (! $self->check_messages()) {
    ##$self->set_serial();
    if ($self->mode =~ /device::hardware::health/) {
      $self->analyze_environmental_subsystem();
      #$self->auto_blacklist();
      $self->check_environmental_subsystem();
    } elsif ($self->mode =~ /device::hardware::load/) {
      $self->analyze_cpu_subsystem();
      #$self->auto_blacklist();
      $self->check_cpu_subsystem();
    } elsif ($self->mode =~ /device::hardware::memory/) {
      $self->analyze_mem_subsystem();
      #$self->auto_blacklist();
      $self->check_mem_subsystem();
    } elsif ($self->mode =~ /device::shinken::interface/) {
      $self->analyze_interface_subsystem();
      $self->shinken_interface_subsystem();
    } elsif ($self->mode =~ /device::hsrp/) {
      $self->analyze_hsrp_subsystem();
      $self->check_interface_subsystem();
    }
  }
}

sub analyze_hsrp_subsystem {
  my $self = shift;
  $self->{components}->{hsrp} =
      NWC::HSRP::Component::HSRPSubsystem->new();
}

sub analyze_environmental_subsystem {
  my $self = shift;
  $self->{components}->{environmental_subsystem} =
      NWC::Nortel::Component::EnvironmentalSubsystem->new();
}

sub analyze_cpu_subsystem {
  my $self = shift;
  $self->{components}->{cpu_subsystem} =
      NWC::Nortel::Component::CpuSubsystem->new();
}

sub analyze_mem_subsystem {
  my $self = shift;
  $self->{components}->{mem_subsystem} =
      NWC::Nortel::Component::MemSubsystem->new();
}


package NWC::Juniper::NetScreen::Component::CpuSubsystem;
our @ISA = qw(NWC::Juniper::NetScreen);

use strict;
use constant { OK => 0, WARNING => 1, CRITICAL => 2, UNKNOWN => 3 };

sub new {
  my $class = shift;
  my %params = @_;
  my $self = {
    loads => [],
    blacklisted => 0,
    info => undef,
    extendedinfo => undef,
  };
  bless $self, $class;
  $self->init(%params);
  return $self;
}

sub init {
  my $self = shift;
  my %params = @_;
  my $type = 0;
  foreach (qw(nsResCpuAvg)) {
    $self->{$_} = $self->get_snmp_object('NETSCREEN-RESOURCE-MIB', $_);
  }
}

sub check {
  my $self = shift;
  $self->add_info('checking cpus');
  $self->blacklist('c', undef);
  my $info = sprintf 'cpu usage is %.2f%%', $self->{nsResCpuAvg};
  $self->add_info($info);
  $self->set_thresholds(warning => 50, critical => 90);
  $self->add_message($self->check_thresholds($self->{nsResCpuAvg}), $info);
  $self->add_perfdata(
      label => 'cpu_usage',
      value => $self->{nsResCpuAvg},
      uom => '%',
      warning => $self->{warning},
      critical => $self->{critical},
  );
}

sub dump {
  my $self = shift;
  printf "[CPU]\n";
  foreach (qw(nsResCpuAvg
      )) {
    printf "%s: %s\n", $_, $self->{$_};
  }
  printf "info: %s\n", $self->{info};
  printf "\n";
}

sub unix_init {
  my $self = shift;
  my %params = @_;
  my $type = 0;
  foreach ($self->get_snmp_table_objects(
     'UCD-SNMP-MIB', 'laTable')) {
    push(@{$self->{loads}},
        NWC::Juniper::NetScreen::Component::CpuSubsystem::Load->new(%{$_}));
  }
}

sub unix_check {
  my $self = shift;
  my $errorfound = 0;
  $self->add_info('checking loads');
  $self->blacklist('c', '');
  foreach (@{$self->{loads}}) {
    $_->check();
  }
}

sub unix_dump {
  my $self = shift;
  foreach (@{$self->{loads}}) {
    $_->dump();
  }
}


package NWC::Juniper::NetScreen::Component::CpuSubsystem::Load;
our @ISA = qw(NWC::Juniper::NetScreen::Component::CpuSubsystem);

use strict;
use constant { OK => 0, WARNING => 1, CRITICAL => 2, UNKNOWN => 3 };

sub new {
  my $class = shift;
  my %params = @_;
  my $self = {
    blacklisted => 0,
    info => undef,
    extendedinfo => undef,
  };
  foreach my $param (qw(laIndex laNames laLoad laConfig laLoadFloat 
      laErrorFlag laErrMessage)) {
    $self->{$param} = $params{$param};
  }
  bless $self, $class;
  return $self;
}

sub check {
  my $self = shift;
  my $errorfound = 0;
  $self->blacklist('c', undef);
  my $info = sprintf '%s is %.2f', lc $self->{laNames}, $self->{laLoadFloat};
  $self->add_info($info);
  $self->set_thresholds(warning => $self->{laConfig},
      critical => $self->{laConfig});
  $self->add_message($self->check_thresholds($self->{laLoadFloat}), $info);
  $self->add_perfdata(
      label => lc $self->{laNames},
      value => $self->{laLoadFloat},
      warning => $self->{warning},
      critical => $self->{critical},
  );
}

sub dump {
  my $self = shift;
  printf "[LOAD_%s]\n", lc $self->{laNames};
  foreach (qw(laIndex laNames laLoad laConfig laLoadFloat 
      laErrorFlag laErrMessage)) {
    printf "%s: %s\n", $_, $self->{$_};
  }
  printf "info: %s\n", $self->{info};
  printf "\n";
}

package NWC::Juniper::NetScreen::Component::MemSubsystem;
our @ISA = qw(NWC::Juniper::NetScreen);

use strict;
use constant { OK => 0, WARNING => 1, CRITICAL => 2, UNKNOWN => 3 };

sub new {
  my $class = shift;
  my %params = @_;
  my $self = {
    runtime => $params{runtime},
    rawdata => $params{rawdata},
    mems => [],
    blacklisted => 0,
    info => undef,
    extendedinfo => undef,
  };
  bless $self, $class;
  $self->init(%params);
  return $self;
}

sub init {
  my $self = shift;
  my %params = @_;
  foreach (qw(nsResMemAllocate nsResMemLeft nsResMemFrag)) {
    $self->{$_} = $self->get_snmp_object('NETSCREEN-RESOURCE-MIB', $_);
  }
  my $mem_total = $self->{nsResMemAllocate} + $self->{nsResMemLeft};
  $self->{mem_usage} = $self->{nsResMemAllocate} / $mem_total * 100;
}

sub check {
  my $self = shift;
  my $errorfound = 0;
  $self->add_info('checking memory');
  $self->blacklist('m', '');
  if (defined $self->{mem_usage}) {
    my $info = sprintf 'memory usage is %.2f%%',
        $self->{mem_usage};
    $self->add_info($info);
    $self->set_thresholds(warning => 80,
        critical => 90);
    $self->add_message($self->check_thresholds($self->{mem_usage}), $info);
    $self->add_perfdata(
        label => 'memory_usage',
        value => $self->{mem_usage},
        uom => '%',
        warning => $self->{warning},
        critical => $self->{critical}
    );
  } else {
    $self->add_message(UNKNOWN, 'cannot aquire momory usage');
  }
}

sub dump {
  my $self = shift;
  printf "[MEMORY]\n";
  foreach (qw(nsResMemAllocate nsResMemLeft nsResMemFrag)) {
    printf "%s: %s\n", $_, $self->{$_};
  }
  printf "info: %s\n", $self->{info};
  printf "\n";
}

package NWC::Juniper::NetScreen;

use strict;

use constant { OK => 0, WARNING => 1, CRITICAL => 2, UNKNOWN => 3 };

our @ISA = qw(NWC::Juniper);

use constant trees => (
  '1.3.6.1.2.1',        # mib-2
  '1.3.6.1.2.1.105',
);

sub init {
  my $self = shift;
  $self->{components} = {
      powersupply_subsystem => undef,
      fan_subsystem => undef,
      temperature_subsystem => undef,
      cpu_subsystem => undef,
      memory_subsystem => undef,
      disk_subsystem => undef,
      environmental_subsystem => undef,
  };
  $self->{serial} = 'unknown';
  $self->{product} = 'unknown';
  $self->{romversion} = 'unknown';
  # serial is 1.3.6.1.2.1.47.1.1.1.1.11.1
  #$self->collect();
  if (! $self->check_messages()) {
    ##$self->set_serial();
    if ($self->mode =~ /device::hardware::health/) {
      $self->no_such_mode();
    } elsif ($self->mode =~ /device::hardware::load/) {
      $self->analyze_cpu_subsystem();
      $self->check_cpu_subsystem();
    } elsif ($self->mode =~ /device::hardware::memory/) {
      $self->analyze_mem_subsystem();
      $self->check_mem_subsystem();
    } elsif ($self->mode =~ /device::interfaces/) {
      $self->analyze_interface_subsystem();
      $self->check_interface_subsystem();
    }
  }
}

sub analyze_mem_subsystem {
  my $self = shift;
  $self->{components}->{mem_subsystem} =
      NWC::Juniper::NetScreen::Component::MemSubsystem->new();
}

sub analyze_cpu_subsystem {
  my $self = shift;
  $self->{components}->{cpu_subsystem} =
      NWC::Juniper::NetScreen::Component::CpuSubsystem->new();
}

package NWC::Juniper::IVE::Component::MemSubsystem;
our @ISA = qw(NWC::Juniper::IVE);

use strict;
use constant { OK => 0, WARNING => 1, CRITICAL => 2, UNKNOWN => 3 };

sub new {
  my $class = shift;
  my %params = @_;
  my $self = {
    runtime => $params{runtime},
    rawdata => $params{rawdata},
    mems => [],
    blacklisted => 0,
    info => undef,
    extendedinfo => undef,
  };
  bless $self, $class;
  $self->init(%params);
  return $self;
}

sub init {
  my $self = shift;
  my %params = @_;
  $self->{iveMemoryUtil} = $self->get_snmp_object('JUNIPER-IVE-MIB', 'iveMemoryUtil');
  $self->{iveSwapUtil} = $self->get_snmp_object('JUNIPER-IVE-MIB', 'iveSwapUtil');
}

sub check {
  my $self = shift;
  my $errorfound = 0;
  $self->add_info('checking memory');
  $self->blacklist('m', '');
  my $info = sprintf 'memory usage is %.2f%%, swap usage is %.2f%%',
      $self->{iveMemoryUtil}, $self->{iveSwapUtil};
  $self->add_info($info);
  $self->set_thresholds(warning => 90, critical => 95);
  $self->add_message($self->check_thresholds($self->{iveMemoryUtil}),
      sprintf 'memory usage is %.2f%%', $self->{iveMemoryUtil});
  $self->add_perfdata(
      label => 'memory_usage',
      value => $self->{iveMemoryUtil},
      uom => '%',
      warning => $self->{warning},
      critical => $self->{critical}
  );
  $self->set_thresholds(warning => 5, critical => 10);
  $self->add_message($self->check_thresholds($self->{iveSwapUtil}),
      sprintf 'swap usage is %.2f%%', $self->{iveSwapUtil});
  $self->add_perfdata(
      label => 'swap_usage',
      value => $self->{iveSwapUtil},
      uom => '%',
      warning => $self->{warning},
      critical => $self->{critical}
  );
}

sub dump {
  my $self = shift;
  printf "[MEMORY/SWAP]\n";
  foreach (qw(iveMemoryUtil iveSwapUtil)) {
    printf "%s: %s\n", $_, $self->{$_};
  }
  printf "info: %s\n", $self->{info};
  printf "\n";
}

package NWC::Juniper::IVE::Component::CpuSubsystem;
our @ISA = qw(NWC::Juniper::IVE);

use strict;
use constant { OK => 0, WARNING => 1, CRITICAL => 2, UNKNOWN => 3 };

sub new {
  my $class = shift;
  my %params = @_;
  my $self = {
    loads => [],
    blacklisted => 0,
    info => undef,
    extendedinfo => undef,
  };
  bless $self, $class;
  $self->init(%params);
  return $self;
}

sub init {
  my $self = shift;
  my %params = @_;
  my $type = 0;
  $self->{iveCpuUtil} = $self->get_snmp_object('JUNIPER-IVE-MIB', 'iveCpuUtil');
}

sub check {
  my $self = shift;
  $self->add_info('checking cpus');
  $self->blacklist('c', undef);
  my $info = sprintf 'cpu usage is %.2f%%', $self->{iveCpuUtil};
  # http://www.juniper.net/techpubs/software/ive/guides/howtos/SA-IC-MAG-SNMP-Monitoring-Guide.pdf
  $self->add_info($info);
  $self->set_thresholds(warning => 50, critical => 90);
  $self->add_message($self->check_thresholds($self->{iveCpuUtil}), $info);
  $self->add_perfdata(
      label => 'cpu_usage',
      value => $self->{iveCpuUtil},
      uom => '%',
      warning => $self->{warning},
      critical => $self->{critical},
  );
}

sub dump {
  my $self = shift;
  printf "[CPU]\n";
  foreach (qw(iveCpuUtil
  )) {
    printf "%s: %s\n", $_, $self->{$_};
  }
  printf "info: %s\n", $self->{info};
  printf "\n";
}

sub unix_init {
  my $self = shift;
  my %params = @_;
  my $type = 0;
  foreach ($self->get_snmp_table_objects(
     'UCD-SNMP-MIB', 'laTable')) {
    push(@{$self->{loads}},
        NWC::Juniper::IVE::Component::CpuSubsystem::Load->new(%{$_}));
  }
}

sub unix_check {
  my $self = shift;
  my $errorfound = 0;
  $self->add_info('checking loads');
  $self->blacklist('c', '');
  foreach (@{$self->{loads}}) {
    $_->check();
  }
}

sub unix_dump {
  my $self = shift;
  foreach (@{$self->{loads}}) {
    $_->dump();
  }
}


package NWC::Juniper::IVE::Component::CpuSubsystem::Load;
our @ISA = qw(NWC::Juniper::IVE::Component::CpuSubsystem);

use strict;
use constant { OK => 0, WARNING => 1, CRITICAL => 2, UNKNOWN => 3 };

sub new {
  my $class = shift;
  my %params = @_;
  my $self = {
    blacklisted => 0,
    info => undef,
    extendedinfo => undef,
  };
  foreach my $param (qw(laIndex laNames laLoad laConfig laLoadFloat 
      laErrorFlag laErrMessage)) {
    $self->{$param} = $params{$param};
  }
  bless $self, $class;
  return $self;
}

sub check {
  my $self = shift;
  my $errorfound = 0;
  $self->blacklist('c', undef);
  my $info = sprintf '%s is %.2f', lc $self->{laNames}, $self->{laLoadFloat};
  $self->add_info($info);
  $self->set_thresholds(warning => $self->{laConfig},
      critical => $self->{laConfig});
  $self->add_message($self->check_thresholds($self->{laLoadFloat}), $info);
  $self->add_perfdata(
      label => lc $self->{laNames},
      value => $self->{laLoadFloat},
      warning => $self->{warning},
      critical => $self->{critical},
  );
}

sub dump {
  my $self = shift;
  printf "[LOAD_%s]\n", lc $self->{laNames};
  foreach (qw(laIndex laNames laLoad laConfig laLoadFloat 
      laErrorFlag laErrMessage)) {
    printf "%s: %s\n", $_, $self->{$_};
  }
  printf "info: %s\n", $self->{info};
  printf "\n";
}

package NWC::Juniper::IVE::Component::EnvironmentalSubsystem;
our @ISA = qw(NWC::SGOS);

use strict;
use constant { OK => 0, WARNING => 1, CRITICAL => 2, UNKNOWN => 3 };

sub new {
  my $class = shift;
  my %params = @_;
  my $self = {
    runtime => $params{runtime},
    rawdata => $params{rawdata},
    method => $params{method},
    condition => $params{condition},
    status => $params{status},
    sensor_subsystem => undef,
    disk_subsystem => undef,
    blacklisted => 0,
    info => undef,
    extendedinfo => undef,
  };
  bless $self, $class;
  $self->init(%params);
  return $self;
}

sub init {
  my $self = shift;
  my %params = @_;
  $self->{disk_subsystem} =
      NWC::Juniper::IVE::Component::DiskSubsystem->new(%params);
  foreach (qw(iveTemperature fanDescription psDescription raidDescription)) {
    $self->{$_} = $self->get_snmp_object('JUNIPER-IVE-MIB', $_);
  }
}

sub check {
  my $self = shift;
  my $errorfound = 0;
  $self->{disk_subsystem}->check();
  $self->add_info(sprintf "temperature is %.2f deg", $self->{iveTemperature});
  $self->set_thresholds(warning => 70, critical => 75);
  $self->check_thresholds(0);
  $self->add_perfdata(
      label => 'temperature',
      value => $self->{iveTemperature},
      warning => $self->{warning},
      critical => $self->{critical},
  );
  if ($self->{fanDescription} && $self->{fanDescription} =~ /(failed)|(threshold)/) {
    $self->add_message(CRITICAL, $self->{fanDescription});
  }
  if ($self->{psDescription} && $self->{psDescription} =~ /failed/) {
    $self->add_message(CRITICAL, $self->{psDescription});
  }
  if ($self->{raidDescription} && $self->{raidDescription} =~ /(failed)|(unknown)/) {
    $self->add_message(CRITICAL, $self->{raidDescription});
  }
  if (! $self->check_messages()) {
    $self->add_message(OK, "environmental hardware working fine");
  }
}

sub dump {
  my $self = shift;
  $self->{disk_subsystem}->dump();
}


package NWC::Juniper::IVE::Component::DiskSubsystem;
our @ISA = qw(NWC::Juniper::IVE::Component::EnvironmentalSubsystem);

use strict;
use constant { OK => 0, WARNING => 1, CRITICAL => 2, UNKNOWN => 3 };

sub new {
  my $class = shift;
  my %params = @_;
  my $self = {
    disks => [],
    diskthresholds => [],
    blacklisted => 0,
    info => undef,
    extendedinfo => undef,
  };
  bless $self, $class;
  $self->init(%params);
  return $self;
}

sub init {
  my $self = shift;
  my $disks = {};
  $self->{diskFullPercent} = 
      $self->get_snmp_object('JUNIPER-IVE-MIB', 'diskFullPercent');
}

sub check {
  my $self = shift;
  my $errorfound = 0;
  $self->add_info('checking disks');
  $self->blacklist('di', '');
  $self->add_info(sprintf 'disk is %.2f%% full',
      $self->{diskFullPercent});
  $self->set_thresholds(warning => 80, critical => 90);
  $self->add_message($self->check_thresholds($self->{diskFullPercent}), $self->{info});
  $self->add_perfdata(
      label => 'disk_usage',
      value => $self->{diskFullPercent},
      uom => '%',
      warning => $self->{warning},
      critical => $self->{critical},
  );
}

sub dump {
  my $self = shift;
  printf "[DISK]\n";
  printf "info: %s\n", $self->{info};
}

package NWC::Juniper::IVE::Component::UserSubsystem;
our @ISA = qw(NWC::Juniper::IVE);

use strict;
use constant { OK => 0, WARNING => 1, CRITICAL => 2, UNKNOWN => 3 };

sub new {
  my $class = shift;
  my %params = @_;
  my $self = {
    runtime => $params{runtime},
    rawdata => $params{rawdata},
    mems => [],
    blacklisted => 0,
    info => undef,
    extendedinfo => undef,
  };
  bless $self, $class;
  $self->init(%params);
  return $self;
}

sub init {
  my $self = shift;
  my %params = @_;
  foreach (qw(signedInWebUsers signedInMailUsers meetingUserCount iveConcurrentUsers clusterConcurrentUsers)) {
    $self->{$_} = $self->get_snmp_object('JUNIPER-IVE-MIB', $_) || 0;
  }
}

sub check {
  my $self = shift;
  my $errorfound = 0;
  $self->add_info('checking memory');
  $self->blacklist('m', '');
  my $info = sprintf 'Users:  cluster=%d, node=%d, web=%d, mail=%d, meeting=%d',
      $self->{clusterConcurrentUsers}, $self->{iveConcurrentUsers},
      $self->{signedInWebUsers},
      $self->{signedInMailUsers},
      $self->{meetingUserCount};
  $self->add_info($info);
  $self->add_message(OK, $info);
  $self->add_perfdata(
      label => 'web_users',
      value => $self->{signedInWebUsers},
  );
  $self->add_perfdata(
      label => 'mail_users',
      value => $self->{signedInMailUsers},
  );
  $self->add_perfdata(
      label => 'meeting_users',
      value => $self->{meetingUserCount},
  );
  $self->add_perfdata(
      label => 'concurrent_users',
      value => $self->{iveConcurrentUsers},
  );
  $self->add_perfdata(
      label => 'cluster_concurrent_users',
      value => $self->{clusterConcurrentUsers},
  );
}

sub dump {
  my $self = shift;
  printf "[USERS]\n";
  foreach (qw(signedInWebUsers signedInMailUsers meetingUserCount iveConcurrentUsers clusterConcurrentUsers)) {
    printf "%s: %s\n", $_, $self->{$_};
  }
  printf "info: %s\n", $self->{info};
  printf "\n";
}

package NWC::Juniper::IVE;

use strict;

use constant { OK => 0, WARNING => 1, CRITICAL => 2, UNKNOWN => 3 };

our @ISA = qw(NWC::Juniper);

use constant trees => (
  '1.3.6.1.2.1',        # mib-2
  '1.3.6.1.2.1.105',
);

sub init {
  my $self = shift;
  $self->{components} = {
      powersupply_subsystem => undef,
      fan_subsystem => undef,
      temperature_subsystem => undef,
      cpu_subsystem => undef,
      memory_subsystem => undef,
      disk_subsystem => undef,
      environmental_subsystem => undef,
      user_subsystem => undef,
  };
  $self->{serial} = 'unknown';
  $self->{product} = 'unknown';
  $self->{romversion} = 'unknown';
  if (! $self->check_messages()) {
    ##$self->set_serial();
    if ($self->mode =~ /device::hardware::health/) {
      $self->analyze_environmental_subsystem();
      $self->check_environmental_subsystem();
    } elsif ($self->mode =~ /device::hardware::load/) {
      $self->analyze_cpu_subsystem();
      $self->check_cpu_subsystem();
    } elsif ($self->mode =~ /device::hardware::memory/) {
      $self->analyze_mem_subsystem();
      $self->check_mem_subsystem();
    } elsif ($self->mode =~ /device::users/) {
      $self->analyze_user_subsystem();
      $self->check_user_subsystem();
    }
  }
}

sub analyze_mem_subsystem {
  my $self = shift;
  $self->{components}->{mem_subsystem} =
      NWC::Juniper::IVE::Component::MemSubsystem->new();
}

sub analyze_cpu_subsystem {
  my $self = shift;
  $self->{components}->{cpu_subsystem} =
      NWC::Juniper::IVE::Component::CpuSubsystem->new();
}

sub analyze_environmental_subsystem {
  my $self = shift;
  $self->{components}->{environmental_subsystem} =
      NWC::Juniper::IVE::Component::EnvironmentalSubsystem->new();
}

sub analyze_user_subsystem {
  my $self = shift;
  $self->{components}->{user_subsystem} =
      NWC::Juniper::IVE::Component::UserSubsystem->new();
}

package NWC::Juniper;

use strict;

use constant { OK => 0, WARNING => 1, CRITICAL => 2, UNKNOWN => 3 };

our @ISA = qw(NWC::Device);

use constant trees => (
    '1.3.6.1.4.1.4874.',
    '1.3.6.1.4.1.3224.',
);

sub init {
  my $self = shift;
  my %params = @_;
  $self->SUPER::init(%params);
  if ($self->{productname} =~ /NetScreen/i) {
    bless $self, 'NWC::Juniper::NetScreen';
    $self->debug('using NWC::Juniper::NetScreen');
  } elsif ($self->{productname} =~ /Juniper.*MAG\-\d+/i) {
    # Juniper Networks,Inc,MAG-4610,7.2R10
    bless $self, 'NWC::Juniper::IVE';
    $self->debug('using NWC::Juniper::IVE');
  }
  $self->init(%params);
}

package NWC::AlliedTelesyn;

use strict;

use constant { OK => 0, WARNING => 1, CRITICAL => 2, UNKNOWN => 3 };

our @ISA = qw(NWC::Device);

sub init {
  my $self = shift;
  my %params = @_;
  $self->SUPER::init(%params);
  $self->{components} = {
      powersupply_subsystem => undef,
      fan_subsystem => undef,
      temperature_subsystem => undef,
      cpu_subsystem => undef,
      memory_subsystem => undef,
      disk_subsystem => undef,
      environmental_subsystem => undef,
  };
  $self->{serial} = 'unknown';
  $self->{product} = 'unknown';
  $self->{romversion} = 'unknown';
  # serial is 1.3.6.1.2.1.47.1.1.1.1.11.1
  #$self->collect();
  if (! $self->check_messages()) {
    ##$self->set_serial();
    if ($self->mode =~ /device::hardware::health/) {
      $self->analyze_environmental_subsystem();
      #$self->auto_blacklist();
      $self->check_environmental_subsystem();
    } elsif ($self->mode =~ /device::hardware::load/) {
      $self->analyze_cpu_subsystem();
      #$self->auto_blacklist();
      $self->check_cpu_subsystem();
    } elsif ($self->mode =~ /device::hardware::memory/) {
      $self->analyze_mem_subsystem();
      #$self->auto_blacklist();
      $self->check_mem_subsystem();
    } elsif ($self->mode =~ /device::hsrp/) {
      $self->analyze_hsrp_subsystem();
      $self->check_interface_subsystem();
    }
  }
}

sub analyze_hsrp_subsystem {
  my $self = shift;
  $self->{components}->{hsrp} =
      NWC::HSRP::Component::HSRPSubsystem->new();
}

sub analyze_environmental_subsystem {
  my $self = shift;
  $self->{components}->{environmental_subsystem} =
      NWC::AlliedTelesyn::Component::EnvironmentalSubsystem->new();
}

sub analyze_cpu_subsystem {
  my $self = shift;
  $self->{components}->{cpu_subsystem} =
      NWC::AlliedTelesyn::Component::CpuSubsystem->new();
}

sub analyze_mem_subsystem {
  my $self = shift;
  $self->{components}->{mem_subsystem} =
      NWC::AlliedTelesyn::Component::MemSubsystem->new();
}

package NWC::FabOS::Component::MemSubsystem;
our @ISA = qw(NWC::FabOS);

use strict;
use constant { OK => 0, WARNING => 1, CRITICAL => 2, UNKNOWN => 3 };

sub new {
  my $class = shift;
  my %params = @_;
  my $self = {
    runtime => $params{runtime},
    rawdata => $params{rawdata},
    mems => [],
    blacklisted => 0,
    info => undef,
    extendedinfo => undef,
  };
  bless $self, $class;
  $self->init(%params);
  return $self;
}

sub init {
  my $self = shift;
  my %params = @_;
  my $snmpwalk = $params{rawdata};
  my $ignore_redundancy = $params{ignore_redundancy};
  my $type = 0;
  foreach (qw(swMemUsage swMemUsageLimit1 swMemUsageLimit3 swMemPollingInterval
      swMemNoOfRetries swMemAction)) {
    $self->{$_} = $self->get_snmp_object('SW-MIB', $_, 0);
  }
}

sub check {
  my $self = shift;
  my $errorfound = 0;
  $self->add_info('checking memory');
  $self->blacklist('m', '');
  if (defined $self->{swMemUsage}) {
    my $info = sprintf 'memory usage is %.2f%%',
        $self->{swMemUsage};
    $self->add_info($info);
    $self->set_thresholds(warning => $self->{swMemUsageLimit1},
        critical => $self->{swMemUsageLimit3});
    $self->add_message($self->check_thresholds($self->{swMemUsage}), $info);
    $self->add_perfdata(
        label => 'memory_usage',
        value => $self->{swMemUsage},
        uom => '%',
        warning => $self->{warning},
        critical => $self->{critical}
    );
  } else {
    $self->add_message(UNKNOWN, 'cannot aquire momory usage');
  }
}

sub dump {
  my $self = shift;
  printf "[MEMORY]\n";
  foreach (qw(swMemUsage swMemUsageLimit1 swMemUsageLimit3 swMemPollingInterval
      swMemNoOfRetries swMemAction)) {
    printf "%s: %s\n", $_, $self->{$_};
  }
  printf "info: %s\n", $self->{info};
  printf "\n";
}

package NWC::FabOS::Component::CpuSubsystem;
our @ISA = qw(NWC::FabOS);

use strict;
use constant { OK => 0, WARNING => 1, CRITICAL => 2, UNKNOWN => 3 };

sub new {
  my $class = shift;
  my %params = @_;
  my $self = {
    cpus => [],
    blacklisted => 0,
    info => undef,
    extendedinfo => undef,
  };
  bless $self, $class;
  $self->init(%params);
  return $self;
}

sub init {
  my $self = shift;
  my %params = @_;
  my $type = 0;
  foreach (qw(swCpuUsage swCpuNoOfRetries swCpuUsageLimit swCpuPollingInterval
      swCpuAction)) {
    $self->{$_} = $self->get_snmp_object('SW-MIB', $_, 0);
  }
}

sub check {
  my $self = shift;
  my $errorfound = 0;
  $self->add_info('checking cpus');
  $self->blacklist('c', undef);
  my $info = sprintf 'cpu usage is %.2f%%', $self->{swCpuUsage};
  $self->add_info($info);
  $self->set_thresholds(warning => $self->{swCpuUsageLimit},
      critical => $self->{swCpuUsageLimit});
  $self->add_message($self->check_thresholds($self->{swCpuUsage}), $info);
  $self->add_perfdata(
      label => 'cpu_usage',
      value => $self->{swCpuUsage},
      uom => '%',
      warning => $self->{warning},
      critical => $self->{critical},
  );
}

sub dump {
  my $self = shift;
  printf "[CPU]\n";
  foreach (qw(swCpuUsage swCpuNoOfRetries swCpuUsageLimit swCpuPollingInterval
      swCpuAction)) {
    printf "%s: %s\n", $_, $self->{$_};
  }
  printf "info: %s\n", $self->{info};
  printf "\n";
}

package NWC::FabOS::Component::EnvironmentalSubsystem;
our @ISA = qw(NWC::FabOS);

use strict;
use constant { OK => 0, WARNING => 1, CRITICAL => 2, UNKNOWN => 3 };

sub new {
  my $class = shift;
  my %params = @_;
  my $self = {
    runtime => $params{runtime},
    rawdata => $params{rawdata},
    method => $params{method},
    condition => $params{condition},
    status => $params{status},
    sensor_subsystem => undef,
    blacklisted => 0,
    info => undef,
    extendedinfo => undef,
  };
  bless $self, $class;
  $self->init(%params);
  return $self;
}

sub init {
  my $self = shift;
  my %params = @_;
  $self->{sensor_subsystem} =
      NWC::FabOS::Component::SensorSubsystem->new(%params);
}

sub check {
  my $self = shift;
  my $errorfound = 0;
  $self->{sensor_subsystem}->check();
  if (! $self->check_messages()) {
    $self->add_message(OK, "environmental hardware working fine");
  }
}

sub dump {
  my $self = shift;
  $self->{sensor_subsystem}->dump();
}


package NWC::FabOS::Component::SensorSubsystem;
our @ISA = qw(NWC::FabOS::Component::EnvironmentalSubsystem);

use strict;
use constant { OK => 0, WARNING => 1, CRITICAL => 2, UNKNOWN => 3 };

sub new {
  my $class = shift;
  my %params = @_;
  my $self = {
    sensors => [],
    sensorthresholds => [],
    blacklisted => 0,
    info => undef,
    extendedinfo => undef,
  };
  bless $self, $class;
  $self->init(%params);
  return $self;
}

sub init {
  my $self = shift;
  my $sensors = {};
  foreach ($self->get_snmp_table_objects(
      'SW-MIB', 'swSensorTable')) {
    push(@{$self->{sensors}}, 
        NWC::FabOS::Component::SensorSubsystem::Sensor->new(%{$_}));
  }
  #foreach ($self->get_snmp_table_objects(
  #    'SW-MIB', 'swFwThresholdTable')) {
  #  printf "%s\n", Data::Dumper::Dumper($_);
  #}
}

sub check {
  my $self = shift;
  my $errorfound = 0;
  $self->add_info('checking sensors');
  $self->blacklist('ses', '');
  if (scalar (@{$self->{sensors}}) == 0) {
  } else {
    foreach (@{$self->{sensors}}) {
      $_->check();
    }
  }
}


sub dump {
  my $self = shift;
  foreach (@{$self->{sensors}}) {
    $_->dump();
  }
}


package NWC::FabOS::Component::SensorSubsystem::Sensor;
our @ISA = qw(NWC::FabOS::Component::SensorSubsystem);

use strict;
use constant { OK => 0, WARNING => 1, CRITICAL => 2, UNKNOWN => 3 };

sub new {
  my $class = shift;
  my %params = @_;
  my $self = {
    blacklisted => 0,
    info => undef,
    extendedinfo => undef,
  };
  foreach my $param (qw(swSensorIndex swSensorType swSensorStatus
      swSensorValue swSensorInfo)) {
    $self->{$param} = $params{$param};
  }
  bless $self, $class;
  return $self;
}

sub check {
  my $self = shift;
  $self->blacklist('se', $self->{swSensorIndex});
  $self->add_info(sprintf '%s sensor %s (%s) is %s',
      $self->{swSensorType},
      $self->{swSensorIndex},
      $self->{swSensorInfo},
      $self->{swSensorStatus});
  if ($self->{swSensorStatus} eq "faulty") {
    $self->add_message(CRITICAL, $self->{info});
  } elsif ($self->{swSensorStatus} eq "absent") {
  } elsif ($self->{swSensorStatus} eq "unknown") {
    $self->add_message(CRITICAL, $self->{info});
  } else {
    if ($self->{swSensorStatus} eq "nominal") {
      #$self->add_message(OK, $self->{info});
    } else {
      $self->add_message(CRITICAL, $self->{info});
    }
    $self->add_perfdata(
        label => sprintf('sensor_%s_%s', 
            $self->{swSensorType}, $self->{swSensorIndex}),
        value => $self->{swSensorValue},
    ) if $self->{swSensorType} ne "power-supply";
  }
}

sub dump {
  my $self = shift;
  printf "[SENSOR_%s_%s]\n", $self->{swSensorType}, $self->{swSensorIndex};
  foreach (qw(swSensorIndex swSensorType swSensorStatus
      swSensorValue swSensorInfo)) {
    printf "%s: %s\n", $_, $self->{$_};
  }
  printf "info: %s\n", $self->{info};
  printf "\n";
}

package NWC::FabOS::Component::SensorSubsystem::SensorThreshold;
our @ISA = qw(NWC::FabOS::Component::SensorSubsystem);

use strict;
use constant { OK => 0, WARNING => 1, CRITICAL => 2, UNKNOWN => 3 };

sub new {
  my $class = shift;
  my %params = @_;
  my $self = {
    blacklisted => 0,
    info => undef,
    extendedinfo => undef,
  };
  foreach my $param (qw(entSensorThresholdRelation entSensorThresholdValue
      entSensorThresholdSeverity entSensorThresholdNotificationEnable
      entSensorThresholdEvaluation indices)) {
    $self->{$param} = $params{$param};
  }
  $self->{entPhysicalIndex} = $params{indices}[0];
  $self->{entSensorThresholdIndex} = $params{indices}[1];
  bless $self, $class;
  return $self;
}

sub dump {
  my $self = shift;
  printf "[SENSOR_THRESHOLD_%s_%s]\n", 
      $self->{entPhysicalIndex}, $self->{entSensorThresholdIndex};
  foreach (qw(entSensorThresholdRelation entSensorThresholdValue
      entSensorThresholdSeverity entSensorThresholdNotificationEnable
      entSensorThresholdEvaluation)) {
    printf "%s: %s\n", $_, $self->{$_};
  }
}


package NWC::FabOS;

use strict;

use constant { OK => 0, WARNING => 1, CRITICAL => 2, UNKNOWN => 3 };

our @ISA = qw(NWC::Brocade);

sub init {
  my $self = shift;
  my %params = @_;
  $self->{components} = {
      powersupply_subsystem => undef,
      fan_subsystem => undef,
      temperature_subsystem => undef,
      cpu_subsystem => undef,
  };
  $self->{serial} = 'unknown';
  $self->{product} = 'unknown';
  $self->{romversion} = 'unknown';
  # serial is 1.3.6.1.2.1.47.1.1.1.1.11.1
  #$self->collect();
  if (! $self->check_messages()) {
    ##$self->set_serial();
    if ($self->mode =~ /device::hardware::health/) {
      $self->analyze_environmental_subsystem();
      $self->check_environmental_subsystem();
    } elsif ($self->mode =~ /device::hardware::load/) {
      $self->analyze_cpu_subsystem();
      $self->check_cpu_subsystem();
    } elsif ($self->mode =~ /device::hardware::memory/) {
      $self->analyze_mem_subsystem();
      $self->check_mem_subsystem();
    }
  }
}

sub analyze_environmental_subsystem {
  my $self = shift;
  $self->{components}->{environmental_subsystem} =
      NWC::FabOS::Component::EnvironmentalSubsystem->new();
}

sub analyze_cpu_subsystem {
  my $self = shift;
  $self->{components}->{cpu_subsystem} =
      NWC::FabOS::Component::CpuSubsystem->new();
#printf "%s\n", Data::Dumper::Dumper($self->{components});
}

sub analyze_mem_subsystem {
  my $self = shift;
  $self->{components}->{mem_subsystem} =
      NWC::FabOS::Component::MemSubsystem->new();
}

package NWC::HP::Procurve::Component::MemSubsystem;
our @ISA = qw(NWC::HP::Procurve::Component::EnvironmentalSubsystem);

use strict;
use constant { OK => 0, WARNING => 1, CRITICAL => 2, UNKNOWN => 3 };

sub new {
  my $class = shift;
  my %params = @_;
  my $self = {
    sensors => [],
    sensorthresholds => [],
    blacklisted => 0,
    info => undef,
    extendedinfo => undef,
  };
  bless $self, $class;
  $self->init(%params);
  return $self;
}

sub init {
  my $self = shift;
  my $sensors = {};
  foreach ($self->get_snmp_table_objects(
      'NETSWITCH-MIB', 'hpLocalMemTable')) {
    push(@{$self->{mem}}, 
        NWC::HP::Procurve::Component::MemSubsystem::Memory->new(%{$_}));
  }
}

sub check {
  my $self = shift;
  my $errorfound = 0;
  $self->add_info('checking memory');
  $self->blacklist('m', '');
  if (scalar (@{$self->{mem}}) == 0) {
  } else {
    foreach (@{$self->{mem}}) {
      $_->check();
    }
  }
}


sub dump {
  my $self = shift;
  foreach (@{$self->{mem}}) {
    $_->dump();
  }
}


package NWC::HP::Procurve::Component::MemSubsystem::Memory;
our @ISA = qw(NWC::HP::Procurve::Component::MemSubsystem);

use strict;
use constant { OK => 0, WARNING => 1, CRITICAL => 2, UNKNOWN => 3 };

sub new {
  my $class = shift;
  my %params = @_;
  my $self = {
    blacklisted => 0,
    info => undef,
    extendedinfo => undef,
  };
  foreach (qw(hpLocalMemSlotIndex  hpLocalMemSlabCnt
      hpLocalMemFreeSegCnt hpLocalMemAllocSegCnt hpLocalMemTotalBytes
      hpLocalMemFreeBytes hpLocalMemAllocBytes)) {
    $self->{$_} = $params{$_};
  }
  bless $self, $class;
  return $self;
}

sub check {
  my $self = shift;
  $self->blacklist('m', $self->{hpicfMemIndex});
  $self->{usage} = $self->{hpLocalMemAllocBytes} / 
      $self->{hpLocalMemTotalBytes} * 100;
  my $info = sprintf 'memory %s usage is %.2f',
      $self->{hpLocalMemSlotIndex},
      $self->{usage};
  $self->add_info($info);
  $self->set_thresholds(warning => 80, critical => 90);
  $self->add_message($self->check_thresholds($self->{usage}), $info);
  $self->add_perfdata(
      label => 'memory_'.$self->{hpLocalMemSlotIndex}.'_usage',
      value => $self->{usage},
      uom => '%',
      warning => $self->{warning},
      critical => $self->{critical}
  );
}

sub dump {
  my $self = shift;
  printf "[MEM%s]\n", $self->{hpLocalMemSlotIndex};
  foreach (qw(hpLocalMemSlotIndex  hpLocalMemSlabCnt
      hpLocalMemFreeSegCnt hpLocalMemAllocSegCnt hpLocalMemTotalBytes
      hpLocalMemFreeBytes hpLocalMemAllocBytes)) {
    printf "%s: %s\n", $_, $self->{$_};
  }
  printf "info: %s\n", $self->{info};
  printf "\n";
}


package NWC::HP::Procurve::Component::CpuSubsystem;
our @ISA = qw(NWC::HP::Procurve);

use strict;
use constant { OK => 0, WARNING => 1, CRITICAL => 2, UNKNOWN => 3 };

sub new {
  my $class = shift;
  my %params = @_;
  my $self = {
    cpus => [],
    blacklisted => 0,
    info => undef,
    extendedinfo => undef,
  };
  bless $self, $class;
  $self->init(%params);
  return $self;
}

sub init {
  my $self = shift;
  my %params = @_;
  $self->{hpSwitchCpuStat} = $self->get_snmp_object('STATISTICS-MIB', 'hpSwitchCpuStat');
}

sub check {
  my $self = shift;
  my $errorfound = 0;
  $self->add_info('checking cpus');
  my $info = sprintf 'cpu usage is %.2f%%', $self->{hpSwitchCpuStat};
  $self->add_info($info);
  $self->set_thresholds(warning => 80, critical => 90); # maybe lower, because the switching is done in hardware
  $self->add_message($self->check_thresholds($self->{hpSwitchCpuStat}), $info);
  $self->add_perfdata(
      label => 'cpu_usage',
      value => $self->{hpSwitchCpuStat},
      uom => '%',
      warning => $self->{warning},
      critical => $self->{critical},
  );
}

sub dump {
  my $self = shift;
  printf "[CPU]\n";
  foreach (qw(hpSwitchCpuStat)) {
    printf "%s: %s\n", $_, $self->{$_};
  }
  printf "info: %s\n", $self->{info};
  printf "\n";
}

package NWC::HP::Procurve::Component::EnvironmentalSubsystem;
our @ISA = qw(NWC::HP::Procurve);

use strict;
use constant { OK => 0, WARNING => 1, CRITICAL => 2, UNKNOWN => 3 };

sub new {
  my $class = shift;
  my %params = @_;
  my $self = {
    runtime => $params{runtime},
    rawdata => $params{rawdata},
    method => $params{method},
    condition => $params{condition},
    status => $params{status},
    sensor_subsystem => undef,
    blacklisted => 0,
    info => undef,
    extendedinfo => undef,
  };
  bless $self, $class;
  $self->init(%params);
  return $self;
}

sub init {
  my $self = shift;
  my %params = @_;
  $self->{sensor_subsystem} =
      NWC::HP::Procurve::Component::SensorSubsystem->new(%params);
}

sub check {
  my $self = shift;
  my $errorfound = 0;
  $self->{sensor_subsystem}->check();
  if (! $self->check_messages()) {
    $self->add_message(OK, "environmental hardware working fine");
  }
}

sub dump {
  my $self = shift;
  $self->{sensor_subsystem}->dump();
}


package NWC::HP::Procurve::Component::SensorSubsystem;
our @ISA = qw(NWC::HP::Procurve::Component::EnvironmentalSubsystem);

use strict;
use constant { OK => 0, WARNING => 1, CRITICAL => 2, UNKNOWN => 3 };

sub new {
  my $class = shift;
  my %params = @_;
  my $self = {
    sensors => [],
    sensorthresholds => [],
    blacklisted => 0,
    info => undef,
    extendedinfo => undef,
  };
  bless $self, $class;
  $self->init(%params);
  return $self;
}

sub init {
  my $self = shift;
  my $sensors = {};
  foreach ($self->get_snmp_table_objects(
      'HP-ICF-CHASSIS-MIB', 'hpicfSensorTable')) {
    push(@{$self->{sensors}}, 
        NWC::HP::Procurve::Component::SensorSubsystem::Sensor->new(%{$_}));
  }
}

sub check {
  my $self = shift;
  my $errorfound = 0;
  $self->add_info('checking sensors');
  $self->blacklist('ses', '');
  if (scalar (@{$self->{sensors}}) == 0) {
  } else {
    foreach (@{$self->{sensors}}) {
      $_->check();
    }
  }
}


sub dump {
  my $self = shift;
  foreach (@{$self->{sensors}}) {
    $_->dump();
  }
}


package NWC::HP::Procurve::Component::SensorSubsystem::Sensor;
our @ISA = qw(NWC::HP::Procurve::Component::SensorSubsystem);

use strict;
use constant { OK => 0, WARNING => 1, CRITICAL => 2, UNKNOWN => 3 };

sub new {
  my $class = shift;
  my %params = @_;
  my $self = {
    blacklisted => 0,
    info => undef,
    extendedinfo => undef,
  };
  foreach my $param (qw(hpicfSensorIndex hpicfSensorObjectId 
      hpicfSensorNumber hpicfSensorStatus hpicfSensorWarnings
      hpicfSensorFailures hpicfSensorDescr)) {
    $self->{$param} = $params{$param};
  }
  bless $self, $class;
  return $self;
}

sub check {
  my $self = shift;
  $self->blacklist('se', $self->{hpicfSensorIndex});
  $self->add_info(sprintf 'sensor %s (%s) is %s',
      $self->{hpicfSensorIndex},
      $self->{hpicfSensorDescr},
      $self->{hpicfSensorStatus});
  if ($self->{hpicfSensorStatus} eq "notPresent") {
  } elsif ($self->{hpicfSensorStatus} eq "bad") {
    $self->add_message(CRITICAL, $self->{info});
  } elsif ($self->{hpicfSensorStatus} eq "warning") {
    $self->add_message(WARNING, $self->{info});
  } elsif ($self->{hpicfSensorStatus} eq "good") {
    #$self->add_message(OK, $self->{info});
  } else {
    $self->add_message(UNKNOWN, $self->{info});
  }
}

sub dump {
  my $self = shift;
  printf "[SENSOR_%s]\n", $self->{hpicfSensorIndex};
  foreach (qw(hpicfSensorIndex hpicfSensorObjectId 
      hpicfSensorNumber hpicfSensorStatus hpicfSensorWarnings
      hpicfSensorFailures hpicfSensorDescr)) {
    printf "%s: %s\n", $_, $self->{$_};
  }
  printf "info: %s\n", $self->{info};
  printf "\n";
}


package NWC::HP::Procurve;

use strict;

use constant { OK => 0, WARNING => 1, CRITICAL => 2, UNKNOWN => 3 };

our @ISA = qw(NWC::HP);

sub init {
  my $self = shift;
  $self->{components} = {
      cpu_subsystem => undef,
      memory_subsystem => undef,
      environmental_subsystem => undef,
  };
  $self->{serial} = 'unknown';
  $self->{product} = 'unknown';
  $self->{romversion} = 'unknown';
  # serial is 1.3.6.1.2.1.47.1.1.1.1.11.1
  #$self->collect();
  if (! $self->check_messages()) {
    ##$self->set_serial();
    if ($self->mode =~ /device::hardware::health/) {
      $self->analyze_environmental_subsystem();
      #$self->auto_blacklist();
      $self->check_environmental_subsystem();
    } elsif ($self->mode =~ /device::hardware::load/) {
      $self->analyze_cpu_subsystem();
      #$self->auto_blacklist();
      $self->check_cpu_subsystem();
    } elsif ($self->mode =~ /device::hardware::memory/) {
      $self->analyze_mem_subsystem();
      #$self->auto_blacklist();
      $self->check_mem_subsystem();
    } elsif ($self->mode =~ /device::shinken::interface/) {
      $self->analyze_interface_subsystem();
      $self->shinken_interface_subsystem();
    }
  }
}

sub analyze_environmental_subsystem {
  my $self = shift;
  $self->{components}->{environmental_subsystem} =
      NWC::HP::Procurve::Component::EnvironmentalSubsystem->new();
}

sub analyze_cpu_subsystem {
  my $self = shift;
  $self->{components}->{cpu_subsystem} =
      NWC::HP::Procurve::Component::CpuSubsystem->new();
}

sub analyze_mem_subsystem {
  my $self = shift;
  $self->{components}->{mem_subsystem} =
      NWC::HP::Procurve::Component::MemSubsystem->new();
}

package NWC::HP;

use strict;

use constant { OK => 0, WARNING => 1, CRITICAL => 2, UNKNOWN => 3 };

our @ISA = qw(NWC::Device);

use constant trees => (
    '1.3.6.1.4.1.11.2.14.11.1.2', # HP-ICF-CHASSIS
    '1.3.6.1.2.1.1.7.11.12.9', # STATISTICS-MIB (old?)
    '1.3.6.1.2.1.1.7.11.12.1', # NETSWITCH-MIB (old?)
    '1.3.6.1.4.1.11.2.14.11.5.1.9', # STATISTICS-MIB
    '1.3.6.1.4.1.11.2.14.11.5.1.1', # NETSWITCH-MIB

);

sub init {
  my $self = shift;
  my %params = @_;
  $self->SUPER::init(%params);
  if ($self->{productname} =~ /Procurve/i) {
    bless $self, 'NWC::HP::Procurve';
    $self->debug('using NWC::HP::Procurve');
  }
  $self->init();
}

package NWC::MEOS;

use strict;

use constant { OK => 0, WARNING => 1, CRITICAL => 2, UNKNOWN => 3 };

our @ISA = qw(NWC::Brocade);

sub init {
  my $self = shift;
  my %params = @_;
  $self->{components} = {
      powersupply_subsystem => undef,
      fan_subsystem => undef,
      temperature_subsystem => undef,
      cpu_subsystem => undef,
  };
  $self->{serial} = 'unknown';
  $self->{product} = 'unknown';
  $self->{romversion} = 'unknown';
  # serial is 1.3.6.1.2.1.47.1.1.1.1.11.1
  #$self->collect();
  if (! $self->check_messages()) {
    if ($self->mode =~ /device::hardware::health/) {
      $self->analyze_environmental_subsystem();
      $self->check_environmental_subsystem();
    } elsif ($self->mode =~ /device::hardware::load/) {
      $self->analyze_cpu_subsystem();
      $self->check_cpu_subsystem();
    } elsif ($self->mode =~ /device::hardware::memory/) {
      $self->analyze_mem_subsystem();
      $self->check_mem_subsystem();
    }
  }
}

sub analyze_environmental_subsystem {
  my $self = shift;
  $self->{components}->{environmental_subsystem1} =
      NWC::FCMGMT::Component::EnvironmentalSubsystem->new();
  $self->{components}->{environmental_subsystem2} =
      NWC::FCEOS::Component::EnvironmentalSubsystem->new();
}

sub analyze_cpu_subsystem {
  my $self = shift;
  $self->no_such_mode();
  $self->{components}->{cpu_subsystem} =
      NWC::UCDMIB::Component::CpuSubsystem->new();
}

sub analyze_mem_subsystem {
  my $self = shift;
  $self->no_such_mode();
  $self->{components}->{mem_subsystem} =
      NWC::UCDMIB::Component::MemSubsystem->new();
}

sub check_environmental_subsystem {
  my $self = shift;
  $self->{components}->{environmental_subsystem1}->check();
  $self->{components}->{environmental_subsystem2}->check();
  if ($self->check_messages()) {
    $self->clear_messages(OK);
  }
  $self->{components}->{environmental_subsystem1}->dump()
      if $self->opts->verbose >= 2;
  $self->{components}->{environmental_subsystem2}->dump()
      if $self->opts->verbose >= 2;
}

package NWC::Brocade;

use strict;

use constant { OK => 0, WARNING => 1, CRITICAL => 2, UNKNOWN => 3 };

our @ISA = qw(NWC::Device);

use constant trees => (
  '1.3.6.1.2.1',        # mib-2
  '1.3.6.1.4.1.289',    # mcData
  '1.3.6.1.4.1.333',    # cnt
  '1.3.6.1.4.1.1588',   # bcsi
  '1.3.6.1.4.1.1991',   # foundry
  '1.3.6.1.4.1.4369',   # nishan
);

sub init {
  my $self = shift;
  my %params = @_;
  $self->SUPER::init(%params);
  foreach ($self->get_snmp_table_objects(
      'ENTITY-MIB', 'entPhysicalTable')) {
    if ($_->{entPhysicalDescr} =~ /Brocade/) {
      $self->{productname} = "FabOS";
    }
  }
  my $swFirmwareVersion = $self->get_snmp_object('SW-MIB', 'swFirmwareVersion');
  if ($swFirmwareVersion && $swFirmwareVersion =~ /^v6/) {
    $self->{productname} = "FabOS"
  }
  if ($self->{productname} =~ /EMC\s*DS.*4700M/i) {
    bless $self, 'NWC::MEOS';
    $self->debug('using NWC::MEOS');
    $self->init();
  } elsif ($self->{productname} =~ /EMC\s*DS-24M2/i) {
    bless $self, 'NWC::MEOS';
    $self->debug('using NWC::MEOS');
    $self->init();
  } elsif ($self->{productname} =~ /FabOS/i) {
    bless $self, 'NWC::FabOS';
    $self->debug('using NWC::FabOS');
    $self->init();
  } elsif ($self->{productname} =~ /ICX6/i) {
    bless $self, 'NWC::Foundry';
    $self->debug('using NWC::Foundry');
    $self->init();
  }
}

package NWC::SecureOS;

use strict;

use constant { OK => 0, WARNING => 1, CRITICAL => 2, UNKNOWN => 3 };

our @ISA = qw(NWC::Device);

sub init {
  my $self = shift;
  my %params = @_;
  $self->SUPER::init(%params);
  $self->{components} = {
      mem_subsystem => undef,
      cpu_subsystem => undef,
  };
  $self->{serial} = 'unknown';
  $self->{product} = 'unknown';
  $self->{romversion} = 'unknown';
  # serial is 1.3.6.1.2.1.47.1.1.1.1.11.1
  #$self->collect();
  if (! $self->check_messages()) {
    if ($self->mode =~ /device::hardware::health/) {
      $self->analyze_environmental_subsystem();
      $self->check_environmental_subsystem();
    } elsif ($self->mode =~ /device::hardware::load/) {
      $self->analyze_cpu_subsystem();
      $self->check_cpu_subsystem();
    } elsif ($self->mode =~ /device::hardware::memory/) {
      $self->analyze_mem_subsystem();
      $self->check_mem_subsystem();
    }
  }
}

sub analyze_environmental_subsystem {
  my $self = shift;
  $self->no_such_mode();
  $self->{components}->{environmental_subsystem} =
      #NWC::SecureOS::Component::EnvironmentalSubsystem->new();
      NWC::FCMGMT::Component::EnvironmentalSubsystem->new();
}

sub analyze_cpu_subsystem {
  my $self = shift;
  $self->{components}->{cpu_subsystem} =
      NWC::UCDMIB::Component::CpuSubsystem->new();
}

sub analyze_mem_subsystem {
  my $self = shift;
  $self->{components}->{mem_subsystem} =
      NWC::UCDMIB::Component::MemSubsystem->new();
}

package NWC::HSRP::Component::HSRPSubsystem;
our @ISA = qw(NWC::HSRP);

use strict;
use constant { OK => 0, WARNING => 1, CRITICAL => 2, UNKNOWN => 3 };

sub new {
  my $class = shift;
  my %params = @_;
  my $self = {
    groups => [],
    blacklisted => 0,
    info => undef,
    extendedinfo => undef,
  };
  bless $self, $class;
  $self->init(%params);
  return $self;
}

sub init {
  my $self = shift;
  my %params = @_;
  if ($self->mode =~ /device::hsrp/) {
    foreach ($self->get_snmp_table_objects(
        'CISCO-HSRP-MIB', 'cHsrpGrpTable')) {
      push(@{$self->{groups}},
          NWC::HSRP::Component::HSRPSubsystem::Group->new(%{$_}));
    }
  }
}

sub check {
  my $self = shift;
  my $errorfound = 0;
  $self->add_info('checking hsrp groups');
  $self->blacklist('hhsrp', '');
  if ($self->mode =~ /device::hsrp::list/) {
    foreach (@{$self->{groups}}) {
      $_->list();
    }
  } elsif ($self->mode =~ /device::hsrp/) {
    if (scalar (@{$self->{groups}}) == 0) {
      $self->add_message(UNKNOWN, 'no hsrp groups');
    } else {
      foreach (@{$self->{groups}}) {
        $_->check();
      }
    }
  }
}

sub dump {
  my $self = shift;
  foreach (@{$self->{groups}}) {
    $_->dump();
  }
}


package NWC::HSRP::Component::HSRPSubsystem::Group;
our @ISA = qw(NWC::HSRP::Component::HSRPSubsystem);

use strict;
use constant { OK => 0, WARNING => 1, CRITICAL => 2, UNKNOWN => 3 };

sub new {
  my $class = shift;
  my %params = @_;
  my $self = {
    blacklisted => 0,
    info => undef,
    extendedinfo => undef,
  };
  bless $self, $class;
  foreach ($self->get_snmp_table_attributes(
      'CISCO-HSRP-MIB', 'cHsrpGrpTable')) {
    $self->{$_} = $params{$_};
  }
  $self->{ifIndex} = $params{indices}->[0];
  $self->{cHsrpGrpNumber} = $params{indices}->[1];
  $self->{name} = $self->{cHsrpGrpNumber}.':'.$self->{ifIndex};
  foreach my $key (keys %params) {
    $self->{$key} = 0 if ! defined $params{$key};
  }
  $self->init();
  return $self;
}

sub init {
  my $self = shift;
  if ($self->mode =~ /device::hsrp::state/) {
    if (! $self->opts->role()) {
      $self->opts->override_opt('role', 'active');
    }
  }
  return $self;
}

sub check {
  my $self = shift;
  $self->blacklist('hsrp', $self->{name});
  if ($self->mode =~ /device::hsrp::state/) {
    my $info = sprintf 'hsrp group %s (interface %s) state is %s (active router is %s, standby router is %s',
        $self->{cHsrpGrpNumber}, $self->{ifIndex},
        $self->{cHsrpGrpStandbyState},
        $self->{cHsrpGrpActiveRouter}, $self->{cHsrpGrpStandbyRouter};
    $self->add_info($info);
    if ($self->opts->role() eq $self->{cHsrpGrpStandbyState}) {
        $self->add_message(OK, $info);
    } else {
      $self->add_message(CRITICAL, 
          sprintf 'state in group %s (interface %s) is %s instead of %s',
              $self->{cHsrpGrpNumber}, $self->{ifIndex},
              $self->{cHsrpGrpStandbyState},
              $self->opts->role());
    }
  } elsif ($self->mode =~ /device::hsrp::failover/) {
    my $info = sprintf 'hsrp group %s/%s: active node is %s, standby node is %s',
        $self->{cHsrpGrpNumber}, $self->{ifIndex},
        $self->{cHsrpGrpActiveRouter}, $self->{cHsrpGrpStandbyRouter};
    if (my $laststate = $self->load_state( name => $self->{name} )) {
      if ($laststate->{active} ne $self->{cHsrpGrpActiveRouter}) {
        $self->add_message(CRITICAL, sprintf 'hsrp group %s/%s: active node %s --> %s',
            $self->{cHsrpGrpNumber}, $self->{ifIndex},
            $laststate->{active}, $self->{cHsrpGrpActiveRouter});
      }
      if ($laststate->{standby} ne $self->{cHsrpGrpStandbyRouter}) {
        $self->add_message(WARNING, sprintf 'hsrp group %s/%s: standby node %s --> %s',
            $self->{cHsrpGrpNumber}, $self->{ifIndex},
            $laststate->{standby}, $self->{cHsrpGrpStandbyRouter});
      }
      if (($laststate->{active} eq $self->{cHsrpGrpActiveRouter}) &&
          ($laststate->{standby} eq $self->{cHsrpGrpStandbyRouter})) {
        $self->add_message(OK, $info);
      }
    } else {
      $self->add_message(OK, 'initializing....');
    }
    $self->save_state( name => $self->{name}, save => {
        active => $self->{cHsrpGrpActiveRouter},
        standby => $self->{cHsrpGrpStandbyRouter},
    });
  }
}

sub list {
  my $self = shift;
  printf "%s %s %s %s\n", $self->{name}, $self->{cHsrpGrpVirtualIpAddr},
      $self->{cHsrpGrpActiveRouter}, $self->{cHsrpGrpStandbyRouter};
}

sub dump {
  my $self = shift;
  printf "[HSRPGRP_%s]\n", $self->{name};
  foreach (qw(cHsrpGrpNumber cHsrpGrpVirtualIpAddr cHsrpGrpStandbyState cHsrpGrpActiveRouter cHsrpGrpStandbyRouter cHsrpGrpEntryRowStatus)) {
    printf "%s: %s\n", $_, defined $self->{$_} ? $self->{$_} : 'undefined';
  }
#  printf "info: %s\n", $self->{info};
  printf "\n";
}

package NWC::HSRP;

use strict;

use constant { OK => 0, WARNING => 1, CRITICAL => 2, UNKNOWN => 3 };

our @ISA = qw(NWC::Device);

package NWC::IFMIB::Component::LinkAggregation;
our @ISA = qw(NWC::IFMIB);

use strict;
use constant { OK => 0, WARNING => 1, CRITICAL => 2, UNKNOWN => 3 };

sub new {
  my $class = shift;
  my %params = @_;
  my $self = {
    link_aggregations => [],
    blacklisted => 0,
    info => undef,
    extendedinfo => undef,
  };
  bless $self, $class;
  $self->init(%params);
  return $self;
}

sub init {
  my $self = shift;
  my %params = @_;
  if ($self->opts->name) {
    my @ifs = split(",", $self->opts->name);
    $self->{name} = shift @ifs;
    if ($self->opts->regexp) {
      $self->opts->override_opt('name',
          sprintf "(%s)", join("|", map { sprintf "(%s)", $_ } @ifs));
    } else {
      $self->opts->override_opt('name',
          sprintf "(%s)", join("|", map { sprintf "(^%s\$)", $_ } @ifs));
      $self->opts->override_opt('regexp', 1);
    }
    $self->{components}->{interface_subsystem} =
        NWC::IFMIB::Component::InterfaceSubsystem->new();
  } else {
    #error, must have a name
  }
  if ($self->mode =~ /device::interfaces::aggregation::availability/) {
    $self->{num_if} = scalar(@{$self->{components}->{interface_subsystem}->{interfaces}});
    $self->{down_if} = [grep { $_->{ifOperStatus} eq "down" } @{$self->{components}->{interface_subsystem}->{interfaces}}];
    $self->{num_down_if} = scalar(@{$self->{down_if}});
    $self->{num_up_if} = $self->{num_if} - $self->{num_down_if};
    $self->{availability} = $self->{num_if} ? (100 * $self->{num_up_if} / $self->{num_if}) : 0;
  }
}

sub check {
  my $self = shift;
  my $errorfound = 0;
  $self->add_info('checking link aggregation');
  if (scalar(@{$self->{components}->{interface_subsystem}->{interfaces}}) == 0) {
    $self->add_message(UNKNOWN, 'no interfaces');
    return;
  }
  if ($self->mode =~ /device::interfaces::aggregation::availability/) {
    my $down_info = scalar(@{$self->{down_if}}) ?
        sprintf " (down: %s)", join(", ", map { $_->{ifDescr} } @{$self->{down_if}}) : "";
    my $info = sprintf 'aggregation %s availability is %.2f%% (%d of %d)%s',
        $self->{name},
        $self->{availability}, $self->{num_up_if}, $self->{num_if},
        $down_info;
    $self->add_info($info);
    my $cavailability = $self->{num_if} ? (100 * 1 / $self->{num_if}) : 0;
    $cavailability = $cavailability == int($cavailability) ? $cavailability + 1: int($cavailability + 1.0);
    $self->set_thresholds(warning => '100:', critical => $cavailability.':');
    $self->add_message($self->check_thresholds($self->{availability}), $info);
    $self->add_perfdata(
        label => 'aggr_'.$self->{name}.'_availability',
        value => $self->{availability},
        uom => '%',
        warning => $self->{warning},
        critical => $self->{critical},
    );
  }
}


package NWC::IFMIB::Component::InterfaceSubsystem;
our @ISA = qw(NWC::IFMIB);

use strict;
use constant { OK => 0, WARNING => 1, CRITICAL => 2, UNKNOWN => 3 };

sub new {
  my $class = shift;
  my %params = @_;
  my $self = {
    interfaces => [],
    blacklisted => 0,
    info => undef,
    extendedinfo => undef,
  };
  bless $self, $class;
  $self->init(%params);
  return $self;
}

sub init {
  my $self = shift;
  my %params = @_;
  if ($self->mode =~ /device::interfaces::list/) {
    $self->update_interface_cache(1);
    foreach my $ifIndex (keys %{$self->{interface_cache}}) {
      my $ifDescr = $self->{interface_cache}->{$ifIndex}->{ifDescr};
      my $ifName = $self->{interface_cache}->{$ifIndex}->{ifName} || '________';
      my $ifAlias = $self->{interface_cache}->{$ifIndex}->{ifAlias} || '________';
      push(@{$self->{interfaces}},
          NWC::IFMIB::Component::InterfaceSubsystem::Interface->new(
              ifIndex => $ifIndex,
              ifDescr => $ifDescr,
              ifName => $ifName,
              ifAlias => $ifAlias,
          ));
    }
  } else {
    $self->update_interface_cache(0);
    #next if $self->opts->can('name') && $self->opts->name && 
    #    $self->opts->name ne $_->{ifDescr};
    # if limited search
    # name is a number -> get_table with extra param
    # name is a regexp -> list of names -> list of numbers
    my @indices = $self->get_interface_indices();
    if (scalar(@indices) > 0) {
      foreach ($self->get_snmp_table_objects(
          'IFMIB', 'ifTable+ifXTable', \@indices)) {
        push(@{$self->{interfaces}},
            NWC::IFMIB::Component::InterfaceSubsystem::Interface->new(%{$_}));
      }
    }
  }
}

sub check {
  my $self = shift;
  my $errorfound = 0;
  $self->add_info('checking interfaces');
  $self->blacklist('ff', '');
  if (scalar(@{$self->{interfaces}}) == 0) {
    $self->add_message(UNKNOWN, 'no interfaces');
    return;
  }
  if ($self->mode =~ /device::interfaces::list/) {
    foreach (sort {$a->{ifIndex} <=> $b->{ifIndex}} @{$self->{interfaces}}) {
    #foreach (sort @{$self->{interfaces}}) {
      $_->list();
    }
  } elsif ($self->mode =~ /device::interfaces::availability/) {
    foreach (@{$self->{interfaces}}) {
      $_->check();
    }
    my $num_interfaces = scalar(@{$self->{interfaces}});
    my $up_interfaces =
        scalar(grep { $_->{ifAdminStatus} eq "up" } @{$self->{interfaces}});
    my $available_interfaces =
        scalar(grep { $_->{ifAvailable} eq "true" } @{$self->{interfaces}});
    my $info = sprintf "%d of %d (%d adm. up) interfaces are available",
        $available_interfaces, $num_interfaces, $up_interfaces;
    $self->add_info($info);
    $self->set_thresholds(warning => "3:", critical => "2:");
    $self->add_message($self->check_thresholds($available_interfaces), $info);
    $self->add_perfdata(
        label => 'num_interfaces',
        value => $num_interfaces,
    );
    $self->add_perfdata(
        label => 'available_interfaces',
        value => $available_interfaces,
        warning => $self->{warning},
        critical => $self->{critical},
    );

    printf "%s\n", $info;
    printf "<table style=\"border-collapse:collapse; border: 1px solid black;\">";
    printf "<tr>";
    foreach (qw(Index Descr Type Speed AdminStatus OperStatus Duration Available)) {
      printf "<th style=\"text-align: right; padding-left: 4px; padding-right: 6px;\">%s</th>", $_;
    }
    printf "</tr>";
    my $unique = {};
    foreach (@{$self->{interfaces}}) {
      if (exists $unique->{$_->{ifDescr}}) {
        $unique->{$_->{ifDescr}}++;
      } else {
        $unique->{$_->{ifDescr}} = 0;
      }
    }
    foreach (sort {$a->{ifIndex} <=> $b->{ifIndex}} @{$self->{interfaces}}) {
      if ($unique->{$_->{ifDescr}}) {
        $_->{ifDescr} .= ' '.$_->{ifIndex};
      }
      printf "<tr>";
      printf "<tr style=\"border: 1px solid black;\">";
      foreach my $attr (qw(ifIndex ifDescr ifType ifSpeedText ifAdminStatus ifOperStatus ifStatusDuration ifAvailable)) {
        if ($_->{ifAvailable} eq "false") {
          printf "<td style=\"text-align: right; padding-left: 4px; padding-right: 6px;\">%s</td>", $_->{$attr};
        } else {
          printf "<td style=\"text-align: right; padding-left: 4px; padding-right: 6px; background-color: #00ff33;\">%s</td>", $_->{$attr};
        }
      }
      printf "</tr>";
    }
    printf "</table>\n";
    printf "<!--\nASCII_NOTIFICATION_START\n";
    foreach (qw(ifIndex ifDescr ifType ifSpeed ifAdminStatus ifOperStatus Duration ifAvailable)) {
      printf "%20s", $_;
    }
    printf "\n";
    foreach (sort {$a->{ifIndex} <=> $b->{ifIndex}} @{$self->{interfaces}}) {
      if ($unique->{$_->{ifDescr}}) {
        $_->{ifDescr} .= ' '.$_->{ifIndex};
      }
      foreach my $attr (qw(ifIndex ifDescr ifType ifSpeedText ifAdminStatus ifOperStatus ifStatusDuration ifAvailable)) {
        printf "%20s", $_->{$attr};
      }
      printf "\n";
    }
    printf "ASCII_NOTIFICATION_END\n--!>\n";
  } else {
    if (scalar (@{$self->{interfaces}}) == 0) {
    } else {
      my $unique = {};
      foreach (@{$self->{interfaces}}) {
        if (exists $unique->{$_->{ifDescr}}) {
          $unique->{$_->{ifDescr}}++;
        } else {
          $unique->{$_->{ifDescr}} = 0;
        }
      }
      foreach (sort {$a->{ifIndex} <=> $b->{ifIndex}} @{$self->{interfaces}}) {
        if ($unique->{$_->{ifDescr}}) {
          $_->{ifDescr} .= ' '.$_->{ifIndex};
        }
        $_->check();
      }
    }
  }
}

sub update_interface_cache {
  my $self = shift;
  my $force = shift;
  my $statefile = $self->create_interface_cache_file();
  my $update = time - 3600;
  if ($force || ! -f $statefile || ((stat $statefile)[9]) < ($update)) {
    $self->debug('force update of interface cache');
    $self->{interface_cache} = {};
    foreach ($self->get_snmp_table_objects( 'IFMIB', 'ifTable+ifXTable')) {
      # neuerdings index+descr, weil die drecksscheiss allied telesyn ports
      # alle gleich heissen
      $self->{interface_cache}->{$_->{ifIndex}}->{ifDescr} = $_->{ifDescr};
      $self->{interface_cache}->{$_->{ifIndex}}->{ifAlias} = $_->{ifAlias} if exists $_->{ifAlias};;
    }
    $self->save_interface_cache();
  }
  $self->load_interface_cache();
}

sub save_interface_cache {
  my $self = shift;
  $self->create_statefilesdir();
  my $statefile = $self->create_interface_cache_file();
  my $tmpfile = $NWC::Device::statefilesdir.'/check_nwc_health_tmp_'.$$;
  my $fh = IO::File->new();
  $fh->open(">$tmpfile");
  $fh->print(Data::Dumper::Dumper($self->{interface_cache}));
  $fh->flush();
  $fh->close();
  my $ren = rename $tmpfile, $statefile;
  $self->debug(sprintf "saved %s to %s",
      Data::Dumper::Dumper($self->{interface_cache}), $statefile);

}

sub load_interface_cache {
  my $self = shift;
  my $statefile = $self->create_interface_cache_file();
  if ( -f $statefile) {
    our $VAR1;
    eval {
      require $statefile;
    };
    if($@) {
      printf "rumms\n";
    }
    $self->debug(sprintf "load %s", Data::Dumper::Dumper($VAR1));
    $self->{interface_cache} = $VAR1;
    eval {
      foreach (keys %{$self->{interface_cache}}) {
        /^\d+$/ || die "newrelease";
      }
    };
    if($@) {
      $self->{interface_cache} = {};
      unlink $statefile;
      delete $INC{$statefile};
      $self->update_interface_cache(1);
    }
  }
}

sub get_interface_indices {
  my $self = shift;
  my @indices = ();
  foreach my $ifIndex (keys %{$self->{interface_cache}}) {
    my $ifDescr = $self->{interface_cache}->{$ifIndex}->{ifDescr};
    my $ifAlias = $self->{interface_cache}->{$ifIndex}->{ifAlias} || '________';
    if ($self->opts->name) {
      if ($self->opts->regexp) {
        my $pattern = $self->opts->name;
        if ($ifDescr =~ /$pattern/i) {
          push(@indices, [$ifIndex]);
        }
      } else {
        if ($self->opts->name =~ /^\d+$/) {
          if ($ifIndex == 1 * $self->opts->name) {
            push(@indices, [1 * $self->opts->name]);
          }
        } else {
          if (lc $ifDescr eq lc $self->opts->name) {
            push(@indices, [$ifIndex]);
          }
        }
      }
    } else {
      push(@indices, [$ifIndex]);
    }
  }
  return @indices;
}

sub dump {
  my $self = shift;
  foreach (@{$self->{interfaces}}) {
    $_->dump();
  }
}


package NWC::IFMIB::Component::InterfaceSubsystem::Interface;
our @ISA = qw(NWC::IFMIB::Component::InterfaceSubsystem);

use strict;
use constant { OK => 0, WARNING => 1, CRITICAL => 2, UNKNOWN => 3 };

sub new {
  my $class = shift;
  my %params = @_;
  my $self = {
    ifTable => $params{ifTable},
    ifEntry => $params{ifEntry},
    ifIndex => $params{ifIndex},
    ifDescr => $params{ifDescr},
    ifType => $params{ifType},
    ifMtu => $params{ifMtu},
    ifSpeed => $params{ifSpeed},
    ifPhysAddress => $params{ifPhysAddress},
    ifAdminStatus => $params{ifAdminStatus},
    ifOperStatus => $params{ifOperStatus},
    ifLastChange => $params{ifLastChange},
    ifInOctets => $params{ifInOctets},
    ifInUcastPkts => $params{ifInUcastPkts},
    ifInNUcastPkts => $params{ifInNUcastPkts},
    ifInDiscards => $params{ifInDiscards},
    ifInErrors => $params{ifInErrors},
    ifInUnknownProtos => $params{ifInUnknownProtos},
    ifOutOctets => $params{ifOutOctets},
    ifOutUcastPkts => $params{ifOutUcastPkts},
    ifOutNUcastPkts => $params{ifOutNUcastPkts},
    ifOutDiscards => $params{ifOutDiscards},
    ifOutErrors => $params{ifOutErrors},
    ifOutQLen => $params{ifOutQLen},
    ifSpecific => $params{ifSpecific},
    blacklisted => 0,
    info => undef,
    extendedinfo => undef,
  };
  foreach my $key (keys %{$self}) {
    next if $key !~ /^if/;
    $self->{$key} = 0 if ! defined $params{$key};
  }
  bless $self, $class;
  #if (0) {
  if ($params{ifName}) {
    my $self64 = {
      ifName => $params{ifName},
      ifInMulticastPkts => $params{ifInMulticastPkts},
      ifInBroadcastPkts => $params{ifInBroadcastPkts},
      ifOutMulticastPkts => $params{ifOutMulticastPkts},
      ifOutBroadcastPkts => $params{ifOutBroadcastPkts},
      ifHCInOctets => $params{ifHCInOctets},
      ifHCInUcastPkts => $params{ifHCInUcastPkts},
      ifHCInMulticastPkts => $params{ifHCInMulticastPkts},
      ifHCInBroadcastPkts => $params{ifHCInBroadcastPkts},
      ifHCOutOctets => $params{ifHCOutOctets},
      ifHCOutUcastPkts => $params{ifHCOutUcastPkts},
      ifHCOutMulticastPkts => $params{ifHCOutMulticastPkts},
      ifHCOutBroadcastPkts => $params{ifHCOutBroadcastPkts},
      ifLinkUpDownTrapEnable => $params{ifLinkUpDownTrapEnable},
      ifHighSpeed => $params{ifHighSpeed},
      ifPromiscuousMode => $params{ifPromiscuousMode},
      ifConnectorPresent => $params{ifConnectorPresent},
      ifAlias => $params{ifAlias},
      ifCounterDiscontinuityTime => $params{ifCounterDiscontinuityTime},
    };
    map { $self->{$_} = $self64->{$_} } keys %{$self64};
    bless $self, 'NWC::IFMIB::Component::InterfaceSubsystem::Interface::64bit';
  }
  $self->init();
  return $self;
}

sub init {
  my $self = shift;
  if ($self->mode =~ /device::interfaces::traffic/) {
    $self->valdiff({name => $self->{ifDescr}}, qw(ifInOctets ifInUcastPkts ifInNUcastPkts ifInDiscards ifInErrors ifInUnknownProtos ifOutOctets ifOutUcastPkts ifOutNUcastPkts ifOutDiscards ifOutErrors));
  } elsif ($self->mode =~ /device::interfaces::usage/) {
    $self->valdiff({name => $self->{ifIndex}.'#'.$self->{ifDescr}}, qw(ifInOctets ifOutOctets));
    if ($self->{ifSpeed} == 0) {
      # vlan graffl
      $self->{inputUtilization} = 0;
      $self->{outputUtilization} = 0;
    } else {
      $self->{inputUtilization} = $self->{delta_ifInOctets} * 8 * 100 /
          ($self->{delta_timestamp} * $self->{ifSpeed});
      $self->{outputUtilization} = $self->{delta_ifOutOctets} * 8 * 100 /
          ($self->{delta_timestamp} * $self->{ifSpeed});
    }
    if (defined $self->opts->ifspeedin) {
      $self->{inputUtilization} = $self->{delta_ifInOctets} * 8 * 100 /
          ($self->{delta_timestamp} * $self->opts->ifspeedin);
    }
    if (defined $self->opts->ifspeedout) {
      $self->{outputUtilization} = $self->{delta_ifOutOctets} * 8 * 100 /
          ($self->{delta_timestamp} * $self->opts->ifspeedout);
    }
    if (defined $self->opts->ifspeed) {
      $self->{inputUtilization} = $self->{delta_ifInOctets} * 8 * 100 /
          ($self->{delta_timestamp} * $self->opts->ifspeed);
      $self->{outputUtilization} = $self->{delta_ifOutOctets} * 8 * 100 /
          ($self->{delta_timestamp} * $self->opts->ifspeed);
    }
    $self->{inputRate} = $self->{delta_ifInOctets} / $self->{delta_timestamp};
    $self->{outputRate} = $self->{delta_ifOutOctets} / $self->{delta_timestamp};
    my $factor = 1/8; # default Bits
    if ($self->opts->units) {
      if ($self->opts->units eq "GB") {
        $factor = 1024 * 1024 * 1024;
      } elsif ($self->opts->units eq "MB") {
        $factor = 1024 * 1024;
      } elsif ($self->opts->units eq "KB") {
        $factor = 1024;
      } elsif ($self->opts->units eq "GBi") {
        $factor = 1024 * 1024 * 1024 / 8;
      } elsif ($self->opts->units eq "MBi") {
        $factor = 1024 * 1024 / 8;
      } elsif ($self->opts->units eq "KBi") {
        $factor = 1024 / 8;
      } elsif ($self->opts->units eq "B") {
        $factor = 1;
      } elsif ($self->opts->units eq "Bit") {
        $factor = 1/8;
      }
    }
    $self->{inputRate} /= $factor;
    $self->{outputRate} /= $factor;
    if ($self->{ifOperStatus} eq 'down') {
      $self->{inputUtilization} = 0;
      $self->{outputUtilization} = 0;
      $self->{inputRate} = 0;
      $self->{outputRate} = 0;
    }
  } elsif ($self->mode =~ /device::interfaces::errors/) {
    $self->valdiff({name => $self->{ifDescr}}, qw(ifInErrors ifOutErrors ifInDiscards ifOutDiscards));
    $self->{inputErrorRate} = $self->{delta_ifInErrors} 
        / $self->{delta_timestamp};
    $self->{outputErrorRate} = $self->{delta_ifOutErrors} 
        / $self->{delta_timestamp};
    $self->{inputDiscardRate} = $self->{delta_ifInDiscards} 
        / $self->{delta_timestamp};
    $self->{outputDiscardRate} = $self->{delta_ifOutDiscards} 
        / $self->{delta_timestamp};
    $self->{inputRate} = ($self->{delta_ifInErrors} + $self->{delta_ifInDiscards}) 
        / $self->{delta_timestamp};
    $self->{outputRate} = ($self->{delta_ifOutErrors} + $self->{delta_ifOutDiscards}) 
        / $self->{delta_timestamp};
  } elsif ($self->mode =~ /device::interfaces::operstatus/) {
  } elsif ($self->mode =~ /device::interfaces::availability/) {
    $self->{ifStatusDuration} = 
        $NWC::Device::uptime - $self->timeticks($self->{ifLastChange});
    $self->opts->override_opt('lookback', 1800) if ! $self->opts->lookback;
    if ($self->{ifAdminStatus} eq "down") {
      $self->{ifAvailable} = "true";
    } elsif ($self->{ifAdminStatus} eq "up" && $self->{ifOperStatus} ne "up" &&
        $self->{ifStatusDuration} > $self->opts->lookback) {
      # and ifLastChange schon ein wenig laenger her
      $self->{ifAvailable} = "true";
    } else {
      $self->{ifAvailable} = "false";
    }
    my $gb = 1000 * 1000 * 1000;
    my $mb = 1000 * 1000;
    my $kb = 1000;
    my $speed = $self->{ifHighSpeed} ? 
        ($self->{ifHighSpeed} * $mb) : $self->{ifSpeed};
    if ($speed >= $gb) {
      $self->{ifSpeedText} = sprintf "%.2fGB", $speed / $gb;
    } elsif ($speed >= $mb) {
      $self->{ifSpeedText} = sprintf "%.2fMB", $speed / $mb;
    } elsif ($speed >= $kb) {
      $self->{ifSpeedText} = sprintf "%.2fKB", $speed / $kb;
    } else {
      $self->{ifSpeedText} = sprintf "%.2fB", $speed;
    }
    $self->{ifSpeedText} =~ s/\.00//g;
  }
  return $self;
}

sub check {
  my $self = shift;
  $self->blacklist('if', $self->{ifIndex});
  if ($self->mode =~ /device::interfaces::traffic/) {
  } elsif ($self->mode =~ /device::interfaces::usage/) {
    my $info = sprintf 'interface %s usage is in:%.2f%% (%s) out:%.2f%% (%s)%s',
        $self->{ifDescr}, 
        $self->{inputUtilization}, 
        sprintf("%.2f%s/s", $self->{inputRate},
            ($self->opts->units ? $self->opts->units : 'Bits')),
        $self->{outputUtilization},
        sprintf("%.2f%s/s", $self->{outputRate},
            ($self->opts->units ? $self->opts->units : 'Bits')),
        $self->{ifOperStatus} eq 'down' ? ' (down)' : '';
    $self->add_info($info);
    $self->set_thresholds(warning => 80, critical => 90);
    my $in = $self->check_thresholds($self->{inputUtilization});
    my $out = $self->check_thresholds($self->{outputUtilization});
    my $level = ($in > $out) ? $in : ($out > $in) ? $out : $in;
    $self->add_message($level, $info);
    $self->add_perfdata(
        label => $self->{ifDescr}.'_usage_in',
        value => $self->{inputUtilization},
        uom => '%',
        warning => $self->{warning},
        critical => $self->{critical},
    );
    $self->add_perfdata(
        label => $self->{ifDescr}.'_usage_out',
        value => $self->{outputUtilization},
        uom => '%',
        warning => $self->{warning},
        critical => $self->{critical},
    );
    $self->add_perfdata(
        label => $self->{ifDescr}.'_traffic_in',
        value => $self->{inputRate},
        uom => $self->opts->units,
    );
    $self->add_perfdata(
        label => $self->{ifDescr}.'_traffic_out',
        value => $self->{outputRate},
        uom => $self->opts->units,
    );
  } elsif ($self->mode =~ /device::interfaces::errors/) {
    my $info = sprintf 'interface %s errors in:%.2f/s out:%.2f/s '.
        'discards in:%.2f/s out:%.2f/s',
        $self->{ifDescr},
        $self->{inputErrorRate} , $self->{outputErrorRate},
        $self->{inputDiscardRate} , $self->{outputDiscardRate};
    $self->add_info($info);
    $self->set_thresholds(warning => 1, critical => 10);
    my $in = $self->check_thresholds($self->{inputRate});
    my $out = $self->check_thresholds($self->{outputRate});
    my $level = ($in > $out) ? $in : ($out > $in) ? $out : $in;
    $self->add_message($level, $info);
    $self->add_perfdata(
        label => $self->{ifDescr}.'_errors_in',
        value => $self->{inputErrorRate},
        warning => $self->{warning},
        critical => $self->{critical},
    );
    $self->add_perfdata(
        label => $self->{ifDescr}.'_errors_out',
        value => $self->{outputErrorRate},
        warning => $self->{warning},
        critical => $self->{critical},
    );
    $self->add_perfdata(
        label => $self->{ifDescr}.'_discards_in',
        value => $self->{inputDiscardRate},
        warning => $self->{warning},
        critical => $self->{critical},
    );
    $self->add_perfdata(
        label => $self->{ifDescr}.'_discards_out',
        value => $self->{outputDiscardRate},
        warning => $self->{warning},
        critical => $self->{critical},
    );
  } elsif ($self->mode =~ /device::interfaces::operstatus/) {
    #rfc2863
    #(1)   if ifAdminStatus is not down and ifOperStatus is down then a
    #     fault condition is presumed to exist on the interface.
    #(2)   if ifAdminStatus is down, then ifOperStatus will normally also
    #     be down (or notPresent) i.e., there is not (necessarily) a
    #     fault condition on the interface.
    # --warning onu,anu
    # Admin: admindown,admin
    # Admin: --warning 
    #        --critical admindown
    # !ad+od  ad+!(od*on)
    # warn & warnbitfield
#    if ($self->opts->critical) {
#      if ($self->opts->critical =~ /^u/) {
#      } elsif ($self->opts->critical =~ /^u/) {
#      }
#    }
#    if ($self->{ifOperStatus} ne 'up') {
#      }
#    } 
    my $info = sprintf '%s is %s/%s',
        $self->{ifDescr}, $self->{ifOperStatus}, $self->{ifAdminStatus};
    $self->add_info($info);
    $self->add_message(OK, $info);
    if ($self->{ifOperStatus} eq 'down' && $self->{ifAdminStatus} ne 'down') {
      $self->add_message(CRITICAL, 
          sprintf 'fault condition is presumed to exist on %s',
          $self->{ifDescr});
    }
  } elsif ($self->mode =~ /device::interfaces::availability/) {
    $self->{ifStatusDuration} = 
        $self->human_timeticks($self->{ifStatusDuration});
    my $info = sprintf '%s is %savailable (%s/%s, since %s)',
        $self->{ifDescr}, ($self->{ifAvailable} eq "true" ? "" : "un"),
        $self->{ifOperStatus}, $self->{ifAdminStatus},
        $self->{ifStatusDuration};
    $self->add_info($info);
  }
}

sub list {
  my $self = shift;
  if ($self->mode =~ /device::interfaces::listdetail/) {
    my $cL2L3IfModeOper = $self->get_snmp_object('CISCO-L2L3-INTERFACE-CONFIG-MIB', 'cL2L3IfModeOper', $self->{ifIndex}) || "unknown";
    my $vlanTrunkPortDynamicStatus = $self->get_snmp_object('CISCO-VTP-MIB', 'vlanTrunkPortDynamicStatus', $self->{ifIndex}) || "unknown";
    printf "%06d %s %s %s\n", $self->{ifIndex}, $self->{ifDescr},
        $cL2L3IfModeOper, $vlanTrunkPortDynamicStatus;
  } else {
    printf "%06d %s\n", $self->{ifIndex}, $self->{ifDescr};
  }
}

sub dump {
  my $self = shift;
  printf "[IF32_%s]\n", $self->{ifIndex};
  foreach (qw(ifIndex ifDescr ifType ifMtu ifSpeed ifPhysAddress ifAdminStatus ifOperStatus ifLastChange ifInOctets ifInUcastPkts ifInNUcastPkts ifInDiscards ifInErrors ifInUnknownProtos ifOutOctets ifOutUcastPkts ifOutNUcastPkts ifOutDiscards ifOutErrors ifOutQLen ifSpecific)) {
    printf "%s: %s\n", $_, defined $self->{$_} ? $self->{$_} : 'undefined';
  }
#  printf "info: %s\n", $self->{info};
  printf "\n";
}

package NWC::IFMIB::Component::InterfaceSubsystem::Interface::64bit;
our @ISA = qw(NWC::IFMIB::Component::InterfaceSubsystem::Interface);

use strict;
use constant { OK => 0, WARNING => 1, CRITICAL => 2, UNKNOWN => 3 };

sub dump {
  my $self = shift;
  printf "[IF64_%s]\n", $self->{ifIndex};
  foreach (qw(ifIndex ifDescr ifType ifMtu ifSpeed ifPhysAddress ifAdminStatus ifOperStatus ifLastChange ifInOctets ifInUcastPkts ifInNUcastPkts ifInDiscards ifInErrors ifInUnknownProtos ifOutOctets ifOutUcastPkts ifOutNUcastPkts ifOutDiscards ifOutErrors ifOutQLen ifSpecific ifName ifInMulticastPkts ifInBroadcastPkts ifOutMulticastPkts ifOutBroadcastPkts ifHCInOctets ifHCInUcastPkts ifHCInMulticastPkts ifHCInBroadcastPkts ifHCOutOctets ifHCOutUcastPkts ifHCOutMulticastPkts ifHCOutBroadcastPkts ifLinkUpDownTrapEnable ifHighSpeed ifPromiscuousMode ifConnectorPresent ifAlias ifCounterDiscontinuityTime)) {
    printf "%s: %s\n", $_, defined $self->{$_} ? $self->{$_} : 'undefined';
  }
#  printf "info: %s\n", $self->{info};
  printf "\n";
}


package NWC::IFMIB;

use strict;

use constant { OK => 0, WARNING => 1, CRITICAL => 2, UNKNOWN => 3 };

our @ISA = qw(NWC::Device);

package NWC::FCMGMT::Component::EnvironmentalSubsystem;
our @ISA = qw(NWC::FCMGMT);

use strict;
use constant { OK => 0, WARNING => 1, CRITICAL => 2, UNKNOWN => 3 };

sub new {
  my $class = shift;
  my %params = @_;
  my $self = {
    runtime => $params{runtime},
    rawdata => $params{rawdata},
    method => $params{method},
    condition => $params{condition},
    status => $params{status},
    sensor_subsystem => undef,
    blacklisted => 0,
    info => undef,
    extendedinfo => undef,
  };
  bless $self, $class;
  $self->init(%params);
  return $self;
}

sub init {
  my $self = shift;
  my %params = @_;
  $self->{sensor_subsystem} =
      NWC::FCMGMT::Component::SensorSubsystem->new(%params);
}

sub check {
  my $self = shift;
  my $errorfound = 0;
  $self->{sensor_subsystem}->check();
  if (! $self->check_messages()) {
    $self->add_message(OK, "environmental hardware working fine");
  }
}

sub dump {
  my $self = shift;
  $self->{sensor_subsystem}->dump();
}


package NWC::FCMGMT::Component::SensorSubsystem;
our @ISA = qw(NWC::FCMGMT::Component::EnvironmentalSubsystem);

use strict;
use constant { OK => 0, WARNING => 1, CRITICAL => 2, UNKNOWN => 3 };

sub new {
  my $class = shift;
  my %params = @_;
  my $self = {
    sensors => [],
    sensorthresholds => [],
    blacklisted => 0,
    info => undef,
    extendedinfo => undef,
  };
  bless $self, $class;
  $self->init(%params);
  return $self;
}

sub init {
  my $self = shift;
  my $sensors = {};
  foreach ($self->get_snmp_table_objects(
      'FCMGMT-MIB', 'fcConnUnitSensorTable')) {
    $_->{fcConnUnitSensorIndex} ||= $_->{indices}->[-1];
    push(@{$self->{sensors}}, 
        NWC::FCMGMT::Component::SensorSubsystem::Sensor->new(%{$_}));
  }
}

sub check {
  my $self = shift;
  my $errorfound = 0;
  $self->add_info('checking sensors');
  $self->blacklist('ses', '');
  if (scalar (@{$self->{sensors}}) == 0) {
  } else {
    foreach (@{$self->{sensors}}) {
      $_->check();
    }
  }
}


sub dump {
  my $self = shift;
  foreach (@{$self->{sensors}}) {
    $_->dump();
  }
}


package NWC::FCMGMT::Component::SensorSubsystem::Sensor;
our @ISA = qw(NWC::FCMGMT::Component::SensorSubsystem);

use strict;
use constant { OK => 0, WARNING => 1, CRITICAL => 2, UNKNOWN => 3 };

sub new {
  my $class = shift;
  my %params = @_;
  my $self = {
    blacklisted => 0,
    info => undef,
    extendedinfo => undef,
  };
  foreach my $param (qw(fcConnUnitSensorIndex fcConnUnitSensorName
      fcConnUnitSensorStatus fcConnUnitSensorStatus
      fcConnUnitSensorType fcConnUnitSensorCharacteristic
      fcConnUnitSensorInfo fcConnUnitSensorMessage)) {
    $self->{$param} = $params{$param};
  }
  bless $self, $class;
  return $self;
}

sub check {
  my $self = shift;
  $self->blacklist('se', $self->{swSensorIndex});
  $self->add_info(sprintf '%s sensor %s (%s) is %s (%s)',
      $self->{fcConnUnitSensorType},
      $self->{fcConnUnitSensorIndex},
      $self->{fcConnUnitSensorInfo},
      $self->{fcConnUnitSensorStatus},
      $self->{fcConnUnitSensorMessage});
  if ($self->{fcConnUnitSensorStatus} ne "ok") {
    $self->add_message(CRITICAL, $self->{info});
  } else {
    #$self->add_message(OK, $self->{info});
  }
}

sub dump {
  my $self = shift;
  printf "[SENSOR_%s_%s]\n", $self->{fcConnUnitSensorType}, $self->{fcConnUnitSensorIndex};
  foreach (qw(fcConnUnitSensorIndex fcConnUnitSensorName
      fcConnUnitSensorType fcConnUnitSensorCharacteristic
      fcConnUnitSensorStatus
      fcConnUnitSensorInfo fcConnUnitSensorMessage)) {
    printf "%s: %s\n", $_, $self->{$_};
  }
  printf "info: %s\n", $self->{info};
  printf "\n";
}

package NWC::FCMGMT;

use strict;

use constant { OK => 0, WARNING => 1, CRITICAL => 2, UNKNOWN => 3 };

our @ISA = qw(NWC::Device);

package NWC::FCEOS::Component::EnvironmentalSubsystem;
our @ISA = qw(NWC::FCEOS);

use strict;
use constant { OK => 0, WARNING => 1, CRITICAL => 2, UNKNOWN => 3 };

sub new {
  my $class = shift;
  my %params = @_;
  my $self = {
    runtime => $params{runtime},
    rawdata => $params{rawdata},
    method => $params{method},
    condition => $params{condition},
    status => $params{status},
    fru_subsystem => undef,
    blacklisted => 0,
    info => undef,
    extendedinfo => undef,
  };
  bless $self, $class;
  $self->overall_init(%params);
  $self->init(%params);
  return $self;
}


sub overall_init {
  my $self = shift;
  my %params = @_;
  $self->{oper_status} = $self->get_snmp_object('FCEOS-MIB', 'fcEosSysOperStatus');
}

sub init {
  my $self = shift;
  my %params = @_;
  $self->{fru_subsystem} =
      NWC::FCEOS::Component::FruSubsystem->new(%params);
}

sub check {
  my $self = shift;
  my $errorfound = 0;
  $self->{fru_subsystem}->check();
  if (! $self->check_messages()) {
    $self->add_message(OK, "environmental hardware working fine");
  } else {
    if ($self->{oper_status} eq "operational") {
      $self->clear_messages(CRITICAL);
      $self->clear_messages(WARNING);
    } elsif ($self->{oper_status} eq "major-failure") {
      $self->add_message(CRITICAL, "major device failure");
    } else {
      $self->add_message(WARNING, $self->{oper_status});
    }
  }
}

sub dump {
  my $self = shift;
  $self->{fru_subsystem}->dump();
}



package NWC::FCEOS::Component::FruSubsystem;
our @ISA = qw(NWC::FCEOS::Component::EnvironmentalSubsystem);

use strict;
use constant { OK => 0, WARNING => 1, CRITICAL => 2, UNKNOWN => 3 };

sub new {
  my $class = shift;
  my %params = @_;
  my $self = {
    frus => [],
    thresholds => [],
    blacklisted => 0,
    info => undef,
    extendedinfo => undef,
  };
  bless $self, $class;
  $self->init(%params);
  return $self;
}

sub init {
  my $self = shift;
  my $sensors = {};
  foreach ($self->get_snmp_table_objects(
      'FCEOS-MIB', 'fcEosFruTable')) {
    push(@{$self->{frus}}, 
        NWC::FCEOS::Component::FruSubsystem::Fcu->new(%{$_}));
  }
}

sub check {
  my $self = shift;
  my $errorfound = 0;
  $self->add_info('checking frus');
  $self->blacklist('frus', '');
  if (scalar (@{$self->{frus}}) == 0) {
  } else {
    foreach (@{$self->{frus}}) {
      $_->check();
    }
  }
}


sub dump {
  my $self = shift;
  foreach (@{$self->{frus}}) {
    $_->dump();
  }
}


package NWC::FCEOS::Component::FruSubsystem::Fcu;
our @ISA = qw(NWC::FCEOS::Component::FruSubsystem);

use strict;
use constant { OK => 0, WARNING => 1, CRITICAL => 2, UNKNOWN => 3 };

sub new {
  my $class = shift;
  my %params = @_;
  my $self = {
    blacklisted => 0,
    info => undef,
    extendedinfo => undef,
  };
  foreach my $param (qw(fcEosFruCode fcEosFruPosition fcEosFruStatus
      fcEosFruPartNumber fcEosFruPowerOnHours)) {
    $self->{$param} = $params{$param};
  }
  bless $self, $class;
  return $self;
}

sub check {
  my $self = shift;
  $self->blacklist('fru', $self->{swSensorIndex});
  $self->add_info(sprintf '%s fru (pos %s) is %s',
      $self->{fcEosFruCode},
      $self->{fcEosFruPosition},
      $self->{fcEosFruStatus});
  if ($self->{fcEosFruStatus} eq "failed") {
    $self->add_message(CRITICAL, $self->{info});
  } else {
    #$self->add_message(OK, $self->{info});
  }
}

sub dump {
  my $self = shift;
  printf "[FRU_%s]\n", $self->{fcEosFruPosition};
  foreach (qw(fcEosFruCode fcEosFruPosition fcEosFruStatus
      fcEosFruPartNumber fcEosFruPowerOnHours)) {
    printf "%s: %s\n", $_, $self->{$_};
  }
  printf "info: %s\n", $self->{info};
  printf "\n";
}


package NWC::FCEOS;

use strict;

use constant { OK => 0, WARNING => 1, CRITICAL => 2, UNKNOWN => 3 };

our @ISA = qw(NWC::Device);

package NWC::UCDMIB::Component::MemSubsystem;
our @ISA = qw(NWC::UCDMIB);

use strict;
use constant { OK => 0, WARNING => 1, CRITICAL => 2, UNKNOWN => 3 };

sub new {
  my $class = shift;
  my %params = @_;
  my $self = {
    runtime => $params{runtime},
    rawdata => $params{rawdata},
    mems => [],
    blacklisted => 0,
    info => undef,
    extendedinfo => undef,
  };
  bless $self, $class;
  $self->init(%params);
  return $self;
}

sub init {
  my $self = shift;
  my %params = @_;
  my $snmpwalk = $params{rawdata};
  my $ignore_redundancy = $params{ignore_redundancy};
  my $type = 0;
  foreach (qw(memTotalSwap memAvailSwap memTotalReal memAvailReal memTotalFree)) {
    $self->{$_} = $self->get_snmp_object('UCD-SNMP-MIB', $_, 0);
  }
  # https://kc.mcafee.com/corporate/index?page=content&id=KB73175
  $self->{mem_usage} = ($self->{memTotalReal} - $self->{memTotalFree}) /
      $self->{memTotalReal} * 100;
  $self->{mem_usage} = $self->{memAvailReal} * 100 / $self->{memTotalReal};
}

sub check {
  my $self = shift;
  my $errorfound = 0;
  $self->add_info('checking memory');
  $self->blacklist('m', '');
  if (defined $self->{mem_usage}) {
    my $info = sprintf 'memory usage is %.2f%%',
        $self->{mem_usage};
    $self->add_info($info);
    $self->set_thresholds(warning => 80,
        critical => 90);
    $self->add_message($self->check_thresholds($self->{mem_usage}), $info);
    $self->add_perfdata(
        label => 'memory_usage',
        value => $self->{mem_usage},
        uom => '%',
        warning => $self->{warning},
        critical => $self->{critical}
    );
  } else {
    $self->add_message(UNKNOWN, 'cannot aquire momory usage');
  }
}

sub dump {
  my $self = shift;
  printf "[MEMORY]\n";
  foreach (qw(memTotalSwap memAvailSwap memTotalReal memAvailReal memTotalFree)) {
    printf "%s: %s\n", $_, $self->{$_};
  }
  printf "info: %s\n", $self->{info};
  printf "\n";
}

package NWC::UCDMIB::Component::CpuSubsystem;
our @ISA = qw(NWC::UCDMIB);

use strict;
use constant { OK => 0, WARNING => 1, CRITICAL => 2, UNKNOWN => 3 };

sub new {
  my $class = shift;
  my %params = @_;
  my $self = {
    loads => [],
    blacklisted => 0,
    info => undef,
    extendedinfo => undef,
  };
  bless $self, $class;
  $self->init(%params);
  return $self;
}

sub init {
  my $self = shift;
  my %params = @_;
  my $type = 0;
  foreach (qw(ssCpuUser ssCpuSystem ssCpuIdle
      ssCpuRawUser ssCpuRawSystem ssCpuRawIdle ssCpuRawNice)) {
    $self->{$_} = $self->get_snmp_object('UCD-SNMP-MIB', $_, 0);
  }
  $self->valdiff(\%params, qw(ssCpuRawUser ssCpuRawSystem ssCpuRawIdle ssCpuRawNice));
  my $cpu_total = $self->{delta_ssCpuRawUser} + $self->{delta_ssCpuRawSystem} +
      $self->{delta_ssCpuRawIdle} + $self->{delta_ssCpuRawNice};
  if ($cpu_total == 0) {
    $self->{cpu_usage} = 0;
  } else {
    $self->{cpu_usage} = (100 - ($self->{delta_ssCpuRawIdle} / $cpu_total) * 100);
  }
}

sub check {
  my $self = shift;
  my $errorfound = 0;
  $self->add_info('checking cpus');
  $self->blacklist('c', undef);
  my $info = sprintf 'cpu usage is %.2f%%', $self->{cpu_usage};
  $self->add_info($info);
  $self->set_thresholds(warning => 50, critical => 90);
  $self->add_message($self->check_thresholds($self->{cpu_usage}), $info);
  $self->add_perfdata(
      label => 'cpu_usage',
      value => $self->{cpu_usage},
      uom => '%',
      warning => $self->{warning},
      critical => $self->{critical},
  );
}

sub dump {
  my $self = shift;
  printf "[CPU]\n";
  foreach (qw(ssCpuUser ssCpuSystem ssCpuIdle
      ssCpuRawUser ssCpuRawSystem ssCpuRawIdle ssCpuRawNice)) {
    printf "%s: %s\n", $_, $self->{$_};
  }
  printf "info: %s\n", $self->{info};
  printf "\n";
}

sub unix_init {
  my $self = shift;
  my %params = @_;
  my $type = 0;
  foreach ($self->get_snmp_table_objects(
     'UCD-SNMP-MIB', 'laTable')) {
    push(@{$self->{loads}},
        NWC::UCDMIB::Component::CpuSubsystem::Load->new(%{$_}));
  }
}

sub unix_check {
  my $self = shift;
  my $errorfound = 0;
  $self->add_info('checking loads');
  $self->blacklist('c', '');
  foreach (@{$self->{loads}}) {
    $_->check();
  }
}

sub unix_dump {
  my $self = shift;
  foreach (@{$self->{loads}}) {
    $_->dump();
  }
}


package NWC::UCDMIB::Component::CpuSubsystem::Load;
our @ISA = qw(NWC::UCDMIB::Component::CpuSubsystem);

use strict;
use constant { OK => 0, WARNING => 1, CRITICAL => 2, UNKNOWN => 3 };

sub new {
  my $class = shift;
  my %params = @_;
  my $self = {
    blacklisted => 0,
    info => undef,
    extendedinfo => undef,
  };
  foreach my $param (qw(laIndex laNames laLoad laConfig laLoadFloat 
      laErrorFlag laErrMessage)) {
    $self->{$param} = $params{$param};
  }
  bless $self, $class;
  return $self;
}

sub check {
  my $self = shift;
  my $errorfound = 0;
  $self->blacklist('c', undef);
  my $info = sprintf '%s is %.2f', lc $self->{laNames}, $self->{laLoadFloat};
  $self->add_info($info);
  $self->set_thresholds(warning => $self->{laConfig},
      critical => $self->{laConfig});
  $self->add_message($self->check_thresholds($self->{laLoadFloat}), $info);
  $self->add_perfdata(
      label => lc $self->{laNames},
      value => $self->{laLoadFloat},
      warning => $self->{warning},
      critical => $self->{critical},
  );
}

sub dump {
  my $self = shift;
  printf "[LOAD_%s]\n", lc $self->{laNames};
  foreach (qw(laIndex laNames laLoad laConfig laLoadFloat 
      laErrorFlag laErrMessage)) {
    printf "%s: %s\n", $_, $self->{$_};
  }
  printf "info: %s\n", $self->{info};
  printf "\n";
}

package NWC::UCDMIB;

use strict;

use constant { OK => 0, WARNING => 1, CRITICAL => 2, UNKNOWN => 3 };

our @ISA = qw(NWC::Device);

package NWC::F5::F5BIGIP::Component::LTMSubsystem;
our @ISA = qw(NWC::F5::F5BIGIP);

use strict;
use constant { OK => 0, WARNING => 1, CRITICAL => 2, UNKNOWN => 3 };

sub new {
  my $class = shift;
  my %params = @_;
  my $self = {
    pools => [],
    poolmembers => [],
    blacklisted => 0,
    info => undef,
    extendedinfo => undef,
  };
  #bless $self, $class;
  # tables can be huge
  if ($NWC::Device::session) {
    $NWC::Device::session->max_msg_size(10 * $NWC::Device::session->max_msg_size());
  }
  if ($params{productversion} =~ /^4/) {
    bless $self, "NWC::F5::F5BIGIP::Component::LTMSubsystem4";
    $self->debug("use NWC::F5::F5BIGIP::Component::LTMSubsystem4");
  #} elsif ($params{productversion} =~ /^9/) {
  } else {
    bless $self, "NWC::F5::F5BIGIP::Component::LTMSubsystem9";
    $self->debug("use NWC::F5::F5BIGIP::Component::LTMSubsystem9");
  }
  $self->init(%params);
  return $self;
}

sub check {
  my $self = shift;
  my $errorfound = 0;
  $self->add_info('checking ltm pools');
  $self->blacklist('poo', '');
  if (scalar(@{$self->{pools}}) == 0) {
    $self->add_message(UNKNOWN, 'no pools');
    return;
  }
  if ($self->mode =~ /pool::list/) {
    foreach (sort {$a->{name} cmp $b->{name}} @{$self->{pools}}) {
      printf "%s\n", $_->{name};
      #$_->list();
    }
  } else {
    foreach (@{$self->{pools}}) {
      $_->check();
    }
  }
}

sub dump {
  my $self = shift;
  foreach (@{$self->{pools}}) {
    $_->dump();
  }
}

package NWC::F5::F5BIGIP::Component::LTMSubsystem9;
our @ISA = qw(NWC::F5::F5BIGIP::Component::LTMSubsystem);

use strict;
use constant { OK => 0, WARNING => 1, CRITICAL => 2, UNKNOWN => 3 };

sub new {
  my $class = shift;
  my %params = @_;
  my $self = {
    pools => [],
    poolmembers => [],
    blacklisted => 0,
    info => undef,
    extendedinfo => undef,
  };
  bless $self, $class;
  $self->init(%params);
  return $self;
}

sub init {
  my $self = shift;
  my %params = @_;
  # ! merge ltmPoolStatus, ltmPoolMemberStatus, bec. ltmPoolAvailabilityState is deprecated
  if ($self->mode =~ /pool::list/) {
    $self->update_entry_cache(1, 'F5-BIGIP-LOCAL-MIB', 'ltmPoolStatusTable', 'ltmPoolStatusName');
    $self->update_entry_cache(1, 'F5-BIGIP-LOCAL-MIB', 'ltmPoolTable', 'ltmPoolName');
    $self->update_entry_cache(1, 'F5-BIGIP-LOCAL-MIB', 'ltmPoolMbrStatusTable', 'ltmPoolMbrStatusPoolName');
    $self->update_entry_cache(1, 'F5-BIGIP-LOCAL-MIB', 'ltmPoolMemberTable', 'ltmPoolMemberPoolName');
  }
  my @auxpools = ();
  foreach ($self->get_snmp_table_objects_with_cache(
      'F5-BIGIP-LOCAL-MIB', 'ltmPoolStatusTable', 'ltmPoolStatusName')) {
    push(@auxpools, $_);
  }
  foreach ($self->get_snmp_table_objects_with_cache(
      'F5-BIGIP-LOCAL-MIB', 'ltmPoolTable', 'ltmPoolName')) {
    if ($self->filter_name($_->{ltmPoolName})) {
      foreach my $auxpool (@auxpools) {
        if ($_->{ltmPoolName} eq $auxpool->{ltmPoolStatusName}) {
          foreach my $key (keys %{$auxpool}) {
            $_->{$key} = $auxpool->{$key};
          }
        }
      }
      push(@{$self->{pools}},
          NWC::F5::F5BIGIP::Component::LTMSubsystem9::LTMPool->new(%{$_}));
    }
  }
  my @auxmembers = ();
  foreach ($self->get_snmp_table_objects_with_cache(
      'F5-BIGIP-LOCAL-MIB', 'ltmPoolMbrStatusTable', 'ltmPoolMbrStatusPoolName')) {
    push(@auxmembers, $_);
  }
  my @auxaddrs = ();
  foreach ($self->get_snmp_table_objects(
      'F5-BIGIP-LOCAL-MIB', 'ltmNodeAddrStatusTable')) {
    push(@auxaddrs, $_);
  }
  foreach ($self->get_snmp_table_objects_with_cache(
      'F5-BIGIP-LOCAL-MIB', 'ltmPoolMemberTable', 'ltmPoolMemberPoolName')) {
    if ($self->filter_name($_->{ltmPoolMemberPoolName})) {
      foreach my $auxmember (@auxmembers) {
        if ($_->{ltmPoolMemberPoolName} eq $auxmember->{ltmPoolMbrStatusPoolName} &&
            $_->{ltmPoolMemberAddrType} eq $auxmember->{ltmPoolMbrStatusAddrType} &&
            $_->{ltmPoolMemberAddr} eq $auxmember->{ltmPoolMbrStatusAddr}) {
          foreach my $key (keys %{$auxmember}) {
            $_->{$key} = $auxmember->{$key};
          }
        }
      }
      foreach my $auxaddr (@auxaddrs) {
        if ($_->{ltmPoolMemberAddrType} eq $auxaddr->{ltmNodeAddrStatusAddrType} &&
            $_->{ltmPoolMemberAddr} eq $auxaddr->{ltmNodeAddrStatusAddr}) {
          $_->{ltmNodeAddrStatusName} = $auxaddr->{ltmNodeAddrStatusName};
        }
      }
      push(@{$self->{poolmembers}},
          NWC::F5::F5BIGIP::Component::LTMSubsystem9::LTMPoolMember->new(%{$_}));
    }
  }
  $self->assign_members_to_pools();
}

sub assign_members_to_pools {
  my $self = shift;
  foreach my $pool (@{$self->{pools}}) {
    foreach my $poolmember (@{$self->{poolmembers}}) {
      if ($poolmember->{ltmPoolMemberPoolName} eq $pool->{ltmPoolName}) {
        $poolmember->{ltmPoolMonitorRule} = $pool->{ltmPoolMonitorRule};
        push(@{$pool->{members}}, $poolmember);
      }
    }
    if (! defined $pool->{ltmPoolMemberCnt}) {
      $pool->{ltmPoolMemberCnt} = scalar(@{$pool->{members}}) ;
      $self->debug("calculate ltmPoolMemberCnt");
    }
    $pool->{completeness} = $pool->{ltmPoolMemberCnt} ?
        $pool->{ltmPoolActiveMemberCnt} / $pool->{ltmPoolMemberCnt} * 100
        : 0;
  }
}


package NWC::F5::F5BIGIP::Component::LTMSubsystem9::LTMPool;
our @ISA = qw(NWC::F5::F5BIGIP::Component::LTMSubsystem9);

use strict;
use constant { OK => 0, WARNING => 1, CRITICAL => 2, UNKNOWN => 3 };

sub new {
  my $class = shift;
  my %params = @_;
  my $self = {
    blacklisted => 0,
    info => undef,
    extendedinfo => undef,
    members => [],
  };
  foreach(keys %params) {
    $self->{$_} = $params{$_};
  }
  $self->{ltmPoolMemberMonitorRule} ||= $self->{ltmPoolMonitorRule};
  $self->{name} = $self->{ltmPoolName};
  bless $self, $class;
  return $self;
}

sub check {
  my $self = shift;
  my %params = @_;
  $self->blacklist('po', $self->{ltmPoolName});
  $self->add_info(sprintf "pool %s is %s, avail state is %s, active members: %d of %d", 
      $self->{ltmPoolName},
      $self->{ltmPoolStatusEnabledState}, $self->{ltmPoolStatusAvailState},
      $self->{ltmPoolActiveMemberCnt}, $self->{ltmPoolMemberCnt});
  if ($self->{ltmPoolActiveMemberCnt} == 1) {
    # only one member left = no more redundancy!!
    $self->set_thresholds(warning => "100:", critical => "51:");
  } else {
    $self->set_thresholds(warning => "51:", critical => "26:");
  }
  $self->add_message($self->check_thresholds($self->{completeness}),
      sprintf ("pool %s has %d active members (of %d)",
          $self->{ltmPoolName},
          $self->{ltmPoolActiveMemberCnt}, $self->{ltmPoolMemberCnt}));
  if ($self->{ltmPoolMinActiveMembers} > 0 &&
      $self->{ltmPoolActiveMemberCnt} < $self->{ltmPoolMinActiveMembers}) {
    $self->add_message(
        defined $params{mitigation} ? $params{mitigation} : 2,
        sprintf("pool %s has not enough active members (%d, min is %d)", 
            $self->{ltmPoolName}, $self->{ltmPoolActiveMemberCnt}, 
            $self->{ltmPoolMinActiveMembers})
    );
  }
  if ($self->check_messages()) {
  foreach my $member (@{$self->{members}}) {
    $member->check();
  }
  }
  $self->add_perfdata(
      label => sprintf('pool_%s_completeness', $self->{ltmPoolName}),
      value => $self->{completeness},
      uom => '%',
      warning => $self->{warning},
      critical => $self->{critical},
  );
}

sub dump { 
  my $self = shift;
  printf "[POOL_%s]\n", $self->{ltmPoolName};
  foreach(qw(ltmPoolName ltmPoolLbMode ltmPoolMinActiveMembers
      ltmPoolActiveMemberCnt ltmPoolMemberCnt
      ltmPoolStatusAvailState ltmPoolStatusEnabledState ltmPoolStatusDetailReason)) {
    printf "%s: %s\n", $_, $self->{$_};
  }
  foreach my $member (@{$self->{members}}) {
    $member->dump();
  }
  printf "info: %s\n", $self->{info};
  printf "\n";
}


package NWC::F5::F5BIGIP::Component::LTMSubsystem9::LTMPoolMember;
our @ISA = qw(NWC::F5::F5BIGIP::Component::LTMSubsystem9);

use strict;
use constant { OK => 0, WARNING => 1, CRITICAL => 2, UNKNOWN => 3 };

sub new {
  my $class = shift;
  my %params = @_;
  my $self = {
    blacklisted => 0,
    info => undef,
    extendedinfo => undef,
  };
  foreach(keys %params) {
    $self->{$_} = $params{$_};
  }
  $self->{ltmPoolMemberAddr} =~ s/ //g;
  if ($self->{ltmPoolMemberAddr} =~ /^0x([0-9a-zA-Z]{8})/) {
    $self->{ltmPoolMemberAddr} = join(".", unpack "C*", pack "H*", $1);
  }
  $self->{ltmPoolMemberNodeName} ||= $self->{ltmPoolMemberAddr};
  if ($self->{ltmPoolMemberNodeName} eq $self->{ltmPoolMemberAddr} &&
      $self->{ltmNodeAddrStatusName}) {
    $self->{ltmPoolMemberNodeName} = $self->{ltmNodeAddrStatusName};
  }
  bless $self, $class;
  return $self;
}

sub check {
  my $self = shift;
  if ($self->{ltmPoolMbrStatusEnabledState} eq "enabled") {
    if ($self->{ltmPoolMbrStatusAvailState} ne "green") {
      $self->add_message(CRITICAL, sprintf
          "member %s is %s/%s (%s)",
          $self->{ltmPoolMemberNodeName},
          $self->{ltmPoolMemberMonitorState},
          $self->{ltmPoolMbrStatusAvailState},
          $self->{ltmPoolMbrStatusDetailReason});
    }
  }
}

sub dump { 
  my $self = shift;
  printf "[POOL_%s_MEMBER]\n", $self->{ltmPoolMemberPoolName};
  foreach(qw(ltmPoolMemberPoolName ltmPoolMemberNodeName
      ltmPoolMemberAddr ltmPoolMemberPort
      ltmPoolMemberMonitorRule
      ltmPoolMemberMonitorState ltmPoolMemberMonitorStatus
      ltmPoolMbrStatusAvailState  ltmPoolMbrStatusEnabledState ltmPoolMbrStatusDetailReason)) {
    printf "%s: %s\n", $_, $self->{$_};
  }
}


package NWC::F5::F5BIGIP::Component::LTMSubsystem4;
our @ISA = qw(NWC::F5::F5BIGIP::Component::LTMSubsystem);

use strict;
use constant { OK => 0, WARNING => 1, CRITICAL => 2, UNKNOWN => 3 };

sub new {
  my $class = shift;
  my %params = @_;
  my $self = {
    pools => [],
    poolmembers => [],
    blacklisted => 0,
    info => undef,
    extendedinfo => undef,
  };
  bless $self, $class;
  $self->init(%params);
  return $self;
}

sub init {
  my $self = shift;
  my %params = @_;
  foreach ($self->get_snmp_table_objects(
      'LOAD-BAL-SYSTEM-MIB', 'poolTable')) {
    if ($self->filter_name($_->{poolName})) {
      push(@{$self->{pools}},
          NWC::F5::F5BIGIP::Component::LTMSubsystem4::LTMPool->new(%{$_}));
    }
  }
  foreach ($self->get_snmp_table_objects(
      'LOAD-BAL-SYSTEM-MIB', 'poolMemberTable')) {
    if ($self->filter_name($_->{poolMemberPoolName})) {
      push(@{$self->{poolmembers}},
          NWC::F5::F5BIGIP::Component::LTMSubsystem4::LTMPoolMember->new(%{$_}));
    }
  }
  $self->assign_members_to_pools();
}

sub assign_members_to_pools {
  my $self = shift;
  foreach my $pool (@{$self->{pools}}) {
    foreach my $poolmember (@{$self->{poolmembers}}) {
      if ($poolmember->{poolMemberPoolName} eq $pool->{poolName}) {
        push(@{$pool->{members}}, $poolmember);
      }
    }
    if (! defined $pool->{poolMemberQty}) {
      $pool->{poolMemberQty} = scalar(@{$pool->{members}}) ;
      $self->debug("calculate poolMemberQty");
    }
    $pool->{completeness} = $pool->{poolMemberQty} ?
        $pool->{poolActiveMemberCount} / $pool->{poolMemberQty} * 100
        : 0;
  }
}


package NWC::F5::F5BIGIP::Component::LTMSubsystem4::LTMPool;
our @ISA = qw(NWC::F5::F5BIGIP::Component::LTMSubsystem4);

use strict;
use constant { OK => 0, WARNING => 1, CRITICAL => 2, UNKNOWN => 3 };

sub new {
  my $class = shift;
  my %params = @_;
  my $self = {
    blacklisted => 0,
    info => undef,
    extendedinfo => undef,
    members => [],
  };
  foreach(qw(poolName poolLBMode poolMinActiveMembers 
      poolActiveMemberCount poolMemberQty)) {
    $self->{$_} = $params{$_};
  }
  $self->{name} = $self->{poolName};
  bless $self, $class;
  return $self;
}

sub check {
  my $self = shift;
  my %params = @_;
  $self->blacklist('po', $self->{poolName});
  my $info = sprintf 'pool %s active members: %d of %d', $self->{poolName},
      $self->{poolActiveMemberCount},
      $self->{poolMemberQty};
  $self->add_info($info);
  if ($self->{poolActiveMemberCount} == 1) {
    # only one member left = no more redundancy!!
    $self->set_thresholds(warning => "100:", critical => "51:");
  } else {
    $self->set_thresholds(warning => "51:", critical => "26:");
  }
  $self->add_message($self->check_thresholds($self->{completeness}), $info);
  if ($self->{poolMinActiveMembers} > 0 &&
      $self->{poolActiveMemberCount} < $self->{poolMinActiveMembers}) {
    $self->add_nagios(
        defined $params{mitigation} ? $params{mitigation} : 2,
        sprintf("pool %s has not enough active members (%d, min is %d)", 
            $self->{poolName}, $self->{poolActiveMemberCount}, 
            $self->{poolMinActiveMembers})
    );
  }
  $self->add_perfdata(
      label => sprintf('pool_%s_completeness', $self->{poolName}),
      value => $self->{completeness},
      uom => '%',
      warning => $self->{warning},
      critical => $self->{critical},
  );
}

sub dump { 
  my $self = shift;
  printf "[POOL_%s]\n", $self->{poolName};
  foreach(qw(poolName poolLBMode poolMinActiveMembers 
      poolActiveMemberCount poolMemberQty)) {
    printf "%s: %s\n", $_, $self->{$_};
  }
  foreach my $member (@{$self->{members}}) {
    $member->dump();
  }
  printf "info: %s\n", $self->{info};
  printf "\n";
}


package NWC::F5::F5BIGIP::Component::LTMSubsystem4::LTMPoolMember;
our @ISA = qw(NWC::F5::F5BIGIP::Component::LTMSubsystem4);

use strict;
use constant { OK => 0, WARNING => 1, CRITICAL => 2, UNKNOWN => 3 };

sub new {
  my $class = shift;
  my %params = @_;
  my $self = {
    blacklisted => 0,
    info => undef,
    extendedinfo => undef,
  };
  foreach(qw(poolMemberPoolName poolMemberStatus)) {
    $self->{$_} = $params{$_};
  }
  bless $self, $class;
  return $self;
}

sub dump { 
  my $self = shift;
  printf "[POOL_%s_MEMBER]\n", $self->{poolMemberPoolName};
  foreach(qw(poolMemberPoolName poolMemberStatus)) {
    printf "%s: %s\n", $_, $self->{$_};
  }
}



package NWC::F5::F5BIGIP::Component::MemSubsystem;
our @ISA = qw(NWC::F5::F5BIGIP::Component::EnvironmentalSubsystem);

use strict;
use constant { OK => 0, WARNING => 1, CRITICAL => 2, UNKNOWN => 3 };

sub new {
  my $class = shift;
  my %params = @_;
  my $self = {
    mems => [],
    blacklisted => 0,
    info => undef,
    extendedinfo => undef,
  };
  bless $self, $class;
  $self->overall_init(%params);
  return $self;
}

sub overall_init {
  my $self = shift;
  $self->{sysStatMemoryTotal} = $self->get_snmp_object(
      'F5-BIGIP-SYSTEM-MIB', 'sysStatMemoryTotal');
  $self->{sysStatMemoryUsed} = $self->get_snmp_object(
      'F5-BIGIP-SYSTEM-MIB', 'sysStatMemoryUsed');
  $self->{sysHostMemoryTotal} = $self->get_snmp_object(
      'F5-BIGIP-SYSTEM-MIB', 'sysHostMemoryTotal');
  $self->{sysHostMemoryUsed} = $self->get_snmp_object(
      'F5-BIGIP-SYSTEM-MIB', 'sysHostMemoryUsed');
  $self->{stat_mem_usage} = ($self->{sysStatMemoryUsed} / $self->{sysStatMemoryTotal}) * 100;
  $self->{host_mem_usage} = ($self->{sysHostMemoryUsed} / $self->{sysHostMemoryTotal}) * 100;
}

sub check {
  my $self = shift;
  my %params = @_;
  my $errorfound = 0;
  $self->add_info('checking memory');
  $self->blacklist('mm', '');
  my $info = sprintf 'tmm memory usage is %.2f%%',
      $self->{stat_mem_usage};
  $self->add_info($info);
  $self->set_thresholds(warning => 80, critical => 90);
  $self->add_message($self->check_thresholds($self->{stat_mem_usage}), $info);
  $self->add_perfdata(
      label => 'tmm_usage',
      value => $self->{stat_mem_usage},
      uom => '%',
      warning => $self->{warning},
      critical => $self->{critical},
  );
  $info = sprintf 'host memory usage is %.2f%%',
      $self->{host_mem_usage};
  $self->add_info($info);
  $self->set_thresholds(warning => 80, critical => 90);
  $self->add_message(OK, $info);
  $self->add_perfdata(
      label => 'host_usage',
      value => $self->{host_mem_usage},
      uom => '%',
      warning => $self->{warning},
      critical => $self->{critical},
  );
  return;
}

sub dump {
  my $self = shift;
  foreach (@{$self->{mems}}) {
    $_->dump();
  }
}


package NWC::F5::F5BIGIP::Component::PowersupplySubsystem;
our @ISA = qw(NWC::F5::F5BIGIP::Component::EnvironmentalSubsystem);

use strict;
use constant { OK => 0, WARNING => 1, CRITICAL => 2, UNKNOWN => 3 };

sub new {
  my $class = shift;
  my %params = @_;
  my $self = {
    powersupplies => [],
    blacklisted => 0,
    info => undef,
    extendedinfo => undef,
  };
  bless $self, $class;
  $self->init(%params);
  return $self;
}

sub init {
  my $self = shift;
  foreach ($self->get_snmp_table_objects(
      'F5-BIGIP-SYSTEM-MIB', 'sysChassisPowerSupplyTable')) {
    push(@{$self->{powersupplies}},
        NWC::F5::F5BIGIP::Component::PowersupplySubsystem::Powersupply->new(%{$_}));
  }
}

sub check {
  my $self = shift;
  my $errorfound = 0;
  $self->add_info('checking powersupplies');
  $self->blacklist('pp', '');
  if (scalar (@{$self->{powersupplies}}) == 0) {
  } else {
    foreach (@{$self->{powersupplies}}) {
      $_->check();
    }
  }
}


sub dump {
  my $self = shift;
  foreach (@{$self->{powersupplies}}) {
    $_->dump();
  }
}


package NWC::F5::F5BIGIP::Component::PowersupplySubsystem::Powersupply;
our @ISA = qw(NWC::F5::F5BIGIP::Component::PowersupplySubsystem);

use strict;
use constant { OK => 0, WARNING => 1, CRITICAL => 2, UNKNOWN => 3 };

sub new {
  my $class = shift;
  my %params = @_;
  my $self = {
    blacklisted => 0,
    info => undef,
    extendedinfo => undef,
  };
  foreach(qw(sysChassisPowerSupplyIndex sysChassisPowerSupplyStatus)) {
    $self->{$_} = $params{$_};
  }
  bless $self, $class;
  return $self;
}

sub check {
  my $self = shift;
  $self->blacklist('p', $self->{sysChassisPowerSupplyIndex});
  $self->add_info(sprintf 'chassis powersupply %d is %s',
      $self->{sysChassisPowerSupplyIndex},
      $self->{sysChassisPowerSupplyStatus});
  if ($self->{sysChassisPowerSupplyStatus} eq 'notpresent') {
  } else {
    if ($self->{sysChassisPowerSupplyStatus} ne 'good') {
      $self->add_message(CRITICAL, $self->{info});
    }
  }
}

sub dump {
  my $self = shift;
  printf "[PS_%s]\n", $self->{sysChassisPowerSupplyIndex};
  foreach(qw(sysChassisPowerSupplyIndex sysChassisPowerSupplyStatus)) {
    printf "%s: %s\n", $_, $self->{$_};
  }
  printf "info: %s\n", $self->{info};
  printf "\n";
}

package NWC::F5::F5BIGIP::Component::TemperatureSubsystem;
our @ISA = qw(NWC::F5::F5BIGIP::Component::EnvironmentalSubsystem);

use strict;
use constant { OK => 0, WARNING => 1, CRITICAL => 2, UNKNOWN => 3 };

sub new {
  my $class = shift;
  my %params = @_;
  my $self = {
    temperatures => [],
    blacklisted => 0,
    info => undef,
    extendedinfo => undef,
  };
  bless $self, $class;
  $self->init(%params);
  return $self;
}

sub init {
  my $self = shift;
  foreach ($self->get_snmp_table_objects(
      'F5-BIGIP-SYSTEM-MIB', 'sysChassisTempTable')) {
    push(@{$self->{temperatures}},
        NWC::F5::F5BIGIP::Component::TemperatureSubsystem::Temperature->new(%{$_}));
  }
}

sub check {
  my $self = shift;
  my $errorfound = 0;
  $self->add_info('checking temperatures');
  $self->blacklist('tt', '');
  if (scalar (@{$self->{temperatures}}) == 0) {
  } else {
    foreach (@{$self->{temperatures}}) {
      $_->check();
    }
  }
}


sub dump {
  my $self = shift;
  foreach (@{$self->{temperatures}}) {
    $_->dump();
  }
}


package NWC::F5::F5BIGIP::Component::TemperatureSubsystem::Temperature;
our @ISA = qw(NWC::F5::F5BIGIP::Component::TemperatureSubsystem);

use strict;
use constant { OK => 0, WARNING => 1, CRITICAL => 2, UNKNOWN => 3 };

sub new {
  my $class = shift;
  my %params = @_;
  my $self = {
    blacklisted => 0,
    info => undef,
    extendedinfo => undef,
  };
  foreach(qw(sysChassisTempIndex sysChassisTempTemperature)) {
    $self->{$_} = $params{$_};
  }
  bless $self, $class;
  return $self;
}

sub check {
  my $self = shift;
  $self->blacklist('t', $self->{sysChassisTempIndex});
  $self->add_info(sprintf 'chassis temperature %d is %sC',
      $self->{sysChassisTempIndex},
      $self->{sysChassisTempTemperature});
  $self->add_perfdata(
      label => sprintf('temp_%s', $self->{sysChassisTempIndex}),
      value => $self->{sysChassisTempTemperature},
      warning => undef,
      critical => undef,
  );
}

sub dump {
  my $self = shift;
  printf "[TEMP_%s]\n", $self->{sysChassisTempIndex};
  foreach(qw(sysChassisTempIndex sysChassisTempTemperature)) {
    printf "%s: %s\n", $_, $self->{$_};
  }
  printf "info: %s\n", $self->{info};
  printf "\n";
}

package NWC::F5::F5BIGIP::Component::CpuSubsystem;
our @ISA = qw(NWC::F5::F5BIGIP::Component::EnvironmentalSubsystem);

use strict;
use constant { OK => 0, WARNING => 1, CRITICAL => 2, UNKNOWN => 3 };

sub new {
  my $class = shift;
  my %params = @_;
  my $self = {
    cpus => [],
    blacklisted => 0,
    info => undef,
    extendedinfo => undef,
  };
  bless $self, $class;
  if ($self->mode =~ /load/) {
    $self->overall_init(%params);
  } else {
    $self->init(%params);
  }
  return $self;
}

sub overall_init {
  my $self = shift;
  $self->{sysStatTmTotalCycles} = $self->get_snmp_object(
      'F5-BIGIP-SYSTEM-MIB', 'sysStatTmTotalCycles');
  $self->{sysStatTmIdleCycles} = $self->get_snmp_object(
      'F5-BIGIP-SYSTEM-MIB', 'sysStatTmIdleCycles');
  $self->{sysStatTmSleepCycles} = $self->get_snmp_object(
      'F5-BIGIP-SYSTEM-MIB', 'sysStatTmSleepCycles');
  $self->valdiff({name => 'cpu'}, qw(sysStatTmTotalCycles sysStatTmIdleCycles sysStatTmSleepCycles ));
  my $delta_used_cycles = $self->{delta_sysStatTmTotalCycles} -
     ($self->{delta_sysStatTmIdleCycles} + $self->{delta_sysStatTmSleepCycles});
  $self->{cpu_usage} =  $self->{delta_sysStatTmTotalCycles} ?
      (($delta_used_cycles / $self->{delta_sysStatTmTotalCycles}) * 100) : 0;
}

sub init {
  my $self = shift;
  foreach ($self->get_snmp_table_objects(
      'F5-BIGIP-SYSTEM-MIB', 'sysCpuTable')) {
    push(@{$self->{cpus}},
        NWC::F5::F5BIGIP::Component::CpuSubsystem::Cpu->new(%{$_}));
  }
}

sub check {
  my $self = shift;
  my %params = @_;
  my $errorfound = 0;
  $self->add_info('checking cpus');
  $self->blacklist('cc', '');
  if ($self->mode =~ /load/) {
    my $info = sprintf 'tmm cpu usage is %.2f%%',
        $self->{cpu_usage};
    $self->add_info($info);
    $self->set_thresholds(warning => 80, critical => 90);
    $self->add_message($self->check_thresholds($self->{cpu_usage}), $info);
    $self->add_perfdata(
        label => 'cpu_tmm_usage',
        value => $self->{cpu_usage},
        uom => '%',
        warning => $self->{warning},
        critical => $self->{critical},
    );
    return;
  }
  if (scalar (@{$self->{cpus}}) == 0) {
  } else {
    foreach (@{$self->{cpus}}) {
      $_->check();
    }
  }
}


sub dump {
  my $self = shift;
  foreach (@{$self->{cpus}}) {
    $_->dump();
  }
}


package NWC::F5::F5BIGIP::Component::CpuSubsystem::Cpu;
our @ISA = qw(NWC::F5::F5BIGIP::Component::CpuSubsystem);

use strict;
use constant { OK => 0, WARNING => 1, CRITICAL => 2, UNKNOWN => 3 };

sub new {
  my $class = shift;
  my %params = @_;
  my $self = {
    blacklisted => 0,
    info => undef,
    extendedinfo => undef,
  };
  foreach(qw(sysCpuIndex sysCpuTemperature sysCpuFanSpeed
      sysCpuName sysCpuSlot)) {
    $self->{$_} = $params{$_};
  }
  bless $self, $class;
  return $self;
}

sub check {
  my $self = shift;
  $self->blacklist('c', $self->{sysCpuIndex});
  $self->add_info(sprintf 'cpu %d has %dC (%drpm)',
      $self->{sysCpuIndex},
      $self->{sysCpuTemperature},
      $self->{sysCpuFanSpeed});
  $self->add_perfdata(
      label => sprintf('temp_c%s', $self->{sysCpuIndex}),
      value => $self->{sysCpuTemperature},
      warning => undef,
      critical => undef,
  );
  $self->add_perfdata(
      label => sprintf('fan_c%s', $self->{sysCpuIndex}),
      value => $self->{sysCpuFanSpeed},
      warning => undef,
      critical => undef,
  );
}

sub dump {
  my $self = shift;
  printf "[CPU_%s]\n", $self->{sysCpuIndex};
  foreach(qw(sysCpuIndex sysCpuTemperature sysCpuFanSpeed
      sysCpuName sysCpuSlot)) {
    printf "%s: %s\n", $_, $self->{$_};
  }
  printf "info: %s\n", $self->{info};
  printf "\n";
}

package NWC::F5::F5BIGIP::Component::FanSubsystem;
our @ISA = qw(NWC::F5::F5BIGIP::Component::EnvironmentalSubsystem);

use strict;
use constant { OK => 0, WARNING => 1, CRITICAL => 2, UNKNOWN => 3 };

sub new {
  my $class = shift;
  my %params = @_;
  my $self = {
    fans => [],
    blacklisted => 0,
    info => undef,
    extendedinfo => undef,
  };
  bless $self, $class;
  $self->init(%params);
  return $self;
}

sub init {
  my $self = shift;
  foreach ($self->get_snmp_table_objects(
      'F5-BIGIP-SYSTEM-MIB', 'sysChassisFanTable')) {
    push(@{$self->{fans}},
        NWC::F5::F5BIGIP::Component::FanSubsystem::Fan->new(%{$_}));
  }
}

sub check {
  my $self = shift;
  my $errorfound = 0;
  $self->add_info('checking fans');
  $self->blacklist('ff', '');
  if (scalar (@{$self->{fans}}) == 0) {
  } else {
    foreach (@{$self->{fans}}) {
      $_->check();
    }
  }
}


sub dump {
  my $self = shift;
  foreach (@{$self->{fans}}) {
    $_->dump();
  }
}


package NWC::F5::F5BIGIP::Component::FanSubsystem::Fan;
our @ISA = qw(NWC::F5::F5BIGIP::Component::FanSubsystem);

use strict;
use constant { OK => 0, WARNING => 1, CRITICAL => 2, UNKNOWN => 3 };

sub new {
  my $class = shift;
  my %params = @_;
  my $self = {
    blacklisted => 0,
    info => undef,
    extendedinfo => undef,
  };
  foreach(qw(sysChassisFanIndex sysChassisFanStatus
      sysChassisFanSpeed)) {
    $self->{$_} = $params{$_};
  }
  bless $self, $class;
  return $self;
}

sub check {
  my $self = shift;
  $self->blacklist('f', $self->{sysChassisFanIndex});
  $self->add_info(sprintf 'chassis fan %d is %s (%drpm)',
      $self->{sysChassisFanIndex},
      $self->{sysChassisFanStatus},
      $self->{sysChassisFanSpeed});
  if ($self->{sysChassisFanStatus} eq 'notpresent') {
  } else {
    if ($self->{sysChassisFanStatus} ne 'good') {
      $self->add_message(CRITICAL, $self->{info});
    }
    $self->add_perfdata(
        label => sprintf('fan_%s', $self->{sysChassisFanIndex}),
        value => $self->{sysChassisFanSpeed},
        warning => undef,
        critical => undef,
    );
  }
}

sub dump {
  my $self = shift;
  printf "[FAN_%s]\n", $self->{sysChassisFanIndex};
  foreach(qw(sysChassisFanIndex sysChassisFanStatus
      sysChassisFanSpeed)) {
    printf "%s: %s\n", $_, $self->{$_};
  }
  printf "info: %s\n", $self->{info};
  printf "\n";
}

package NWC::F5::F5BIGIP::Component::EnvironmentalSubsystem;
our @ISA = qw(NWC::F5::F5BIGIP);

use strict;
use constant { OK => 0, WARNING => 1, CRITICAL => 2, UNKNOWN => 3 };

sub new {
  my $class = shift;
  my %params = @_;
  my $self = {
    runtime => $params{runtime},
    rawdata => $params{rawdata},
    method => $params{method},
    condition => $params{condition},
    status => $params{status},
    cpu_subsystem => undef,
    fan_subsystem => undef,
    temperature_subsystem => undef,
    powersupply_subsystem => undef,
    blacklisted => 0,
    info => undef,
    extendedinfo => undef,
  };
  bless $self, $class;
  $self->init(%params);
  return $self;
}

sub init {
  my $self = shift;
  my %params = @_;
  $self->{cpu_subsystem} =
      NWC::F5::F5BIGIP::Component::CpuSubsystem->new(%params);
  $self->{fan_subsystem} =
      NWC::F5::F5BIGIP::Component::FanSubsystem->new(%params);
  $self->{temperature_subsystem} =
      NWC::F5::F5BIGIP::Component::TemperatureSubsystem->new(%params);
  $self->{powersupply_subsystem} = 
      NWC::F5::F5BIGIP::Component::PowersupplySubsystem->new(%params);
}

sub check {
  my $self = shift;
  my $errorfound = 0;
  $self->{cpu_subsystem}->check();
  $self->{fan_subsystem}->check();
  $self->{temperature_subsystem}->check();
  $self->{powersupply_subsystem}->check();
  if (! $self->check_messages()) {
    $self->add_message(OK, "environmental hardware working fine");
  }
}

sub dump {
  my $self = shift;
  $self->{cpu_subsystem}->dump();
  $self->{fan_subsystem}->dump();
  $self->{temperature_subsystem}->dump();
  $self->{powersupply_subsystem}->dump();
}


package NWC::F5::F5BIGIP;

use strict;

use constant { OK => 0, WARNING => 1, CRITICAL => 2, UNKNOWN => 3 };

our @ISA = qw(NWC::F5);

sub init {
  my $self = shift;
  my %params = @_;
  $self->{components} = {
      powersupply_subsystem => undef,
      fan_subsystem => undef,
      temperature_subsystem => undef,
      cpu_subsystem => undef,
      memory_subsystem => undef,
      disk_subsystem => undef,
      environmental_subsystem => undef,
      ltm_subsystem => undef,
  };
  # gets 11.* and 9.*
  $self->{productversion} = $self->get_snmp_object('F5-BIGIP-SYSTEM-MIB', 'sysProductVersion');
  if (! defined $self->{productversion} ||
      $self->{productversion} !~ /^((9)|(10)|(11))/) {
    $self->{productversion} = "4";
  }
  $params{productversion} = $self->{productversion};
  if (! $self->check_messages()) {
    if ($self->mode =~ /device::hardware::health/) {
      $self->analyze_environmental_subsystem();
      #$self->auto_blacklist();
      $self->check_environmental_subsystem();
    } elsif ($self->mode =~ /device::hardware::load/) {
      $self->analyze_cpu_subsystem();
      #$self->auto_blacklist();
      $self->check_cpu_subsystem();
    } elsif ($self->mode =~ /device::hardware::memory/) {
      $self->analyze_mem_subsystem();
      #$self->auto_blacklist();
      $self->check_mem_subsystem();
    } elsif ($self->mode =~ /device::lb/) {
      $self->analyze_ltm_subsystem(%params);
      $self->check_ltm_subsystem();
    } elsif ($self->mode =~ /device::shinken::interface/) {
      $self->analyze_interface_subsystem();
      $self->shinken_interface_subsystem();
    }
  }
}

sub analyze_environmental_subsystem {
  my $self = shift;
  $self->{components}->{environmental_subsystem} =
      NWC::F5::F5BIGIP::Component::EnvironmentalSubsystem->new();
}

sub analyze_cpu_subsystem {
  my $self = shift;
  $self->{components}->{cpu_subsystem} =
      NWC::F5::F5BIGIP::Component::CpuSubsystem->new();
}

sub analyze_mem_subsystem {
  my $self = shift;
  $self->{components}->{mem_subsystem} =
      NWC::F5::F5BIGIP::Component::MemSubsystem->new();
}

sub analyze_ltm_subsystem {
  my $self = shift;
  my %params = @_;
  $self->{components}->{ltm_subsystem} =
      NWC::F5::F5BIGIP::Component::LTMSubsystem->new(%params);
}

package NWC::F5;

use strict;

use constant { OK => 0, WARNING => 1, CRITICAL => 2, UNKNOWN => 3 };

our @ISA = qw(NWC::Device);

use constant trees => (
    '1.3.6.1.4.1.3375.1.2.1.1.1', # F5-3DNS-MIB
    '1.3.6.1.4.1.3375', # F5-BIGIP-COMMON-MIB
    '1.3.6.1.4.1.3375.2.2', # F5-BIGIP-LOCAL-MIB
    '1.3.6.1.4.1.3375.2.1', # F5-BIGIP-SYSTEM-MIB
    '1.3.6.1.4.1.3375.1.1.1.1', # LOAD-BAL-SYSTEM-MIB
    '1.3.6.1.4.1.2021', # UCD-SNMP-MIB
);

sub init {
  my $self = shift;
  my %params = @_;
  $self->SUPER::init(%params);
  if ($self->{productname} =~ /Linux.*((el6.f5.x86_64)|(el5.1.0.f5app)) .*/i) {
    bless $self, 'NWC::F5::F5BIGIP';
    $self->debug('using NWC::F5::F5BIGIP');
  }
  $self->init(%params);
}

package NWC::CheckPoint::Firewall1::Component::MngmtSubsystem;
our @ISA = qw(NWC::CheckPoint::Firewall1);

use strict;
use constant { OK => 0, WARNING => 1, CRITICAL => 2, UNKNOWN => 3 };

sub new {
  my $class = shift;
  my %params = @_;
  my $self = {
    cpus => [],
    blacklisted => 0,
    info => undef,
    extendedinfo => undef,
  };
  bless $self, $class;
  $self->init(%params);
  return $self;
}

sub init {
  my $self = shift;
  my %params = @_;
  if ($self->mode =~ /device::mngmt::status/) {
    $self->{mgStatShortDescr} = $self->get_snmp_object('CHECKPOINT-MIB', 'mgStatShortDescr');
    $self->{mgStatLongDescr} = $self->get_snmp_object('CHECKPOINT-MIB', 'mgStatLongDescr');
  }
}

sub check {
  my $self = shift;
  my %params = @_;
  my $errorfound = 0;
  $self->add_info('checking mngmt');
  if ($self->mode =~ /device::mngmt::status/) {
    if ($self->{mgStatShortDescr} ne 'OK') {
      $self->add_message(CRITICAL,
          sprintf 'status of management is %s', $self->{mgStatLongDescr});
    } else {
      $self->add_message(OK,
          sprintf 'status of management is %s', $self->{mgStatLongDescr});
    }
  }
}

sub dump {
  my $self = shift;
  printf "[MNGMT]\n";
}

package NWC::CheckPoint::Firewall1::Component::SvnSubsystem;
our @ISA = qw(NWC::CheckPoint::Firewall1);

use strict;
use constant { OK => 0, WARNING => 1, CRITICAL => 2, UNKNOWN => 3 };

sub new {
  my $class = shift;
  my %params = @_;
  my $self = {
    cpus => [],
    blacklisted => 0,
    info => undef,
    extendedinfo => undef,
  };
  bless $self, $class;
  $self->init(%params);
  return $self;
}

sub init {
  my $self = shift;
  my %params = @_;
  if ($self->mode =~ /device::svn::status/) {
    $self->{svnStatShortDescr} = $self->get_snmp_object('CHECKPOINT-MIB', 'svnStatShortDescr');
    $self->{svnStatLongDescr} = $self->get_snmp_object('CHECKPOINT-MIB', 'svnStatLongDescr');
  }
}

sub check {
  my $self = shift;
  my %params = @_;
  my $errorfound = 0;
  $self->add_info('checking svn');
  if ($self->mode =~ /device::svn::status/) {
    if ($self->{svnStatShortDescr} ne 'OK') {
      $self->add_message(CRITICAL,
          sprintf 'status of svn is %s', $self->{svnStatLongDescr});
    } else {
      $self->add_message(OK,
          sprintf 'status of svn is %s', $self->{svnStatLongDescr});
    }
  }
}

sub dump {
  my $self = shift;
  printf "[SVN]\n";
}

package NWC::CheckPoint::Firewall1::Component::FwSubsystem;
our @ISA = qw(NWC::CheckPoint::Firewall1);

use strict;
use constant { OK => 0, WARNING => 1, CRITICAL => 2, UNKNOWN => 3 };

sub new {
  my $class = shift;
  my %params = @_;
  my $self = {
    cpus => [],
    blacklisted => 0,
    info => undef,
    extendedinfo => undef,
  };
  bless $self, $class;
  $self->init(%params);
  return $self;
}

sub init {
  my $self = shift;
  my %params = @_;
  $self->{fwModuleState} = $self->get_snmp_object('CHECKPOINT-MIB', 'fwModuleState');
  $self->{fwPolicyName} = $self->get_snmp_object('CHECKPOINT-MIB', 'fwPolicyName');
  if ($self->mode =~ /device::fw::policy::installed/) {
  } elsif ($self->mode =~ /device::fw::policy::connections/) {
    $self->{fwNumConn} = $self->get_snmp_object('CHECKPOINT-MIB', 'fwNumConn');
  }
}

sub check {
  my $self = shift;
  my %params = @_;
  my $errorfound = 0;
  $self->add_info('checking fw module');
  if ($self->{fwModuleState} ne 'Installed') {
    $self->add_message(CRITICAL,
        sprintf 'fw module is %s', $self->{fwPolicyName});
  } elsif ($self->mode =~ /device::fw::policy::installed/) {
    if ($self->{fwPolicyName} eq $self->opts->name()) {
      $self->add_message(OK,
        sprintf 'fw policy is %s', $self->{fwPolicyName});
    } else {
      $self->add_message(CRITICAL,
          sprintf 'fw policy is %s, expected %s',
              $self->{fwPolicyName}, $self->opts->name());
    }
  } elsif ($self->mode =~ /device::fw::policy::connections/) {
    $self->set_thresholds(warning => 20000, critical => 23000);
    $self->add_message($self->check_thresholds($self->{fwNumConn}),
        sprintf 'policy %s has %s open connections',
            $self->{fwPolicyName}, $self->{fwNumConn});
    $self->add_perfdata(
        label => 'fw_policy_numconn',
        value => $self->{fwNumConn},
    );
  }
}

sub dump {
  my $self = shift;
  printf "[FW]\n";
}

package NWC::CheckPoint::Firewall1::Component::HaSubsystem;
our @ISA = qw(NWC::CheckPoint::Firewall1);

use strict;
use constant { OK => 0, WARNING => 1, CRITICAL => 2, UNKNOWN => 3 };

sub new {
  my $class = shift;
  my %params = @_;
  my $self = {
    cpus => [],
    blacklisted => 0,
    info => undef,
    extendedinfo => undef,
  };
  bless $self, $class;
  $self->init(%params);
  return $self;
}

sub init {
  my $self = shift;
  my %params = @_;
  if ($self->mode =~ /device::ha::role/) {
    $self->{haStarted} = $self->get_snmp_object('CHECKPOINT-MIB', 'haStarted');
    $self->{haState} = $self->get_snmp_object('CHECKPOINT-MIB', 'haState');
    $self->{haStatShort} = $self->get_snmp_object('CHECKPOINT-MIB', 'haStatShort');
    if (! $self->opts->role()) {
      $self->opts->override_opt('role', 'active');
    }
  }
}

sub check {
  my $self = shift;
  my %params = @_;
  my $errorfound = 0;
  $self->add_info('checking ha');
  my $info = sprintf 'ha %sstarted, role is %s, status is %s', 
      $self->{haStarted} eq 'yes' ? '' : 'not ', 
      $self->{haState}, $self->{haStatShort};
  $self->add_info($info);
  if ($self->{haStarted} eq 'yes') {
    if ($self->{haStatShort} ne 'OK') {
      $self->add_message(
          defined $self->opts->mitigation() ? $self->opts->mitigation() : 2,
          $info);
    } elsif ($self->{haState} ne $self->opts->role()) {
      $self->add_message(
          defined $self->opts->mitigation() ? $self->opts->mitigation() : 1,
          $info);
      $self->add_message(
          defined $self->opts->mitigation() ? $self->opts->mitigation() : 1,
          sprintf "expected role %s", $self->opts->role())
    } else {
      $self->add_message(OK, $info);
    }
  } else {
    $self->add_message(
        defined $self->opts->mitigation() ? $self->opts->mitigation() : 1,
        'ha was not started');
  }

  #$self->add_message($self->check_thresholds($self->{procUsage}), $info);
}

sub dump {
  my $self = shift;
  printf "[CPU]\n";
  foreach (qw(procUsage procQueue)) {
    printf "%s: %s\n", $_, $self->{$_} if defined $self->{$_};
  }
  printf "info: %s\n", $self->{info};
  printf "\n";
}

package NWC::CheckPoint::Firewall1::Component::CpuSubsystem;
our @ISA = qw(NWC::CheckPoint::Firewall1);

use strict;
use constant { OK => 0, WARNING => 1, CRITICAL => 2, UNKNOWN => 3 };

sub new {
  my $class = shift;
  my %params = @_;
  my $self = {
    cpus => [],
    blacklisted => 0,
    info => undef,
    extendedinfo => undef,
  };
  bless $self, $class;
  $self->init(%params);
  return $self;
}

sub init {
  my $self = shift;
  my %params = @_;
  $self->{procUsage} = $self->get_snmp_object('CHECKPOINT-MIB', 'procUsage');
  $self->{procQueue} = $self->valid_response('CHECKPOINT-MIB', 'procQueue');
}

sub check {
  my $self = shift;
  my $errorfound = 0;
  $self->add_info('checking cpus');
  my $info = sprintf 'cpu usage is %.2f%%', $self->{procUsage};
  $self->add_info($info);
  $self->set_thresholds(warning => 80, critical => 90);
  $self->add_message($self->check_thresholds($self->{procUsage}), $info);
  $self->add_perfdata(
      label => 'cpu_usage',
      value => $self->{procUsage},
      uom => '%',
      warning => $self->{warning},
      critical => $self->{critical},
  );
  if (defined $self->{procQueue}) {
    $self->add_perfdata(
        label => 'cpu_queue_length',
        value => $self->{procQueue},
    );
  }
}

sub dump {
  my $self = shift;
  printf "[CPU]\n";
  foreach (qw(procUsage procQueue)) {
    printf "%s: %s\n", $_, $self->{$_} if defined $self->{$_};
  }
  printf "info: %s\n", $self->{info};
  printf "\n";
}

package NWC::CheckPoint::Firewall1::Component::MemSubsystem;
our @ISA = qw(NWC::CheckPoint::Firewall1);

use strict;
use constant { OK => 0, WARNING => 1, CRITICAL => 2, UNKNOWN => 3 };

sub new {
  my $class = shift;
  my %params = @_;
  my $self = {
    blacklisted => 0,
    info => undef,
    extendedinfo => undef,
  };
  bless $self, $class;
  $self->init(%params);
  return $self;
}

sub init {
  my $self = shift;
  my %params = @_;
  my $type = 0;
  $self->{total_memory} = $self->get_snmp_object(
      'CHECKPOINT-MIB', 'memTotalReal64');
  $self->{free_memory} = $self->get_snmp_object(
      'CHECKPOINT-MIB', 'memFreeReal64');
  $self->{memory_usage} = $self->{free_memory} ? 
      ($self->{free_memory} / $self->{total_memory} * 100) : 100;
}

sub check {
  my $self = shift;
  my $info = sprintf 'memory usage is %.2f%%',
      $self->{memory_usage};
  $self->add_info($info);
  $self->set_thresholds(warning => 80, critical => 90);
  $self->add_message($self->check_thresholds($self->{memory_usage}), $info);
  $self->add_perfdata(
      label => 'memory_usage',
      value => $self->{memory_usage},
      uom => '%',
      warning => $self->{warning},
      critical => $self->{critical},
  );
}

sub dump {
  my $self = shift;
  printf "[MEM]\n";
  foreach (qw(memory_usage total_memory free_memory)) {
    if (exists $self->{$_}) {
      printf "%s: %s\n", $_, $self->{$_};
    }
  }
  printf "info: %s\n", $self->{info};
  printf "\n";
}

package NWC::CheckPoint::Firewall1;

use strict;

use constant { OK => 0, WARNING => 1, CRITICAL => 2, UNKNOWN => 3 };

our @ISA = qw(NWC::CheckPoint);

sub init {
  my $self = shift;
  $self->{components} = {
      powersupply_subsystem => undef,
      fan_subsystem => undef,
      temperature_subsystem => undef,
      cpu_subsystem => undef,
  };
  $self->{serial} = 'unknown';
  $self->{product} = 'unknown';
  $self->{romversion} = 'unknown';
  # serial is 1.3.6.1.2.1.47.1.1.1.1.11.1
  #$self->collect();
  if (! $self->check_messages()) {
    ##$self->set_serial();
    if ($self->mode =~ /device::hardware::health/) {
      $self->analyze_environmental_subsystem();
      $self->check_environmental_subsystem();
    } elsif ($self->mode =~ /device::hardware::load/) {
      $self->analyze_cpu_subsystem();
      $self->check_cpu_subsystem();
    } elsif ($self->mode =~ /device::hardware::memory/) {
      $self->analyze_mem_subsystem();
      $self->check_mem_subsystem();
    } elsif ($self->mode =~ /device::ha::/) {
      $self->analyze_ha_subsystem();
      $self->check_ha_subsystem();
    } elsif ($self->mode =~ /device::fw::/) {
      $self->analyze_fw_subsystem();
      $self->check_fw_subsystem();
    } elsif ($self->mode =~ /device::svn::/) {
      $self->analyze_svn_subsystem();
      $self->check_svn_subsystem();
    } elsif ($self->mode =~ /device::mngmt::/) {
      $self->analyze_mngmt_subsystem();
      $self->check_svn_subsystem();
    }
  }
}

sub analyze_environmental_subsystem {
  my $self = shift;
  $self->{components}->{environmental_subsystem} =
      NWC::CheckPoint::Firewall1::Component::EnvironmentalSubsystem->new();
}

sub analyze_cpu_subsystem {
  my $self = shift;
  $self->{components}->{cpu_subsystem} =
      NWC::CheckPoint::Firewall1::Component::CpuSubsystem->new();
#printf "%s\n", Data::Dumper::Dumper($self->{components});
}

sub analyze_mem_subsystem {
  my $self = shift;
  $self->{components}->{mem_subsystem} =
      NWC::CheckPoint::Firewall1::Component::MemSubsystem->new();
}

sub analyze_ha_subsystem {
  my $self = shift;
  $self->{components}->{ha_subsystem} =
      NWC::CheckPoint::Firewall1::Component::HaSubsystem->new();
}

sub analyze_fw_subsystem {
  my $self = shift;
  $self->{components}->{fw_subsystem} =
      NWC::CheckPoint::Firewall1::Component::FwSubsystem->new();
}

sub analyze_svn_subsystem {
  my $self = shift;
  $self->{components}->{svn_subsystem} =
      NWC::CheckPoint::Firewall1::Component::SvnSubsystem->new();
}

sub analyze_mngmt_subsystem {
  my $self = shift;
  $self->{components}->{mngmt_subsystem} =
      NWC::CheckPoint::Firewall1::Component::MngmtSubsystem->new();
}

package NWC::CheckPoint;

use strict;

use constant { OK => 0, WARNING => 1, CRITICAL => 2, UNKNOWN => 3 };

our @ISA = qw(NWC::Device);

use constant trees => (
    '1.3.6.1.4.1.2620', # CHECKPOINT-MIB
);

sub init {
  my $self = shift;
  my %params = @_;
  $self->SUPER::init(%params);
  if ($self->{productname} =~ /(FireWall\-1\s)|(cpx86_64)|(Linux.*\dcp )/i) {
    bless $self, 'NWC::CheckPoint::Firewall1';
    $self->debug('using NWC::CheckPoint::Firewall1');
  }
  $self->init();
}

package NWC::SGOS::Component::MemSubsystem;
our @ISA = qw(NWC::SGOS);

use strict;
use constant { OK => 0, WARNING => 1, CRITICAL => 2, UNKNOWN => 3 };

sub new {
  my $class = shift;
  my %params = @_;
  my $self = {
    runtime => $params{runtime},
    rawdata => $params{rawdata},
    mems => [],
    blacklisted => 0,
    info => undef,
    extendedinfo => undef,
  };
  bless $self, $class;
  $self->init(%params);
  return $self;
}

sub init {
  # https://kb.bluecoat.com/index?page=content&id=KB3069
  # Memory pressure simply is the percentage of physical memory less free and reclaimable memory, of total memory. So, for example, if there is no free or reclaimable memory in the system, then memory pressure is at 100%.
  # The event logs start reporting memory pressure when it is over 75%.
  # There's two separate OIDs to obtain memory pressure value for SGOSV4 and SGOSV5;
  # SGOSV4:  memPressureValue - OIDs: 1.3.6.1.4.1.3417.2.8.2.3 (systemResourceMIB)
  # SGOSV5: sgProxyMemoryPressure - OIDs: 1.3.6.1.4.1.3417.2.11.2.3.4 (bluecoatSGProxyMIB)
  my $self = shift;
  my %params = @_;
  my $snmpwalk = $params{rawdata};
  my $ignore_redundancy = $params{ignore_redundancy};
  my $type = 0;
  foreach (qw(sgProxyMemPressure sgProxyMemAvailable sgProxyMemCacheUsage
      sgProxyMemSysUsage)) {
    $self->{$_} = $self->get_snmp_object('BLUECOAT-SG-PROXY-MIB', $_);
  }
}

sub check {
  my $self = shift;
  my $errorfound = 0;
  $self->add_info('checking memory');
  $self->blacklist('m', '');
  my $info = sprintf 'memory usage is %.2f%%',
      $self->{sgProxyMemPressure};
  $self->add_info($info);
  $self->set_thresholds(warning => 75, critical => 90);
  $self->add_message($self->check_thresholds($self->{sgProxyMemPressure}), $info);
  $self->add_perfdata(
      label => 'memory_usage',
      value => $self->{sgProxyMemPressure},
      uom => '%',
      warning => $self->{warning},
      critical => $self->{critical}
  );
}

sub dump {
  my $self = shift;
  printf "[MEMORY]\n";
  foreach (qw(sgProxyMemPressure sgProxyMemAvailable sgProxyMemCacheUsage
      sgProxyMemSysUsage)) {
    printf "%s: %s\n", $_, $self->{$_};
  }
  printf "info: %s\n", $self->{info};
  printf "\n";
}

package NWC::SGOS::Component::CpuSubsystem;
our @ISA = qw(NWC::SGOS);

use strict;
use constant { OK => 0, WARNING => 1, CRITICAL => 2, UNKNOWN => 3 };

sub new {
  my $class = shift;
  my %params = @_;
  my $self = {
    cpus => [],
    blacklisted => 0,
    info => undef,
    extendedinfo => undef,
  };
  bless $self, $class;
  $self->init(%params);
  return $self;
}

sub init {
  my $self = shift;
  my %params = @_;
  # With SGOS version 5.5.4.1, 5.4.6.1 and 6.1.2.1, the SNMP MIB has been extended to support multiple CPU cores.
  # The new OID is defined as a table 1.3.6.1.4.1.3417.2.11.2.4.1 in the BLUECOAT-SG-PROXY-MIB file with the following sub-OIDs.
  # https://kb.bluecoat.com/index?page=content&id=FAQ1244&actp=search&viewlocale=en_US&searchid=1360452047002
  foreach ($self->get_snmp_table_objects(
      'BLUECOAT-SG-PROXY-MIB', 'sgProxyCpuCoreTable')) {
    push(@{$self->{cpus}},
        NWC::SGOS::Component::CpuSubsystem::Cpu->new(%{$_}));
  }
  if (scalar (@{$self->{cpus}}) == 0) {
    foreach ($self->get_snmp_table_objects(
        'USAGE-MIB', 'deviceUsageTable')) {
      next if $_->{deviceUsageName} !~ /CPU/;
      push(@{$self->{cpus}},
          NWC::SGOS::Component::CpuSubsystem::DevCpu->new(%{$_}));
    }
  }
}

sub check {
  my $self = shift;
  my $errorfound = 0;
  $self->add_info('checking cpus');
  $self->blacklist('ff', '');
  if (scalar (@{$self->{cpus}}) == 0) {
  } else {
    foreach (@{$self->{cpus}}) {
      $_->check();
    }
  }
}

sub dump {
  my $self = shift;
  foreach (@{$self->{cpus}}) {
    $_->dump();
  }
}


package NWC::SGOS::Component::CpuSubsystem::Cpu;
our @ISA = qw(NWC::SGOS::Component::CpuSubsystem);

use strict;
use constant { OK => 0, WARNING => 1, CRITICAL => 2, UNKNOWN => 3 };

sub new {
  my $class = shift;
  my %params = @_;
  my $self = {
    blacklisted => 0,
    info => undef,
    extendedinfo => undef,
  };
  foreach (qw(sgProxyCpuCoreUpTime sgProxyCpuCoreBusyTime
      sgProxyCpuCoreIdleTime sgProxyCpuCoreUpTimeSinceLastAccess
      sgProxyCpuCoreBusyTimeSinceLastAccess
      sgProxyCpuCoreIdleTimeSinceLastAccess
      sgProxyCpuCoreBusyPerCent sgProxyCpuCoreIdlePerCent)) {
    if (exists $params{$_}) {
      $self->{$_} = $params{$_};
    }
  }
  $self->{sgProxyCpuCoreIndex} = join(".", @{$params{indices}});
  bless $self, $class;
  return $self;
}

sub check {
  my $self = shift;
  $self->blacklist('c', $self->{sgProxyCpuCoreIndex});
  my $info = sprintf 'cpu %s usage is %.2f%%',
      $self->{sgProxyCpuCoreIndex}, $self->{sgProxyCpuCoreBusyPerCent};
  $self->add_info($info);
  $self->set_thresholds(warning => 80, critical => 90);
  $self->add_message($self->check_thresholds($self->{sgProxyCpuCoreBusyPerCent}), $info);
  $self->add_perfdata(
      label => 'cpu_'.$self->{sgProxyCpuCoreIndex}.'_usage',
      value => $self->{sgProxyCpuCoreBusyPerCent},
      uom => '%',
      warning => $self->{warning},
      critical => $self->{critical},
  );
}

sub dump {
  my $self = shift;
  printf "[CPU_%s]\n", $self->{sgProxyCpuCoreIndex};
  foreach (qw(sgProxyCpuCoreUpTime sgProxyCpuCoreBusyTime
      sgProxyCpuCoreIdleTime sgProxyCpuCoreUpTimeSinceLastAccess
      sgProxyCpuCoreBusyTimeSinceLastAccess
      sgProxyCpuCoreIdleTimeSinceLastAccess
      sgProxyCpuCoreBusyPerCent sgProxyCpuCoreIdlePerCent)) {
    if (exists $self->{$_}) {
      printf "%s: %s\n", $_, $self->{$_};
    }
  }
  printf "info: %s\n", $self->{info};
  printf "\n";
}


package NWC::SGOS::Component::CpuSubsystem::DevCpu;
our @ISA = qw(NWC::SGOS::Component::CpuSubsystem);

use strict;
use constant { OK => 0, WARNING => 1, CRITICAL => 2, UNKNOWN => 3 };

sub new {
  my $class = shift;
  my %params = @_;
  my $self = {
    blacklisted => 0,
    info => undef,
    extendedinfo => undef,
  };
  foreach (qw(deviceUsageIndex deviceUsageTrapEnabled deviceUsageName
      deviceUsagePercent deviceUsageHigh deviceUsageStatus deviceUsageTime)) {
    if (exists $params{$_}) {
      $self->{$_} = $params{$_};
    }
  }
  $self->{deviceUsageIndex} = join(".", @{$params{indices}});
  bless $self, $class;
  return $self;
}

sub check {
  my $self = shift;
  $self->blacklist('c', $self->{deviceUsageIndex});
  my $info = sprintf 'cpu %s usage is %.2f%%',
      $self->{deviceUsageIndex}, $self->{deviceUsagePercent};
  $self->add_info($info);
  $self->set_thresholds(warning => 80, critical => 90);
  $self->add_message($self->check_thresholds($self->{deviceUsagePercent}), $info);
  $self->add_perfdata(
      label => 'cpu_'.$self->{deviceUsageIndex}.'_usage',
      value => $self->{deviceUsagePercent},
      uom => '%',
      warning => $self->{warning},
      critical => $self->{critical},
  );
}

sub dump {
  my $self = shift;
  printf "[CPU_%s]\n", $self->{deviceUsageIndex};
  foreach (qw(deviceUsageIndex deviceUsageTrapEnabled deviceUsageName
      deviceUsagePercent deviceUsageHigh deviceUsageStatus deviceUsageTime)) {
    if (exists $self->{$_}) {
      printf "%s: %s\n", $_, $self->{$_};
    }
  }
  printf "info: %s\n", $self->{info};
  printf "\n";
}

package NWC::SGOS::Component::EnvironmentalSubsystem;
our @ISA = qw(NWC::SGOS);

use strict;
use constant { OK => 0, WARNING => 1, CRITICAL => 2, UNKNOWN => 3 };

sub new {
  my $class = shift;
  my %params = @_;
  my $self = {
    runtime => $params{runtime},
    rawdata => $params{rawdata},
    method => $params{method},
    condition => $params{condition},
    status => $params{status},
    sensor_subsystem => undef,
    disk_subsystem => undef,
    blacklisted => 0,
    info => undef,
    extendedinfo => undef,
  };
  bless $self, $class;
  $self->init(%params);
  return $self;
}

sub init {
  my $self = shift;
  my %params = @_;
  $self->{sensor_subsystem} =
      NWC::SGOS::Component::SensorSubsystem->new(%params);
  $self->{disk_subsystem} =
      NWC::SGOS::Component::DiskSubsystem->new(%params);
}

sub check {
  my $self = shift;
  my $errorfound = 0;
  $self->{sensor_subsystem}->check();
  $self->{disk_subsystem}->check();
  if (! $self->check_messages()) {
    $self->add_message(OK, "environmental hardware working fine");
  }
}

sub dump {
  my $self = shift;
  $self->{sensor_subsystem}->dump();
  $self->{disk_subsystem}->dump();
}


package NWC::SGOS::Component::SensorSubsystem;
our @ISA = qw(NWC::SGOS::Component::EnvironmentalSubsystem);

use strict;
use constant { OK => 0, WARNING => 1, CRITICAL => 2, UNKNOWN => 3 };

sub new {
  my $class = shift;
  my %params = @_;
  my $self = {
    sensors => [],
    sensorthresholds => [],
    blacklisted => 0,
    info => undef,
    extendedinfo => undef,
  };
  bless $self, $class;
  $self->init(%params);
  return $self;
}

sub init {
  my $self = shift;
  my $sensors = {};
  foreach ($self->get_snmp_table_objects(
      'SENSOR-MIB', 'deviceSensorValueTable')) {
    push(@{$self->{sensors}}, 
        NWC::SGOS::Component::SensorSubsystem::Sensor->new(%{$_}));
  }
}

sub check {
  my $self = shift;
  my $errorfound = 0;
  $self->add_info('checking sensors');
  $self->blacklist('ses', '');
  if (scalar (@{$self->{sensors}}) == 0) {
  } else {
    foreach (@{$self->{sensors}}) {
      $_->check();
    }
  }
}

sub dump {
  my $self = shift;
  foreach (@{$self->{sensors}}) {
    $_->dump();
  }
}


package NWC::SGOS::Component::SensorSubsystem::Sensor;
our @ISA = qw(NWC::SGOS::Component::SensorSubsystem);

use strict;
use constant { OK => 0, WARNING => 1, CRITICAL => 2, UNKNOWN => 3 };

sub new {
  my $class = shift;
  my %params = @_;
  my $self = {
    blacklisted => 0,
    info => undef,
    extendedinfo => undef,
  };
  foreach (qw(deviceSensorIndex deviceSensorTrapEnabled
      deviceSensorUnits deviceSensorScale deviceSensorValue
      deviceSensorCode deviceSensorStatus deviceSensorTimeStamp
      deviceSensorName)) {
    $self->{$_} = $params{$_};
  }
  $self->{deviceSensorIndex} = join(".", @{$params{indices}});
  if ($self->{deviceSensorScale}) {
    $self->{deviceSensorValue} *= 10 ** $self->{deviceSensorScale};
  }
  bless $self, $class;
  return $self;
}

sub check {
  my $self = shift;
  $self->blacklist('se', $self->{deviceSensorIndex});
  $self->add_info(sprintf 'sensor %s (%s %s) is %s',
      $self->{deviceSensorName},
      $self->{deviceSensorValue},
      $self->{deviceSensorUnits},
      $self->{deviceSensorCode});
  if ($self->{deviceSensorCode} eq "not-installed") {
  } elsif ($self->{deviceSensorCode} eq "unknown") {
  } elsif ($self->{deviceSensorCode} ne "ok") {
    if ($self->{deviceSensorCode} =~ /warning/) {
      $self->add_message(WARNING, $self->{info});
    } else {
      $self->add_message(CRITICAL, $self->{info});
    }
    $self->add_perfdata(
        label => sprintf('sensor_%s', 
            $self->{deviceSensorName}),
        value => $self->{deviceSensorValue},
    );
  } else {
    $self->add_perfdata(
        label => sprintf('sensor_%s', 
            $self->{deviceSensorName}),
        value => $self->{deviceSensorValue},
    );
  }
}

sub dump {
  my $self = shift;
  printf "[SENSOR_%s]\n", $self->{deviceSensorIndex};
  foreach (qw(deviceSensorIndex deviceSensorTrapEnabled
      deviceSensorUnits deviceSensorScale deviceSensorValue
      deviceSensorCode deviceSensorStatus deviceSensorTimeStamp
      deviceSensorName)) {
    printf "%s: %s\n", $_, $self->{$_};
  }
  printf "info: %s\n", $self->{info};
  printf "\n";
}


package NWC::SGOS::Component::DiskSubsystem;
our @ISA = qw(NWC::SGOS::Component::EnvironmentalSubsystem);

use strict;
use constant { OK => 0, WARNING => 1, CRITICAL => 2, UNKNOWN => 3 };

sub new {
  my $class = shift;
  my %params = @_;
  my $self = {
    disks => [],
    diskthresholds => [],
    blacklisted => 0,
    info => undef,
    extendedinfo => undef,
  };
  bless $self, $class;
  $self->init(%params);
  return $self;
}

sub init {
  my $self = shift;
  my $disks = {};
  foreach ($self->get_snmp_table_objects(
      'DISK-MIB', 'deviceDiskValueTable')) {
    push(@{$self->{disks}}, 
        NWC::SGOS::Component::DiskSubsystem::Disk->new(%{$_}));
  }
}

sub check {
  my $self = shift;
  my $errorfound = 0;
  $self->add_info('checking disks');
  $self->blacklist('ses', '');
  if (scalar (@{$self->{disks}}) == 0) {
  } else {
    foreach (@{$self->{disks}}) {
      $_->check();
    }
  }
}

sub dump {
  my $self = shift;
  foreach (@{$self->{disks}}) {
    $_->dump();
  }
}


package NWC::SGOS::Component::DiskSubsystem::Disk;
our @ISA = qw(NWC::SGOS::Component::DiskSubsystem);

use strict;
use constant { OK => 0, WARNING => 1, CRITICAL => 2, UNKNOWN => 3 };

sub new {
  my $class = shift;
  my %params = @_;
  my $self = {
    blacklisted => 0,
    info => undef,
    extendedinfo => undef,
  };
  foreach (qw(deviceDiskIndex deviceDiskTrapEnabled deviceDiskStatus
      deviceDiskTimeStamp deviceDiskVendor deviceDiskProduct deviceDiskRevision
      deviceDiskSerialN deviceDiskBlockSize deviceDiskBlockCount)) {
    $self->{$_} = $params{$_};
  }
  $self->{deviceDiskIndex} = join(".", @{$params{indices}});
  bless $self, $class;
  return $self;
}

sub check {
  my $self = shift;
  $self->blacklist('di', $self->{deviceDiskIndex});
  $self->add_info(sprintf 'disk %s (%s %s) is %s',
      $self->{deviceDiskIndex},
      $self->{deviceDiskVendor},
      $self->{deviceDiskRevision},
      $self->{deviceDiskStatus});
  if ($self->{deviceDiskStatus} eq "bad") {
    $self->add_message(CRITICAL, $self->{info});
  }
}

sub dump {
  my $self = shift;
  printf "[DISK_%s]\n", $self->{deviceDiskIndex};
  foreach (qw(deviceDiskIndex deviceDiskTrapEnabled deviceDiskStatus
      deviceDiskTimeStamp deviceDiskVendor deviceDiskProduct deviceDiskRevision
      deviceDiskSerialN deviceDiskBlockSize deviceDiskBlockCount)) {
    printf "%s: %s\n", $_, $self->{$_};
  }
  printf "info: %s\n", $self->{info};
  printf "\n";
}


package NWC::SGOS::Component::SecuritySubsystem;
our @ISA = qw(NWC::SGOS);

use strict;
use constant { OK => 0, WARNING => 1, CRITICAL => 2, UNKNOWN => 3 };

sub new {
  my $class = shift;
  my %params = @_;
  my $self = {
    securitys => [],
    blacklisted => 0,
    info => undef,
    extendedinfo => undef,
  };
  bless $self, $class;
  $self->init(%params);
  return $self;
}

sub init {
  my $self = shift;
  my %params = @_;
  foreach ($self->get_snmp_table_objects(
      'ATTACK-MIB', 'deviceAttackTable')) {
    push(@{$self->{securitys}},
        NWC::SGOS::Component::SecuritySubsystem::Security->new(%{$_}));
  }
}

sub check {
  my $self = shift;
  my $errorfound = 0;
  $self->add_info('checking securitys');
  $self->blacklist('ff', '');
  if (scalar (@{$self->{securitys}}) == 0) {
    $self->add_message(OK, 'no security incidents');
  } else {
    foreach (@{$self->{securitys}}) {
      $_->check();
    }
    $self->add_message(OK, sprintf '%d serious incidents (of %d)',
        scalar(grep { $_->{count_me} == 1 } @{$self->{securitys}}),
        scalar(@{$self->{securitys}}));
  }
}

sub dump {
  my $self = shift;
  foreach (@{$self->{securitys}}) {
    $_->dump();
  }
}


package NWC::SGOS::Component::SecuritySubsystem::Security;
our @ISA = qw(NWC::SGOS::Component::SecuritySubsystem);

use strict;
use constant { OK => 0, WARNING => 1, CRITICAL => 2, UNKNOWN => 3 };

sub new {
  my $class = shift;
  my %params = @_;
  my $self = {
    blacklisted => 0,
    info => undef,
    extendedinfo => undef,
  };
  foreach (qw(deviceAttackIndex deviceAttackName deviceAttackStatus
      deviceAttackTime)) {
    if (exists $params{$_}) {
      $self->{$_} = $params{$_};
    }
  }
  $self->{deviceAttackIndex} = join(".", @{$params{indices}});
  bless $self, $class;
  $self->{deviceAttackTime} = $self->timeticks(
      $self->{deviceAttackTime});
  $self->{count_me} = 0;
  return $self;
}

sub check {
  my $self = shift;
  $self->blacklist('s', $self->{deviceAttackIndex});
  my $info = sprintf '%s %s %s',
      scalar localtime (time - $self->uptime() + $self->{deviceAttackTime}),
      $self->{deviceAttackName}, $self->{deviceAttackStatus};
  $self->add_info($info);
  my $lookback = $self->opts->lookback() ? 
      $self->opts->lookback() : 3600;
  if (($self->{deviceAttackStatus} eq 'under-attack') &&
      ($lookback - $self->uptime() + $self->{deviceAttackTime} > 0)) {
    $self->add_message(CRITICAL, $info);
    $self->{count_me}++;
  }
}

sub dump {
  my $self = shift;
  printf "[ATTACK_%s]\n", $self->{deviceAttackIndex};
  foreach (qw(deviceAttackIndex deviceAttackName deviceAttackStatus
      deviceAttackTime)) {
    if (exists $self->{$_}) {
      printf "%s: %s\n", $_, $self->{$_};
    }
  }
  printf "info: %s\n", $self->{info};
  printf "\n";
}

package NWC::SGOS;

use strict;

use constant { OK => 0, WARNING => 1, CRITICAL => 2, UNKNOWN => 3 };

our @ISA = qw(NWC::Bluecoat);

sub init {
  my $self = shift;
  my %params = @_;
  $self->{components} = {
      powersupply_subsystem => undef,
      fan_subsystem => undef,
      temperature_subsystem => undef,
      cpu_subsystem => undef,
      security_subsystem => undef,
  };
  $self->{serial} = 'unknown';
  $self->{product} = 'unknown';
  $self->{romversion} = 'unknown';
  # serial is 1.3.6.1.2.1.47.1.1.1.1.11.1
  #$self->collect();
  if (! $self->check_messages()) {
    ##$self->set_serial();
    if ($self->mode =~ /device::hardware::health/) {
      $self->analyze_environmental_subsystem();
      $self->check_environmental_subsystem();
    } elsif ($self->mode =~ /device::hardware::load/) {
      $self->analyze_cpu_subsystem();
      $self->check_cpu_subsystem();
    } elsif ($self->mode =~ /device::hardware::memory/) {
      $self->analyze_mem_subsystem();
      $self->check_mem_subsystem();
    } elsif ($self->mode =~ /device::security/) {
      $self->analyze_security_subsystem();
      $self->check_security_subsystem();
    }
  }
}

sub analyze_environmental_subsystem {
  my $self = shift;
  $self->{components}->{environmental_subsystem} =
      NWC::SGOS::Component::EnvironmentalSubsystem->new();
}

sub analyze_cpu_subsystem {
  my $self = shift;
  $self->{components}->{cpu_subsystem} =
      NWC::SGOS::Component::CpuSubsystem->new();
}

sub analyze_mem_subsystem {
  my $self = shift;
  $self->{components}->{mem_subsystem} =
      NWC::SGOS::Component::MemSubsystem->new();
}

sub analyze_security_subsystem {
  my $self = shift;
  $self->{components}->{security_subsystem} =
      NWC::SGOS::Component::SecuritySubsystem->new();
}

package NWC::AVOS::Component::KeySubsystem;
our @ISA = qw(NWC::AVOS);

use strict;
use constant { OK => 0, WARNING => 1, CRITICAL => 2, UNKNOWN => 3 };

sub new {
  my $class = shift;
  my %params = @_;
  my $self = {
    blacklisted => 0,
    info => undef,
    extendedinfo => undef,
  };
  bless $self, $class;
  $self->init(%params);
  return $self;
}

sub init {
  my $self = shift;
  foreach (qw(avLicenseDaysRemaining avVendorName)) {
    $self->{$_} = $self->get_snmp_object('BLUECOAT-AV-MIB', $_);
  }
}

sub check {
  my $self = shift;
  $self->add_info(sprintf 'license %s expires in %d days',
      $self->{avVendorName},
      $self->{avLicenseDaysRemaining});
  $self->set_thresholds(warning => '14:', critical => '7:');
  $self->add_message($self->check_thresholds($self->{avLicenseDaysRemaining}), $self->{info});
  $self->add_perfdata(
      label => sprintf('lifetime_%s', $self->{avVendorName}),
      value => $self->{avLicenseDaysRemaining},
      warning => $self->{warning},
      critical => $self->{critical},
  );
}

sub dump {
  my $self = shift;
  printf "[LICENSE_%s]\n", $self->{avVendorName};
  foreach (qw(avLicenseDaysRemaining avVendorName)) {
    printf "%s: %s\n", $_, $self->{$_};
  }
  printf "info: %s\n", $self->{info};
  printf "\n";
}


package NWC::AVOS::Component::SecuritySubsystem;
our @ISA = qw(NWC::AVOS);

use strict;
use constant { OK => 0, WARNING => 1, CRITICAL => 2, UNKNOWN => 3 };

sub new {
  my $class = shift;
  my %params = @_;
  my $self = {
    blacklisted => 0,
    info => undef,
    extendedinfo => undef,
  };
  bless $self, $class;
  $self->init(%params);
  return $self;
}

sub init {
  my $self = shift;
  foreach (qw(avVirusesDetected)) {
    $self->{$_} = $self->get_snmp_object('BLUECOAT-AV-MIB', $_);
  }
}

sub check {
  my $self = shift;
  $self->add_info(sprintf '%d viruses detected',
      $self->{avVirusesDetected});
  $self->set_thresholds(warning => 1500, critical => 1500);
  $self->add_message($self->check_thresholds($self->{avVirusesDetected}), $self->{info});
  $self->add_perfdata(
      label => 'viruses',
      value => $self->{avVirusesDetected},
      warning => $self->{warning},
      critical => $self->{critical},
  );

}

sub dump {
  my $self = shift;
  printf "[VIRUSES]\n";
  foreach (qw(avVirusesDetected)) {
    printf "%s: %s\n", $_, $self->{$_};
  }
  printf "info: %s\n", $self->{info};
  printf "\n";
}


package NWC::AVOS::Component::ConnectionSubsystem;
our @ISA = qw(NWC::AVOS);

use strict;
use constant { OK => 0, WARNING => 1, CRITICAL => 2, UNKNOWN => 3 };

sub new {
  my $class = shift;
  my %params = @_;
  my $self = {
    blacklisted => 0,
    info => undef,
    extendedinfo => undef,
  };
  bless $self, $class;
  $self->init(%params);
  return $self;
}

sub init {
  my $self = shift;
  foreach (qw(avSlowICAPConnections)) {
    $self->{$_} = $self->get_snmp_object('BLUECOAT-AV-MIB', $_);
  }
}

sub check {
  my $self = shift;
  $self->add_info(sprintf '%d slow ICAP connections',
      $self->{avSlowICAPConnections});
  $self->set_thresholds(warning => 100, critical => 100);
  $self->add_message($self->check_thresholds($self->{avSlowICAPConnections}), $self->{info});
  $self->add_perfdata(
      label => 'slow_connections',
      value => $self->{avSlowICAPConnections},
      warning => $self->{warning},
      critical => $self->{critical},
  );
}

sub dump {
  my $self = shift;
  printf "[CONNECTIONS]\n";
  foreach (qw(avSlowICAPConnections)) {
    printf "%s: %s\n", $_, $self->{$_};
  }
  printf "info: %s\n", $self->{info};
  printf "\n";
}


package NWC::AVOS::Component::MemSubsystem;
our @ISA = qw(NWC::AVOS);

use strict;
use constant { OK => 0, WARNING => 1, CRITICAL => 2, UNKNOWN => 3 };

sub new {
  my $class = shift;
  my %params = @_;
  my $self = {
    runtime => $params{runtime},
    rawdata => $params{rawdata},
    mems => [],
    blacklisted => 0,
    info => undef,
    extendedinfo => undef,
  };
  bless $self, $class;
  $self->init(%params);
  return $self;
}

sub init {
  # https://kb.bluecoat.com/index?page=content&id=KB3069
  # Memory pressure simply is the percentage of physical memory less free and reclaimable memory, of total memory. So, for example, if there is no free or reclaimable memory in the system, then memory pressure is at 100%.
  # The event logs start reporting memory pressure when it is over 75%.
  # There's two separate OIDs to obtain memory pressure value for AVOSV4 and AVOSV5;
  # AVOSV4:  memPressureValue - OIDs: 1.3.6.1.4.1.3417.2.8.2.3 (systemResourceMIB)
  # AVOSV5: sgProxyMemoryPressure - OIDs: 1.3.6.1.4.1.3417.2.11.2.3.4 (bluecoatSGProxyMIB)
  my $self = shift;
  my %params = @_;
  my $snmpwalk = $params{rawdata};
  my $ignore_redundancy = $params{ignore_redundancy};
  my $type = 0;
  foreach (qw(sgProxyMemPressure sgProxyMemAvailable sgProxyMemCacheUsage
      sgProxyMemSysUsage)) {
    $self->{$_} = $self->get_snmp_object('BLUECOAT-SG-PROXY-MIB', $_);
  }
  if (! defined $self->{sgProxyMemPressure}) {
    foreach (qw(memPressureValue memWarningThreshold memCriticalThreshold memCurrentState)) {
      $self->{$_} = $self->get_snmp_object('SYSTEM-RESOURCES-MIB', $_);
    }
  }
  if (! defined $self->{memPressureValue}) {
    foreach ($self->get_snmp_table_objects(
        'USAGE-MIB', 'deviceUsageTable')) {
      next if $_->{deviceUsageName} !~ /Memory/;
      $self->{deviceUsageName} = $_->{deviceUsageName};
      $self->{deviceUsagePercent} = $_->{deviceUsagePercent};
      $self->{deviceUsageHigh} = $_->{deviceUsageHigh};
      $self->{deviceUsageStatus} = $_->{deviceUsageStatus};
      $self->{deviceUsageTime} = $_->{deviceUsageTime};
    }
    bless $self, 'NWC::AVOS::Component::MemSubsystem::AVOS3';
  }
}

package NWC::AVOS::Component::MemSubsystem::AVOS3;
our @ISA = qw(NWC::AVOS::Component::MemSubsystem);

use strict;
use constant { OK => 0, WARNING => 1, CRITICAL => 2, UNKNOWN => 3 };


sub check {
  my $self = shift;
  my $errorfound = 0;
  $self->add_info('checking memory');
  $self->blacklist('m', '');
  my $info = sprintf 'memory usage is %.2f%%',
      $self->{deviceUsagePercent};
  $self->add_info($info);
  $self->set_thresholds(warning => $self->{deviceUsageHigh} - 10, critical => $self->{deviceUsageHigh});
  $self->add_message($self->check_thresholds($self->{deviceUsagePercent}), $info);
  $self->add_perfdata(
      label => 'memory_usage',
      value => $self->{deviceUsagePercent},
      uom => '%',
      warning => $self->{warning},
      critical => $self->{critical}
  );
}

sub dump {
  my $self = shift;
  printf "[MEMORY]\n";
  foreach (qw(deviceUsageName deviceUsagePercent deviceUsageHigh
      deviceUsageStatus deviceUsageTime)) {
    printf "%s: %s\n", $_, $self->{$_};
  }
  printf "info: %s\n", $self->{info};
  printf "\n";
}

package NWC::AVOS::Component::CpuSubsystem;
our @ISA = qw(NWC::AVOS);

use strict;
use constant { OK => 0, WARNING => 1, CRITICAL => 2, UNKNOWN => 3 };

sub new {
  my $class = shift;
  my %params = @_;
  my $self = {
    cpus => [],
    blacklisted => 0,
    info => undef,
    extendedinfo => undef,
  };
  bless $self, $class;
  $self->init(%params);
  return $self;
}

sub init {
  my $self = shift;
  my %params = @_;
  # With AVOS version 5.5.4.1, 5.4.6.1 and 6.1.2.1, the SNMP MIB has been extended to support multiple CPU cores.
  # The new OID is defined as a table 1.3.6.1.4.1.3417.2.11.2.4.1 in the BLUECOAT-SG-PROXY-MIB file with the following sub-OIDs.
  # https://kb.bluecoat.com/index?page=content&id=FAQ1244&actp=search&viewlocale=en_US&searchid=1360452047002
  foreach ($self->get_snmp_table_objects(
      'BLUECOAT-SG-PROXY-MIB', 'sgProxyCpuCoreTable')) {
    push(@{$self->{cpus}},
        NWC::AVOS::Component::CpuSubsystem::Cpu->new(%{$_}));
  }
  if (scalar (@{$self->{cpus}}) == 0) {
    foreach ($self->get_snmp_table_objects(
        'USAGE-MIB', 'deviceUsageTable')) {
      next if $_->{deviceUsageName} !~ /CPU/;
      push(@{$self->{cpus}},
          NWC::AVOS::Component::CpuSubsystem::DevCpu->new(%{$_}));
    }
  }
}

sub check {
  my $self = shift;
  my $errorfound = 0;
  $self->add_info('checking cpus');
  $self->blacklist('ff', '');
  if (scalar (@{$self->{cpus}}) == 0) {
  } else {
    foreach (@{$self->{cpus}}) {
      $_->check();
    }
  }
}

sub dump {
  my $self = shift;
  foreach (@{$self->{cpus}}) {
    $_->dump();
  }
}


package NWC::AVOS::Component::CpuSubsystem::Cpu;
our @ISA = qw(NWC::AVOS::Component::CpuSubsystem);

use strict;
use constant { OK => 0, WARNING => 1, CRITICAL => 2, UNKNOWN => 3 };

sub new {
  my $class = shift;
  my %params = @_;
  my $self = {
    blacklisted => 0,
    info => undef,
    extendedinfo => undef,
  };
  foreach (qw(sgProxyCpuCoreUpTime sgProxyCpuCoreBusyTime
      sgProxyCpuCoreIdleTime sgProxyCpuCoreUpTimeSinceLastAccess
      sgProxyCpuCoreBusyTimeSinceLastAccess
      sgProxyCpuCoreIdleTimeSinceLastAccess
      sgProxyCpuCoreBusyPerCent sgProxyCpuCoreIdlePerCent)) {
    if (exists $params{$_}) {
      $self->{$_} = $params{$_};
    }
  }
  $self->{sgProxyCpuCoreIndex} = join(".", @{$params{indices}});
  bless $self, $class;
  return $self;
}

sub check {
  my $self = shift;
  $self->blacklist('c', $self->{sgProxyCpuCoreIndex});
  my $info = sprintf 'cpu %s usage is %.2f%%',
      $self->{sgProxyCpuCoreIndex}, $self->{sgProxyCpuCoreBusyPerCent};
  $self->add_info($info);
  $self->set_thresholds(warning => 80, critical => 90);
  $self->add_message($self->check_thresholds($self->{sgProxyCpuCoreBusyPerCent}), $info);
  $self->add_perfdata(
      label => 'cpu_'.$self->{sgProxyCpuCoreIndex}.'_usage',
      value => $self->{sgProxyCpuCoreBusyPerCent},
      uom => '%',
      warning => $self->{warning},
      critical => $self->{critical},
  );
}

sub dump {
  my $self = shift;
  printf "[CPU_%s]\n", $self->{sgProxyCpuCoreIndex};
  foreach (qw(sgProxyCpuCoreUpTime sgProxyCpuCoreBusyTime
      sgProxyCpuCoreIdleTime sgProxyCpuCoreUpTimeSinceLastAccess
      sgProxyCpuCoreBusyTimeSinceLastAccess
      sgProxyCpuCoreIdleTimeSinceLastAccess
      sgProxyCpuCoreBusyPerCent sgProxyCpuCoreIdlePerCent)) {
    if (exists $self->{$_}) {
      printf "%s: %s\n", $_, $self->{$_};
    }
  }
  printf "info: %s\n", $self->{info};
  printf "\n";
}


package NWC::AVOS::Component::CpuSubsystem::DevCpu;
our @ISA = qw(NWC::AVOS::Component::CpuSubsystem);

use strict;
use constant { OK => 0, WARNING => 1, CRITICAL => 2, UNKNOWN => 3 };

sub new {
  my $class = shift;
  my %params = @_;
  my $self = {
    blacklisted => 0,
    info => undef,
    extendedinfo => undef,
  };
  foreach (qw(deviceUsageIndex deviceUsageTrapEnabled deviceUsageName
      deviceUsagePercent deviceUsageHigh deviceUsageStatus deviceUsageTime)) {
    if (exists $params{$_}) {
      $self->{$_} = $params{$_};
    }
  }
  $self->{deviceUsageIndex} = join(".", @{$params{indices}});
  bless $self, $class;
  return $self;
}

sub check {
  my $self = shift;
  $self->blacklist('c', $self->{deviceUsageIndex});
  my $info = sprintf 'cpu %s usage is %.2f%%',
      $self->{deviceUsageIndex}, $self->{deviceUsagePercent};
  $self->add_info($info);
  $self->set_thresholds(warning => $self->{deviceUsageHigh} - 10, critical => $self->{deviceUsageHigh});
  $self->add_message($self->check_thresholds($self->{deviceUsagePercent}), $info);
  $self->add_perfdata(
      label => 'cpu_'.$self->{deviceUsageIndex}.'_usage',
      value => $self->{deviceUsagePercent},
      uom => '%',
      warning => $self->{warning},
      critical => $self->{critical},
  );
}

sub dump {
  my $self = shift;
  printf "[CPU_%s]\n", $self->{deviceUsageIndex};
  foreach (qw(deviceUsageIndex deviceUsageTrapEnabled deviceUsageName
      deviceUsagePercent deviceUsageHigh deviceUsageStatus deviceUsageTime)) {
    if (exists $self->{$_}) {
      printf "%s: %s\n", $_, $self->{$_};
    }
  }
  printf "info: %s\n", $self->{info};
  printf "\n";
}

package NWC::AVOS;

use strict;

use constant { OK => 0, WARNING => 1, CRITICAL => 2, UNKNOWN => 3 };

our @ISA = qw(NWC::Bluecoat);

sub init {
  my $self = shift;
  my %params = @_;
  $self->{components} = {
      powersupply_subsystem => undef,
      fan_subsystem => undef,
      temperature_subsystem => undef,
      cpu_subsystem => undef,
      security_subsystem => undef,
  };
  $self->{serial} = 'unknown';
  $self->{product} = 'unknown';
  $self->{romversion} = 'unknown';
  # serial is 1.3.6.1.2.1.47.1.1.1.1.11.1
  #$self->collect();
  if (! $self->check_messages()) {
    ##$self->set_serial();
    if ($self->mode =~ /device::hardware::health/) {
      $self->no_such_mode();
    } elsif ($self->mode =~ /device::hardware::load/) {
      $self->analyze_cpu_subsystem();
      $self->check_cpu_subsystem();
    } elsif ($self->mode =~ /device::hardware::memory/) {
      $self->analyze_mem_subsystem();
      $self->check_mem_subsystem();
    } elsif ($self->mode =~ /device::licenses::/) {
      $self->analyze_key_subsystem();
      $self->check_key_subsystem();
    } elsif ($self->mode =~ /device::connections/) {
      $self->analyze_connection_subsystem();
      $self->check_connection_subsystem();
    } elsif ($self->mode =~ /device::security/) {
      $self->analyze_security_subsystem();
      $self->check_security_subsystem();
    }
  }
}

sub analyze_environmental_subsystem {
  my $self = shift;
  $self->{components}->{environmental_subsystem} =
      NWC::AVOS::Component::EnvironmentalSubsystem->new();
}

sub analyze_cpu_subsystem {
  my $self = shift;
  $self->{components}->{cpu_subsystem} =
      NWC::AVOS::Component::CpuSubsystem->new();
}

sub analyze_mem_subsystem {
  my $self = shift;
  $self->{components}->{mem_subsystem} =
      NWC::AVOS::Component::MemSubsystem->new();
}

sub analyze_key_subsystem {
  my $self = shift;
  $self->{components}->{key_subsystem} =
      NWC::AVOS::Component::KeySubsystem->new();
}

sub analyze_security_subsystem {
  my $self = shift;
  $self->{components}->{security_subsystem} =
      NWC::AVOS::Component::SecuritySubsystem->new();
}

sub analyze_connection_subsystem {
  my $self = shift;
  $self->{components}->{connection_subsystem} =
      NWC::AVOS::Component::ConnectionSubsystem->new();
}

package NWC::Foundry::Component::MemSubsystem;
our @ISA = qw(NWC::Foundry);

use strict;
use constant { OK => 0, WARNING => 1, CRITICAL => 2, UNKNOWN => 3 };

sub new {
  my $class = shift;
  my %params = @_;
  my $self = {
    runtime => $params{runtime},
    rawdata => $params{rawdata},
    mems => [],
    blacklisted => 0,
    info => undef,
    extendedinfo => undef,
  };
  bless $self, $class;
  $self->init(%params);
  return $self;
}

sub init {
  my $self = shift;
  my %params = @_;
  my $snmpwalk = $params{rawdata};
  foreach (qw(snAgGblDynMemUtil snAgGblDynMemTotal snAgGblDynMemFree)) {
    $self->{$_} = $self->get_snmp_object('FOUNDRY-SN-AGENT-MIB', $_);
  }
}

sub check {
  my $self = shift;
  my $errorfound = 0;
  $self->add_info('checking memory');
  $self->blacklist('m', '');
  if (defined $self->{snAgGblDynMemUtil}) {
    my $info = sprintf 'memory usage is %.2f%%',
        $self->{snAgGblDynMemUtil};
    $self->add_info($info);
    $self->set_thresholds(warning => 80, critical => 99);
    $self->add_message($self->check_thresholds($self->{snAgGblDynMemUtil}), $info);
    $self->add_perfdata(
        label => 'memory_usage',
        value => $self->{snAgGblDynMemUtil},
        uom => '%',
        warning => $self->{warning},
        critical => $self->{critical}
    );
  } else {
    $self->add_message(UNKNOWN, 'cannot aquire momory usage');
  }
}

sub dump {
  my $self = shift;
  printf "[MEMORY]\n";
  foreach (qw(snAgGblDynMemUtil snAgGblDynMemTotal snAgGblDynMemFree)) {
    printf "%s: %s\n", $_, $self->{$_};
  }
  printf "info: %s\n", $self->{info};
  printf "\n";
}

package NWC::Foundry::Component::CpuSubsystem;
our @ISA = qw(NWC::Foundry);

use strict;
use constant { OK => 0, WARNING => 1, CRITICAL => 2, UNKNOWN => 3 };

sub new {
  my $class = shift;
  my %params = @_;
  my $self = {
    loads => [],
    blacklisted => 0,
    info => undef,
    extendedinfo => undef,
  };
  bless $self, $class;
  $self->init(%params);
  return $self;
}

sub init {
  my $self = shift;
  my %params = @_;
  foreach ($self->get_snmp_table_objects(
      'FOUNDRY-SN-AGENT-MIB', 'snAgentCpuUtilTable')) {
    push(@{$self->{cpus}},
        NWC::Foundry::Component::CpuSubsystem::Cpu->new(%{$_}));
  }
  foreach (qw(snAgGblCpuUtil1SecAvg snAgGblCpuUtil5SecAvg
      snAgGblCpuUtil1MinAvg)) {
    $self->{$_} = $self->get_snmp_object('FOUNDRY-SN-AGENT-MIB', $_);
  }
}

sub check {
  my $self = shift;
  if (scalar (@{$self->{cpus}}) == 0) {
    $self->overall_check();
  } else {
    # snAgentCpuUtilInterval = 1, 5, 60, 300
    # --lookback can be one of these values, default is 300 (1,5 is a stupid choice)
    $self->opts->override_opt('lookback', 300) if ! $self->opts->lookback;
    foreach (grep { $_->{snAgentCpuUtilInterval} eq $self->opts->lookback} @{$self->{cpus}}) {
      $_->check();
    }
  }
}

sub dump {
  my $self = shift;
  $self->overall_dump();
  foreach (@{$self->{cpus}}) {
    $_->dump();
  }
}

sub overall_check {
  my $self = shift;
  my $errorfound = 0;
  $self->add_info('checking cpus');
  $self->blacklist('c', undef);
  my $info = sprintf 'cpu usage is %.2f%%', $self->{snAgGblCpuUtil1MinAvg};
  $self->add_info($info);
  $self->set_thresholds(warning => 50, critical => 90);
  $self->add_message($self->check_thresholds(
      $self->{snAgGblCpuUtil1MinAvg}), $info);
  $self->add_perfdata(
      label => 'cpu_usage',
      value => $self->{snAgGblCpuUtil1MinAvg},
      uom => '%',
      warning => $self->{warning},
      critical => $self->{critical},
  );
}

sub overall_dump {
  my $self = shift;
  printf "[CPU]\n";
  foreach (qw(snAgGblCpuUtil1SecAvg snAgGblCpuUtil5SecAvg
      snAgGblCpuUtil1MinAvg)) {
    printf "%s: %s\n", $_, $self->{$_};
  }
  printf "\n";
}

sub unix_init {
  my $self = shift;
  my %params = @_;
  my $type = 0;
  foreach ($self->get_snmp_table_objects(
     'UCD-SNMP-MIB', 'laTable')) {
    push(@{$self->{loads}},
        NWC::Foundry::Component::CpuSubsystem::Load->new(%{$_}));
  }
}

sub unix_check {
  my $self = shift;
  my $errorfound = 0;
  $self->add_info('checking loads');
  $self->blacklist('c', '');
  foreach (@{$self->{loads}}) {
    $_->check();
  }
}

sub unix_dump {
  my $self = shift;
  foreach (@{$self->{loads}}) {
    $_->dump();
  }
}


package NWC::Foundry::Component::CpuSubsystem::Cpu;
our @ISA = qw(NWC::Foundry::Component::CpuSubsystem);

use strict;
use constant { OK => 0, WARNING => 1, CRITICAL => 2, UNKNOWN => 3 };

sub new {
  my $class = shift;
  my %params = @_;
  my $self = {
    blacklisted => 0,
    info => undef,
    extendedinfo => undef,
  };
  foreach (qw(snAgentCpuUtilSlotNum snAgentCpuUtilCpuId 
      snAgentCpuUtilInterval snAgentCpuUtilValue
      snAgentCpuUtilPercent snAgentCpuUtil100thPercent)) {
    $self->{$_} = $params{$_};
  }
  bless $self, $class;
  # newer mibs have snAgentCpuUtilPercent and snAgentCpuUtil100thPercent
  # snAgentCpuUtilValue is deprecated
  $self->{snAgentCpuUtilValue} = $self->{snAgentCpuUtil100thPercent} / 100
      if defined $self->{snAgentCpuUtil100thPercent};
  # if it is an old mib, watch out. snAgentCpuUtilValue is 100th of a percent
  # but it seems that sometimes in reality it is percent
  $self->{snAgentCpuUtilValue} = $self->{snAgentCpuUtilValue} / 100
      if $self->{snAgentCpuUtilValue} > 100;
  return $self;
}

sub check {
  my $self = shift;
  my $errorfound = 0;
  $self->blacklist('c', undef);
  my $info = sprintf 'cpu %s usage is %.2f', $self->{snAgentCpuUtilSlotNum}, $self->{snAgentCpuUtilValue};
  $self->add_info($info);
  $self->set_thresholds(warning => 80, critical => 90);
  $self->add_message($self->check_thresholds($self->{snAgentCpuUtilValue}), $info);
  $self->add_perfdata(
      label => 'cpu_'.$self->{snAgentCpuUtilSlotNum},
      value => $self->{snAgentCpuUtilValue},
      uom => '%',
      warning => $self->{warning},
      critical => $self->{critical},
  );
}

sub dump {
  my $self = shift;
  printf "[CPU_%s]\n", $self->{snAgentCpuUtilSlotNum};
  foreach (qw(snAgentCpuUtilSlotNum snAgentCpuUtilCpuId 
      snAgentCpuUtilInterval snAgentCpuUtilValue
      snAgentCpuUtilPercent snAgentCpuUtil100thPercent)) {
    printf "%s: %s\n", $_, $self->{$_};
  }
  printf "info: %s\n", $self->{info} || "unchecked";
  printf "\n";
}


package NWC::Foundry::Component::CpuSubsystem::Load;
our @ISA = qw(NWC::Foundry::Component::CpuSubsystem);

use strict;
use constant { OK => 0, WARNING => 1, CRITICAL => 2, UNKNOWN => 3 };

sub new {
  my $class = shift;
  my %params = @_;
  my $self = {
    blacklisted => 0,
    info => undef,
    extendedinfo => undef,
  };
  foreach my $param (qw(laIndex laNames laLoad laConfig laLoadFloat 
      laErrorFlag laErrMessage)) {
    $self->{$param} = $params{$param};
  }
  bless $self, $class;
  return $self;
}

sub check {
  my $self = shift;
  my $errorfound = 0;
  $self->blacklist('c', undef);
  my $info = sprintf '%s is %.2f', lc $self->{laNames}, $self->{laLoadFloat};
  $self->add_info($info);
  $self->set_thresholds(warning => $self->{laConfig},
      critical => $self->{laConfig});
  $self->add_message($self->check_thresholds($self->{laLoadFloat}), $info);
  $self->add_perfdata(
      label => lc $self->{laNames},
      value => $self->{laLoadFloat},
      warning => $self->{warning},
      critical => $self->{critical},
  );
}

sub dump {
  my $self = shift;
  printf "[LOAD_%s]\n", lc $self->{laNames};
  foreach (qw(laIndex laNames laLoad laConfig laLoadFloat 
      laErrorFlag laErrMessage)) {
    printf "%s: %s\n", $_, $self->{$_};
  }
  printf "info: %s\n", $self->{info};
  printf "\n";
}

package NWC::Foundry::Component::EnvironmentalSubsystem;
our @ISA = qw(NWC::Foundry);

use strict;
use constant { OK => 0, WARNING => 1, CRITICAL => 2, UNKNOWN => 3 };

sub new {
  my $class = shift;
  my %params = @_;
  my $self = {
    runtime => $params{runtime},
    rawdata => $params{rawdata},
    method => $params{method},
    condition => $params{condition},
    status => $params{status},
    powersupply_subsystem => undef,
    fan_subsystem => undef,
    temperature_subsystem => undef,
    blacklisted => 0,
    info => undef,
    extendedinfo => undef,
  };
  bless $self, $class;
  $self->init(%params);
  return $self;
}

sub init {
  my $self = shift;
  my %params = @_;
  $self->{powersupply_subsystem} =
      NWC::Foundry::Component::PowersupplySubsystem->new(%params);
  $self->{fan_subsystem} =
      NWC::Foundry::Component::FanSubsystem->new(%params);
  $self->{temperature_subsystem} =
      NWC::Foundry::Component::TemperatureSubsystem->new(%params);
}

sub check {
  my $self = shift;
  my $errorfound = 0;
  $self->{powersupply_subsystem}->check();
  $self->{fan_subsystem}->check();
  $self->{temperature_subsystem}->check();
  if (! $self->check_messages()) {
    $self->add_message(OK, "environmental hardware working fine");
  }
}

sub dump {
  my $self = shift;
  $self->{powersupply_subsystem}->dump();
  $self->{fan_subsystem}->dump();
  $self->{temperature_subsystem}->dump();
}


package NWC::Foundry::Component::PowersupplySubsystem;
our @ISA = qw(NWC::Foundry::Component::EnvironmentalSubsystem);

use strict;
use constant { OK => 0, WARNING => 1, CRITICAL => 2, UNKNOWN => 3 };

sub new {
  my $class = shift;
  my %params = @_;
  my $self = {
    supplies => [],
    blacklisted => 0,
    info => undef,
    extendedinfo => undef,
  };
  bless $self, $class;
  $self->init(%params);
  return $self;
}

sub init {
  my $self = shift;
  foreach ($self->get_snmp_table_objects(
      'FOUNDRY-SN-AGENT-MIB', 'snChasPwrSupplyTable')) {
    push(@{$self->{supplies}},
        NWC::Foundry::Component::PowersupplySubsystem::Powersupply->new(%{$_}));
  }
}

sub check {
  my $self = shift;
  my $errorfound = 0;
  $self->add_info('checking supplies');
  $self->blacklist('ps', '');
  if (scalar (@{$self->{supplies}}) == 0) {
  } else {
    foreach (@{$self->{supplies}}) {
      $_->check();
    }
  }
}


sub dump {
  my $self = shift;
  foreach (@{$self->{supplies}}) {
    $_->dump();
  }
}


package NWC::Foundry::Component::PowersupplySubsystem::Powersupply;
our @ISA = qw(NWC::Foundry::Component::PowersupplySubsystem);

use strict;
use constant { OK => 0, WARNING => 1, CRITICAL => 2, UNKNOWN => 3 };

sub new {
  my $class = shift;
  my %params = @_;
  my $self = {
    blacklisted => 0,
    info => undef,
    extendedinfo => undef,
  };
  foreach (qw(snChasPwrSupplyIndex snChasPwrSupplyDescription
      snChasPwrSupplyOperStatus)) {
    $self->{$_} = $params{$_};
  }
  bless $self, $class;
  return $self;
}

sub check {
  my $self = shift;
  $self->blacklist('f', $self->{snChasPwrSupplyIndex});
  $self->add_info(sprintf 'powersupply %d is %s',
      $self->{snChasPwrSupplyIndex},
      $self->{snChasPwrSupplyOperStatus});
  if ($self->{snChasPwrSupplyOperStatus} eq 'failure') {
    $self->add_message(CRITICAL, $self->{info});
  }
}

sub dump {
  my $self = shift;
  printf "[PS_%s]\n", $self->{snChasPwrSupplyIndex};
  foreach (qw(snChasPwrSupplyIndex snChasPwrSupplyDescription
      snChasPwrSupplyOperStatus)) {
    printf "%s: %s\n", $_, $self->{$_};
  }
  printf "info: %s\n", $self->{info};
  printf "\n";
}

package NWC::Foundry::Component::FanSubsystem;
our @ISA = qw(NWC::Foundry::Component::EnvironmentalSubsystem);

use strict;
use constant { OK => 0, WARNING => 1, CRITICAL => 2, UNKNOWN => 3 };

sub new {
  my $class = shift;
  my %params = @_;
  my $self = {
    fans => [],
    blacklisted => 0,
    info => undef,
    extendedinfo => undef,
  };
  bless $self, $class;
  $self->init(%params);
  return $self;
}

sub init {
  my $self = shift;
  foreach ($self->get_snmp_table_objects(
      'FOUNDRY-SN-AGENT-MIB', 'snChasFanTable')) {
    push(@{$self->{fans}},
        NWC::Foundry::Component::FanSubsystem::Fan->new(%{$_}));
  }
}

sub check {
  my $self = shift;
  my $errorfound = 0;
  $self->add_info('checking fans');
  $self->blacklist('ps', '');
  if (scalar (@{$self->{fans}}) == 0) {
  } else {
    foreach (@{$self->{fans}}) {
      $_->check();
    }
  }
}


sub dump {
  my $self = shift;
  foreach (@{$self->{fans}}) {
    $_->dump();
  }
}


package NWC::Foundry::Component::FanSubsystem::Fan;
our @ISA = qw(NWC::Foundry::Component::FanSubsystem);

use strict;
use constant { OK => 0, WARNING => 1, CRITICAL => 2, UNKNOWN => 3 };

sub new {
  my $class = shift;
  my %params = @_;
  my $self = {
    blacklisted => 0,
    info => undef,
    extendedinfo => undef,
  };
  foreach (qw(snChasFanIndex snChasFanDescription
      snChasFanOperStatus)) {
    $self->{$_} = $params{$_};
  }
  bless $self, $class;
  return $self;
}

sub check {
  my $self = shift;
  $self->blacklist('f', $self->{snChasFanIndex});
  $self->add_info(sprintf 'fan %d is %s',
      $self->{snChasFanIndex},
      $self->{snChasFanOperStatus});
  if ($self->{snChasFanOperStatus} eq 'failure') {
    $self->add_message(CRITICAL, $self->{info});
  }
}

sub dump {
  my $self = shift;
  printf "[FAN_%s]\n", $self->{snChasFanIndex};
  foreach (qw(snChasFanIndex snChasFanDescription
      snChasFanOperStatus)) {
    printf "%s: %s\n", $_, $self->{$_};
  }
  printf "info: %s\n", $self->{info};
  printf "\n";
}

package NWC::Foundry::Component::TemperatureSubsystem;
our @ISA = qw(NWC::Foundry);

use strict;
use constant { OK => 0, WARNING => 1, CRITICAL => 2, UNKNOWN => 3 };

sub new {
  my $class = shift;
  my %params = @_;
  my $self = {
    temperatures => [],
    blacklisted => 0,
    info => undef,
    extendedinfo => undef,
  };
  bless $self, $class;
  $self->init(%params);
  return $self;
}

sub init {
  my $self = shift;
  my %params = @_;
  my $temp = 0;
  foreach ($self->get_snmp_table_objects(
      'FOUNDRY-SN-AGENT-MIB', 'snAgentTempTable')) {
    $_->{snAgentTempSlotNum} ||= $temp++;
    $_->{snAgentTempSensorId} ||= 1;
    push(@{$self->{temperatures}},
        NWC::Foundry::Component::TemperatureSubsystem::Temperature->new(%{$_}));
  }
}

sub check {
  my $self = shift;
  if (scalar (@{$self->{temperatures}}) == 0) {
    $self->overall_check();
  } else {
    foreach (@{$self->{temperatures}}) {
      $_->check();
    }
  }
}

sub dump {
  my $self = shift;
  foreach (@{$self->{temperatures}}) {
    $_->dump();
  }
}


package NWC::Foundry::Component::TemperatureSubsystem::Temperature;
our @ISA = qw(NWC::Foundry::Component::TemperatureSubsystem);

use strict;
use constant { OK => 0, WARNING => 1, CRITICAL => 2, UNKNOWN => 3 };

sub new {
  my $class = shift;
  my %params = @_;
  my $self = {
    blacklisted => 0,
    info => undef,
    extendedinfo => undef,
  };
  foreach (qw(snAgentTempSlotNum snAgentTempSensorId snAgentTempSensorDescr 
      snAgentTempValue)) {
    $self->{$_} = $params{$_};
  }
  $self->{snAgentTempValue} /= 2;
  bless $self, $class;
  return $self;
}

sub check {
  my $self = shift;
  my $errorfound = 0;
  $self->blacklist('t', undef);
  my $info = sprintf 'temperature %s is %.2fC', 
      $self->{snAgentTempSlotNum}, $self->{snAgentTempValue};
  $self->add_info($info);
  $self->set_thresholds(warning => 60, critical => 70);
  $self->add_message($self->check_thresholds($self->{snAgentTempValue}), $info);
  $self->add_perfdata(
      label => 'temperature_'.$self->{snAgentTempSlotNum},
      value => $self->{snAgentTempValue},
      warning => $self->{warning},
      critical => $self->{critical},
  );
}

sub dump {
  my $self = shift;
  printf "[TEMP_%s]\n", $self->{snAgentTempSlotNum};
  foreach (qw(snAgentTempSlotNum snAgentTempSensorId snAgentTempSensorDescr 
      snAgentTempValue)) {
    printf "%s: %s\n", $_, $self->{$_};
  }
  printf "info: %s\n", $self->{info} || "unchecked";
  printf "\n";
}


package NWC::Foundry;

use strict;

use constant { OK => 0, WARNING => 1, CRITICAL => 2, UNKNOWN => 3 };

our @ISA = qw(NWC::Brocade);

sub init {
  my $self = shift;
  my %params = @_;
  $self->{components} = {
      powersupply_subsystem => undef,
      fan_subsystem => undef,
      temperature_subsystem => undef,
      cpu_subsystem => undef,
  };
  $self->{serial} = 'unknown';
  $self->{product} = 'unknown';
  $self->{romversion} = 'unknown';
  if (! $self->check_messages()) {
    if ($self->mode =~ /device::hardware::health/) {
      $self->analyze_environmental_subsystem();
      $self->check_environmental_subsystem();
    } elsif ($self->mode =~ /device::hardware::load/) {
      $self->analyze_cpu_subsystem();
      $self->check_cpu_subsystem();
    } elsif ($self->mode =~ /device::hardware::memory/) {
      $self->analyze_mem_subsystem();
      $self->check_mem_subsystem();
    }
  }
}

sub analyze_environmental_subsystem {
  my $self = shift;
  $self->{components}->{environmental_subsystem} =
      NWC::Foundry::Component::EnvironmentalSubsystem->new();
}

sub analyze_cpu_subsystem {
  my $self = shift;
  $self->{components}->{cpu_subsystem} =
      NWC::Foundry::Component::CpuSubsystem->new();
}

sub analyze_mem_subsystem {
  my $self = shift;
  $self->{components}->{mem_subsystem} =
      NWC::Foundry::Component::MemSubsystem->new();
}

package NWC::Bluecoat;

use strict;

use constant { OK => 0, WARNING => 1, CRITICAL => 2, UNKNOWN => 3 };

our @ISA = qw(NWC::Device);

use constant trees => (
  '1.3.6.1.2.1.1', # RFC1213-MIB
  '1.3.6.1.2.1.10.33', # RS-232-MIB
  '1.3.6.1.2.1.22.1.1', # SNMP-REPEATER-MIB
  '1.3.6.1.2.1.25.1', # HOST-RESOURCES-MIB
  '1.3.6.1.2.1.30', # IANAifType-MIB
  '1.3.6.1.2.1.31', # IF-MIB
  '1.3.6.1.2.1.65', # WWW-MIB
  '1.3.6.1.3.25.17', # PROXY-MIB
  '1.3.6.1.4.1.3417', # BLUECOAT-MIB
  '1.3.6.1.4.1.3417', # BLUECOAT-MIB
  '1.3.6.1.4.1.3417', # BLUECOAT-MIB
  '1.3.6.1.4.1.3417.2.1', # SENSOR-MIB
  '1.3.6.1.4.1.3417.2.10', # BLUECOAT-AV-MIB
  '1.3.6.1.4.1.3417.2.2', # DISK-MIB
  '1.3.6.1.4.1.3417.2.3', # ATTACK-MIB
  '1.3.6.1.4.1.3417.2.4', # USAGE-MIB
  '1.3.6.1.4.1.3417.2.5', # WCCP-MIB
  '1.3.6.1.4.1.3417.2.6', # POLICY-MIB
  '1.3.6.1.4.1.3417.2.8', # SYSTEM-RESOURCES-MIB
  '1.3.6.1.4.1.3417.2.9', # BLUECOAT-HOST-RESOURCES-MIB
  '1.3.6.1.4.1.99.12.33', # SR-COMMUNITY-MIB
  '1.3.6.1.4.1.99.12.35', # USM-TARGET-TAG-MIB
  '1.3.6.1.4.1.99.12.36', # TGT-ADDRESS-MASK-MIB
  '1.3.6.1.4.1.99.42', # MLM-MIB
  '1.3.6.1.6.3.1', # SNMPv2-MIB
  '1.3.6.1.6.3.10', # SNMP-FRAMEWORK-MIB
  '1.3.6.1.6.3.11', # SNMP-MPD-MIB
  '1.3.6.1.6.3.1133', # COMMUNITY-MIB
  '1.3.6.1.6.3.1134', # V2ADMIN-MIB
  '1.3.6.1.6.3.1135', # USEC-MIB
  '1.3.6.1.6.3.12', # SNMP-TARGET-MIB
  '1.3.6.1.6.3.13', # SNMP-NOTIFICATION-MIB
  '1.3.6.1.6.3.14', # SNMP-PROXY-MIB
  '1.3.6.1.6.3.15', # SNMP-USER-BASED-SM-MIB
  '1.3.6.1.6.3.16', # SNMP-VIEW-BASED-ACM-MIB
  '1.3.6.1.6.3.18', # SNMP-COMMUNITY-MIB
);

sub init {
  my $self = shift;
  my %params = @_;
  $self->SUPER::init(%params);
  if ($self->{productname} =~ /Blue.*Coat.*SG\d+/i) {
    # product ProxySG  Blue Coat SG600
# iso.3.6.1.4.1.3417.2.11.1.3.0 = STRING: "Version: SGOS 5.5.8.1, Release id: 78642 Proxy Edition"
    bless $self, 'NWC::SGOS';
    $self->debug('using NWC::SGOS');
    $self->init();
  } elsif ($self->{productname} =~ /Blue.*Coat.*AV\d+/i) {
    # product Blue Coat AV510 Series, ProxyAV Version: 3.5.1.1, Release id: 111017
    bless $self, 'NWC::AVOS';
    $self->debug('using NWC::AVOS');
    $self->init();
  }
}

$NWC::Device::mibs_and_oids = {
  'MIB-II' => {
      sysDescr => '1.3.6.1.2.1.1.1',
      sysUpTime => '1.3.6.1.2.1.1.3',
      sysName => '1.3.6.1.2.1.1.5',
  },
  'IFMIB' => {
      ifTable => '1.3.6.1.2.1.2.2',
      ifEntry => '1.3.6.1.2.1.2.2.1',
      ifIndex => '1.3.6.1.2.1.2.2.1.1',
      ifDescr => '1.3.6.1.2.1.2.2.1.2',
      ifType => '1.3.6.1.2.1.2.2.1.3',
      ifTypeDefinition => 'IFMIB::ifType',
      ifMtu => '1.3.6.1.2.1.2.2.1.4',
      ifSpeed => '1.3.6.1.2.1.2.2.1.5',
      ifPhysAddress => '1.3.6.1.2.1.2.2.1.6',
      ifAdminStatus => '1.3.6.1.2.1.2.2.1.7',
      ifOperStatus => '1.3.6.1.2.1.2.2.1.8',
      ifLastChange => '1.3.6.1.2.1.2.2.1.9',
      ifInOctets => '1.3.6.1.2.1.2.2.1.10',
      ifInUcastPkts => '1.3.6.1.2.1.2.2.1.11',
      ifInNUcastPkts => '1.3.6.1.2.1.2.2.1.12',
      ifInDiscards => '1.3.6.1.2.1.2.2.1.13',
      ifInErrors => '1.3.6.1.2.1.2.2.1.14',
      ifInUnknownProtos => '1.3.6.1.2.1.2.2.1.15',
      ifOutOctets => '1.3.6.1.2.1.2.2.1.16',
      ifOutUcastPkts => '1.3.6.1.2.1.2.2.1.17',
      ifOutNUcastPkts => '1.3.6.1.2.1.2.2.1.18',
      ifOutDiscards => '1.3.6.1.2.1.2.2.1.19',
      ifOutErrors => '1.3.6.1.2.1.2.2.1.20',
      ifOutQLen => '1.3.6.1.2.1.2.2.1.21',
      ifSpecific => '1.3.6.1.2.1.2.2.1.22',
      ifAdminStatusDefinition => {
          1 => 'up',
          2 => 'down',
          3 => 'testing',
      },
      ifOperStatusDefinition => {
          1 => 'up',
          2 => 'down',
          3 => 'testing',
          4 => 'unknown',
          5 => 'dormant',
          6 => 'notPresent',
          7 => 'lowerLayerDown',
      },
      # INDEX { ifIndex }
      #
      ifXTable => '1.3.6.1.2.1.31.1.1',
      ifXEntry => '1.3.6.1.2.1.31.1.1.1',
      ifName => '1.3.6.1.2.1.31.1.1.1.1',
      ifInMulticastPkts => '1.3.6.1.2.1.31.1.1.1.2',
      ifInBroadcastPkts => '1.3.6.1.2.1.31.1.1.1.3',
      ifOutMulticastPkts => '1.3.6.1.2.1.31.1.1.1.4',
      ifOutBroadcastPkts => '1.3.6.1.2.1.31.1.1.1.5',
      ifHCInOctets => '1.3.6.1.2.1.31.1.1.1.6',
      ifHCInUcastPkts => '1.3.6.1.2.1.31.1.1.1.7',
      ifHCInMulticastPkts => '1.3.6.1.2.1.31.1.1.1.8',
      ifHCInBroadcastPkts => '1.3.6.1.2.1.31.1.1.1.9',
      ifHCOutOctets => '1.3.6.1.2.1.31.1.1.1.10',
      ifHCOutUcastPkts => '1.3.6.1.2.1.31.1.1.1.11',
      ifHCOutMulticastPkts => '1.3.6.1.2.1.31.1.1.1.12',
      ifHCOutBroadcastPkts => '1.3.6.1.2.1.31.1.1.1.13',
      ifLinkUpDownTrapEnable => '1.3.6.1.2.1.31.1.1.1.14',
      ifHighSpeed => '1.3.6.1.2.1.31.1.1.1.15',
      ifPromiscuousMode => '1.3.6.1.2.1.31.1.1.1.16',
      ifConnectorPresent => '1.3.6.1.2.1.31.1.1.1.17',
      ifAlias => '1.3.6.1.2.1.31.1.1.1.18',
      ifCounterDiscontinuityTime => '1.3.6.1.2.1.31.1.1.1.19',
      ifLinkUpDownTrapEnableDefinition => {
          1 => 'enabled',
          2 => 'disabled',
      },
      # ifXEntry AUGMENTS ifEntry
      #
  },
  'CISCO-PROCESS-MIB' => {
      cpmCPUTotalTable => '1.3.6.1.4.1.9.9.109.1.1.1',
      cpmCPUTotalEntry => '1.3.6.1.4.1.9.9.109.1.1.1.1',
      cpmCPUTotalIndex => '1.3.6.1.4.1.9.9.109.1.1.1.1.1',
      cpmCPUTotalPhysicalIndex => '1.3.6.1.4.1.9.9.109.1.1.1.1.2',
      cpmCPUTotal5sec => '1.3.6.1.4.1.9.9.109.1.1.1.1.3',
      cpmCPUTotal1min => '1.3.6.1.4.1.9.9.109.1.1.1.1.4',
      cpmCPUTotal5min => '1.3.6.1.4.1.9.9.109.1.1.1.1.5',
      cpmCPUTotal5secRev => '1.3.6.1.4.1.9.9.109.1.1.1.1.6',
      cpmCPUTotal1minRev => '1.3.6.1.4.1.9.9.109.1.1.1.1.7',
      cpmCPUTotal5minRev => '1.3.6.1.4.1.9.9.109.1.1.1.1.8',
      cpmCPUMonInterval => '1.3.6.1.4.1.9.9.109.1.1.1.1.9',
      cpmCPUTotalMonIntervalDefinition => '1.3.6.1.4.1.9.9.109.1.1.1.1.10',
      cpmCPUInterruptMonIntervalDefinition => '1.3.6.1.4.1.9.9.109.1.1.1.1.11',
      # INDEX { cpmCPUTotalIndex }
  },
  'CISCO-MEMORY-POOL-MIB' => {
      ciscoMemoryPoolTable => '1.3.6.1.4.1.9.9.48.1.1',
      ciscoMemoryPoolEntry => '1.3.6.1.4.1.9.9.48.1.1.1',
      ciscoMemoryPoolType => '1.3.6.1.4.1.9.9.48.1.1.1.1',
      ciscoMemoryPoolName => '1.3.6.1.4.1.9.9.48.1.1.1.2',
      ciscoMemoryPoolAlternate => '1.3.6.1.4.1.9.9.48.1.1.1.3',
      ciscoMemoryPoolValid => '1.3.6.1.4.1.9.9.48.1.1.1.4',
      ciscoMemoryPoolUsed => '1.3.6.1.4.1.9.9.48.1.1.1.5',
      ciscoMemoryPoolFree => '1.3.6.1.4.1.9.9.48.1.1.1.6',
      ciscoMemoryPoolLargestFree => '1.3.6.1.4.1.9.9.48.1.1.1.7',
      # INDEX { ciscoMemoryPoolType }
  },
  'CISCO-ENVMON-MIB' => {
     ciscoEnvMonFanStatusTable => '1.3.6.1.4.1.9.9.13.1.4',
     ciscoEnvMonFanStatusEntry => '1.3.6.1.4.1.9.9.13.1.4.1',
     ciscoEnvMonFanStatusIndex => '1.3.6.1.4.1.9.9.13.1.4.1.1',
     ciscoEnvMonFanStatusDescr => '1.3.6.1.4.1.9.9.13.1.4.1.2',
     ciscoEnvMonFanState => '1.3.6.1.4.1.9.9.13.1.4.1.3',
     ciscoEnvMonFanStateDefinition => 'CISCO-ENVMON-MIB::ciscoEnvMonState',
     # INDEX { ciscoEnvMonFanStatusIndex }
     ciscoEnvMonSupplyStatusTable => '1.3.6.1.4.1.9.9.13.1.5',
     ciscoEnvMonSupplyStatusEntry => '1.3.6.1.4.1.9.9.13.1.5.1',
     ciscoEnvMonSupplyStatusIndex => '1.3.6.1.4.1.9.9.13.1.5.1.1',
     ciscoEnvMonSupplyStatusDescr => '1.3.6.1.4.1.9.9.13.1.5.1.2',
     ciscoEnvMonSupplyState => '1.3.6.1.4.1.9.9.13.1.5.1.3',
     ciscoEnvMonSupplySource => '1.3.6.1.4.1.9.9.13.1.5.1.4',
     ciscoEnvMonSupplyStateDefinition => 'CISCO-ENVMON-MIB::ciscoEnvMonState',
     # INDEX { ciscoEnvMonSupplyStatusIndex }
     ciscoEnvMonTemperatureStatusTable => '1.3.6.1.4.1.9.9.13.1.3',
     ciscoEnvMonTemperatureStatusEntry => '1.3.6.1.4.1.9.9.13.1.3.1',
     ciscoEnvMonTemperatureStatusIndex => '1.3.6.1.4.1.9.9.13.1.3.1.1',
     ciscoEnvMonTemperatureStatusDescr => '1.3.6.1.4.1.9.9.13.1.3.1.2',
     ciscoEnvMonTemperatureStatusValue => '1.3.6.1.4.1.9.9.13.1.3.1.3',
     ciscoEnvMonTemperatureThreshold => '1.3.6.1.4.1.9.9.13.1.3.1.4',
     ciscoEnvMonTemperatureLastShutdown => '1.3.6.1.4.1.9.9.13.1.3.1.5',
     ciscoEnvMonTemperatureState => '1.3.6.1.4.1.9.9.13.1.3.1.6',
     ciscoEnvMonTemperatureStateDefinition => 'CISCO-ENVMON-MIB::ciscoEnvMonState',
     # INDEX { ciscoEnvMonTemperatureStatusIndex }
     ciscoEnvMonVoltageStatusTable => '1.3.6.1.4.1.9.9.13.1.2',
     ciscoEnvMonVoltageStatusEntry => '1.3.6.1.4.1.9.9.13.1.2.1',
     ciscoEnvMonVoltageStatusIndex => '1.3.6.1.4.1.9.9.13.1.2.1.1',
     ciscoEnvMonVoltageStatusDescr => '1.3.6.1.4.1.9.9.13.1.2.1.2',
     ciscoEnvMonVoltageStatusValue => '1.3.6.1.4.1.9.9.13.1.2.1.3',
     ciscoEnvMonVoltageThresholdLow => '1.3.6.1.4.1.9.9.13.1.2.1.4',
     ciscoEnvMonVoltageThresholdHigh => '1.3.6.1.4.1.9.9.13.1.2.1.5',
     ciscoEnvMonVoltageLastShutdown => '1.3.6.1.4.1.9.9.13.1.2.1.6',
     ciscoEnvMonVoltageState => '1.3.6.1.4.1.9.9.13.1.2.1.7',
     ciscoEnvMonVoltageStateDefinition => 'CISCO-ENVMON-MIB::ciscoEnvMonState',
     # INDEX { ciscoEnvMonVoltageStatusIndex }
  },
  'CISCO-HSRP-MIB' => {
      cHsrpGrpTable => '1.3.6.1.4.1.9.9.106.1.2.1',
      cHsrpGrpEntry => '1.3.6.1.4.1.9.9.106.1.2.1.1',
      cHsrpGrpNumber => '1.3.6.1.4.1.9.9.106.1.2.1.1.1',
      cHsrpGrpAuth => '1.3.6.1.4.1.9.9.106.1.2.1.1.2',
      cHsrpGrpPriority => '1.3.6.1.4.1.9.9.106.1.2.1.1.3',
      cHsrpGrpPreempt => '1.3.6.1.4.1.9.9.106.1.2.1.1.4',
      cHsrpGrpPreemptDelay => '1.3.6.1.4.1.9.9.106.1.2.1.1.5',
      cHsrpGrpUseConfiguredTimers => '1.3.6.1.4.1.9.9.106.1.2.1.1.6',
      cHsrpGrpConfiguredHelloTime => '1.3.6.1.4.1.9.9.106.1.2.1.1.7',
      cHsrpGrpConfiguredHoldTime => '1.3.6.1.4.1.9.9.106.1.2.1.1.8',
      cHsrpGrpLearnedHelloTime => '1.3.6.1.4.1.9.9.106.1.2.1.1.9',
      cHsrpGrpLearnedHoldTime => '1.3.6.1.4.1.9.9.106.1.2.1.1.10',
      cHsrpGrpVirtualIpAddr => '1.3.6.1.4.1.9.9.106.1.2.1.1.11',
      cHsrpGrpUseConfigVirtualIpAddr => '1.3.6.1.4.1.9.9.106.1.2.1.1.12',
      cHsrpGrpActiveRouter => '1.3.6.1.4.1.9.9.106.1.2.1.1.13',
      cHsrpGrpStandbyRouter => '1.3.6.1.4.1.9.9.106.1.2.1.1.14',
      cHsrpGrpStandbyState => '1.3.6.1.4.1.9.9.106.1.2.1.1.15',
      cHsrpGrpStandbyStateDefinition => 'CISCO-HSRP-MIB::HsrpState',
      cHsrpGrpVirtualMacAddr => '1.3.6.1.4.1.9.9.106.1.2.1.1.16',
      cHsrpGrpEntryRowStatus => '1.3.6.1.4.1.9.9.106.1.2.1.1.17',
      cHsrpGrpEntryRowStatusDefinition => 'SNMPv2-TC-v1::RowStatus',
      # INDEX { ifIndex, cHsrpGrpNumber }
  },
  'OLD-CISCO-CPU-MIB' => {
      'avgBusy1' => '1.3.6.1.4.1.9.2.1.57.0',
      'avgBusy5' => '1.3.6.1.4.1.9.2.1.58.0',
      'busyPer' => '1.3.6.1.4.1.9.2.1.56.0',
      'idleCount' => '1.3.6.1.4.1.9.2.1.59.0',
      'idleWired' => '1.3.6.1.4.1.9.2.1.60.0',
  },
  'CISCO-SYSTEM-EXT-MIB' => {
      cseSysCPUUtilization => '1.3.6.1.4.1.9.9.305.1.1.1.0',
      cseSysMemoryUtilization => '1.3.6.1.4.1.9.9.305.1.1.2.0',
      cseSysConfLastChange => '1.3.6.1.4.1.9.9.305.1.1.3.0',
      cseSysAutoSync => '1.3.6.1.4.1.9.9.305.1.1.4.0',
      cseSysAutoSyncState => '1.3.6.1.4.1.9.9.305.1.1.5.0',
      cseWriteErase => '1.3.6.1.4.1.9.9.305.1.1.6.0',
      cseSysConsolePortStatus => '1.3.6.1.4.1.9.9.305.1.1.7.0',
      cseSysTelnetServiceActivation => '1.3.6.1.4.1.9.9.305.1.1.8.0',
      cseSysFIPSModeActivation => '1.3.6.1.4.1.9.9.305.1.1.9.0',
      cseSysUpTime => '1.3.6.1.4.1.9.9.305.1.1.10.0',
  },
  'CISCO-ENTITY-SENSOR-MIB' => {
      entSensorValueTable => '1.3.6.1.4.1.9.9.91.1.1.1',
      entSensorValueEntry => '1.3.6.1.4.1.9.9.91.1.1.1.1',
      entSensorType => '1.3.6.1.4.1.9.9.91.1.1.1.1.1',
      entSensorTypeDefinition => 'CISCO-ENTITY-SENSOR-MIB::SensorDataType',
      entSensorScale => '1.3.6.1.4.1.9.9.91.1.1.1.1.2',
      entSensorScaleDefinition => 'CISCO-ENTITY-SENSOR-MIB::SensorDataScale',
      entSensorPrecision => '1.3.6.1.4.1.9.9.91.1.1.1.1.3',
      entSensorValue => '1.3.6.1.4.1.9.9.91.1.1.1.1.4',
      entSensorStatus => '1.3.6.1.4.1.9.9.91.1.1.1.1.5',
      entSensorStatusDefinition => 'CISCO-ENTITY-SENSOR-MIB::SensorStatus',
      entSensorValueTimeStamp => '1.3.6.1.4.1.9.9.91.1.1.1.1.6',
      entSensorValueUpdateRate => '1.3.6.1.4.1.9.9.91.1.1.1.1.7',
      entSensorMeasuredEntity => '1.3.6.1.4.1.9.9.91.1.1.1.1.8',
      entSensorThresholdTable => '1.3.6.1.4.1.9.9.91.1.2.1',
      entSensorThresholdEntry => '1.3.6.1.4.1.9.9.91.1.2.1.1',
      entSensorThresholdIndex => '1.3.6.1.4.1.9.9.91.1.2.1.1.1',
      entSensorThresholdSeverity => '1.3.6.1.4.1.9.9.91.1.2.1.1.2',
      entSensorThresholdSeverityDefinition => 'CISCO-ENTITY-SENSOR-MIB::SensorThresholdSeverity',
      entSensorThresholdRelation => '1.3.6.1.4.1.9.9.91.1.2.1.1.3',
      entSensorThresholdRelationDefinition => 'CISCO-ENTITY-SENSOR-MIB::SensorThresholdRelation',
      entSensorThresholdValue => '1.3.6.1.4.1.9.9.91.1.2.1.1.4',
      entSensorThresholdEvaluation => '1.3.6.1.4.1.9.9.91.1.2.1.1.5',
      entSensorThresholdEvaluationDefinition => 'SNMPv2-TC-v1::TruthValue',
      entSensorThresholdNotificationEnable => '1.3.6.1.4.1.9.9.91.1.2.1.1.6',
      entSensorThresholdNotificationEnableDefinition => 'SNMPv2-TC-v1::TruthValue',
  },
  'CISCO-L2L3-INTERFACE-CONFIG-MIB' => {
      cL2L3IfTable => '1.3.6.1.4.1.9.9.151.1.1.1',
      cL2L3IfEntry => '1.3.6.1.4.1.9.9.151.1.1.1.1',
      cL2L3IfModeAdmin => '1.3.6.1.4.1.9.9.151.1.1.1.1.1',
      cL2L3IfModeAdminDefinition => 'CISCO-L2L3-INTERFACE-CONFIG-MIB::CL2L3InterfaceMode',
      cL2L3IfModeOper => '1.3.6.1.4.1.9.9.151.1.1.1.1.2',
      cL2L3IfModeOperDefinition => 'CISCO-L2L3-INTERFACE-CONFIG-MIB::CL2L3InterfaceMode',
  },
  'CISCO-VTP-MIB' => {
      vlanTrunkPortTable => '1.3.6.1.4.1.9.9.46.1.6.1',
      vlanTrunkPortEntry => '1.3.6.1.4.1.9.9.46.1.6.1.1',
      vlanTrunkPortIfIndex => '1.3.6.1.4.1.9.9.46.1.6.1.1.1',
      vlanTrunkPortVlansPruningEligible => '1.3.6.1.4.1.9.9.46.1.6.1.1.10',
      vlanTrunkPortVlansXmitJoined => '1.3.6.1.4.1.9.9.46.1.6.1.1.11',
      vlanTrunkPortVlansRcvJoined => '1.3.6.1.4.1.9.9.46.1.6.1.1.12',
      vlanTrunkPortDynamicState => '1.3.6.1.4.1.9.9.46.1.6.1.1.13',
      vlanTrunkPortDynamicStatus => '1.3.6.1.4.1.9.9.46.1.6.1.1.14',
      vlanTrunkPortDynamicStatusDefinition => {
          1 => 'trunking',
          2 => 'notTrunking',
      },
      vlanTrunkPortVtpEnabled => '1.3.6.1.4.1.9.9.46.1.6.1.1.15',
      vlanTrunkPortEncapsulationOperType => '1.3.6.1.4.1.9.9.46.1.6.1.1.16',
      vlanTrunkPortVlansEnabled2k => '1.3.6.1.4.1.9.9.46.1.6.1.1.17',
      vlanTrunkPortVlansEnabled3k => '1.3.6.1.4.1.9.9.46.1.6.1.1.18',
      vlanTrunkPortVlansEnabled4k => '1.3.6.1.4.1.9.9.46.1.6.1.1.19',
      vlanTrunkPortManagementDomain => '1.3.6.1.4.1.9.9.46.1.6.1.1.2',
      vtpVlansPruningEligible2k => '1.3.6.1.4.1.9.9.46.1.6.1.1.20',
      vtpVlansPruningEligible3k => '1.3.6.1.4.1.9.9.46.1.6.1.1.21',
      vtpVlansPruningEligible4k => '1.3.6.1.4.1.9.9.46.1.6.1.1.22',
      vlanTrunkPortVlansXmitJoined2k => '1.3.6.1.4.1.9.9.46.1.6.1.1.23',
      vlanTrunkPortVlansXmitJoined3k => '1.3.6.1.4.1.9.9.46.1.6.1.1.24',
      vlanTrunkPortVlansXmitJoined4k => '1.3.6.1.4.1.9.9.46.1.6.1.1.25',
      vlanTrunkPortVlansRcvJoined2k => '1.3.6.1.4.1.9.9.46.1.6.1.1.26',
      vlanTrunkPortVlansRcvJoined3k => '1.3.6.1.4.1.9.9.46.1.6.1.1.27',
      vlanTrunkPortVlansRcvJoined4k => '1.3.6.1.4.1.9.9.46.1.6.1.1.28',
      vlanTrunkPortDot1qTunnel => '1.3.6.1.4.1.9.9.46.1.6.1.1.29',
      vlanTrunkPortEncapsulationType => '1.3.6.1.4.1.9.9.46.1.6.1.1.3',
      vlanTrunkPortVlansActiveFirst2k => '1.3.6.1.4.1.9.9.46.1.6.1.1.30',
      vlanTrunkPortVlansActiveSecond2k => '1.3.6.1.4.1.9.9.46.1.6.1.1.31',
      vlanTrunkPortVlansEnabled => '1.3.6.1.4.1.9.9.46.1.6.1.1.4',
      vlanTrunkPortNativeVlan => '1.3.6.1.4.1.9.9.46.1.6.1.1.5',
      vlanTrunkPortRowStatus => '1.3.6.1.4.1.9.9.46.1.6.1.1.6',
      vlanTrunkPortInJoins => '1.3.6.1.4.1.9.9.46.1.6.1.1.7',
      vlanTrunkPortOutJoins => '1.3.6.1.4.1.9.9.46.1.6.1.1.8',
      vlanTrunkPortOldAdverts => '1.3.6.1.4.1.9.9.46.1.6.1.1.9',
  },
  'CISCO-FIREWALL-MIB' => {
      cfwConnectionStatTable => '1.3.6.1.4.1.9.9.147.1.2.2.2',
      cfwConnectionStatEntry => '1.3.6.1.4.1.9.9.147.1.2.2.2.1',
      cfwConnectionStatService => '1.3.6.1.4.1.9.9.147.1.2.2.2.1.1',
      cfwConnectionStatServiceDefinition => 'CISCO-FIREWALL-MIB::Services',
      cfwConnectionStatType => '1.3.6.1.4.1.9.9.147.1.2.2.2.1.2',
      cfwConnectionStatDescription => '1.3.6.1.4.1.9.9.147.1.2.2.2.1.3',
      cfwConnectionStatCount => '1.3.6.1.4.1.9.9.147.1.2.2.2.1.4', #Counter
      cfwConnectionStatValue => '1.3.6.1.4.1.9.9.147.1.2.2.2.1.5', #Gauge
  },
  'AIRESPACE-SWITCHING-MIB' => {
      bsnSwitching => '1.3.6.1.4.1.14179.1',
      agentInfoGroup => '1.3.6.1.4.1.14179.1.1',
      agentInventoryGroup => '1.3.6.1.4.1.14179.1.1.1',
      agentInventorySysDescription => '1.3.6.1.4.1.14179.1.1.1.1',
      agentInventoryOperatingSystem => '1.3.6.1.4.1.14179.1.1.1.10',
      agentInventoryManufacturerName => '1.3.6.1.4.1.14179.1.1.1.12',
      agentInventoryProductName => '1.3.6.1.4.1.14179.1.1.1.13',
      agentInventoryProductVersion => '1.3.6.1.4.1.14179.1.1.1.14',
      agentInventoryIsGigECardPresent => '1.3.6.1.4.1.14179.1.1.1.15',
      agentInventoryIsCryptoCardPresent => '1.3.6.1.4.1.14179.1.1.1.16',
      agentInventoryIsForeignAPSupported => '1.3.6.1.4.1.14179.1.1.1.17',
      agentInventoryMaxNumberOfAPsSupported => '1.3.6.1.4.1.14179.1.1.1.18',
      agentInventoryIsCryptoCard2Present => '1.3.6.1.4.1.14179.1.1.1.19',
      agentInventoryMachineType => '1.3.6.1.4.1.14179.1.1.1.2',
      agentInventoryFipsModeEnabled => '1.3.6.1.4.1.14179.1.1.1.20',
      agentInventoryMachineModel => '1.3.6.1.4.1.14179.1.1.1.3',
      agentInventorySerialNumber => '1.3.6.1.4.1.14179.1.1.1.4',
      agentInventoryMaintenanceLevel => '1.3.6.1.4.1.14179.1.1.1.6',
      agentInventoryBurnedInMacAddress => '1.3.6.1.4.1.14179.1.1.1.9',
      agentTrapLogGroup => '1.3.6.1.4.1.14179.1.1.2',
      agentTrapLogTotal => '1.3.6.1.4.1.14179.1.1.2.1',
      agentApCoverageProfileFailTrapCount => '1.3.6.1.4.1.14179.1.1.2.10',
      agentTrapLogTotalSinceLastViewed => '1.3.6.1.4.1.14179.1.1.2.3',

      agentTrapLogTable => '1.3.6.1.4.1.14179.1.1.2.4',
      agentTrapLogEntry => '1.3.6.1.4.1.14179.1.1.2.4.1',
      agentTrapLogIndex => '1.3.6.1.4.1.14179.1.1.2.4.1.1',
      agentTrapLogSystemTime => '1.3.6.1.4.1.14179.1.1.2.4.1.2',
      agentTrapLogTrap => '1.3.6.1.4.1.14179.1.1.2.4.1.22',

      agentRadioUpDownTrapCount => '1.3.6.1.4.1.14179.1.1.2.5',
      agentApAssociateDisassociateTrapCount => '1.3.6.1.4.1.14179.1.1.2.6',
      agentApLoadProfileFailTrapCount => '1.3.6.1.4.1.14179.1.1.2.7',
      agentApNoiseProfileFailTrapCount => '1.3.6.1.4.1.14179.1.1.2.8',
      agentApInterferenceProfileFailTrapCount => '1.3.6.1.4.1.14179.1.1.2.9',
      agentSwitchInfoGroup => '1.3.6.1.4.1.14179.1.1.3',
      agentSwitchInfoLwappTransportMode => '1.3.6.1.4.1.14179.1.1.3.1',
      agentSwitchInfoPowerSupply1Present => '1.3.6.1.4.1.14179.1.1.3.2',
      agentSwitchInfoPowerSupply1PresentDefinition => {
          0 => 'false',
          1 => 'true',
      },
      agentSwitchInfoPowerSupply1Operational => '1.3.6.1.4.1.14179.1.1.3.3',
      agentSwitchInfoPowerSupply1OperationalDefinition => {
          0 => 'false',
          1 => 'true',
      },
      agentSwitchInfoPowerSupply2Present => '1.3.6.1.4.1.14179.1.1.3.4',
      agentSwitchInfoPowerSupply2PresentDefinition => {
          0 => 'false',
          1 => 'true',
      },
      agentSwitchInfoPowerSupply2Operational => '1.3.6.1.4.1.14179.1.1.3.5',
      agentSwitchInfoPowerSupply2OperationalDefinition => {
          0 => 'false',
          1 => 'true',
      },
      agentProductGroup => '1.3.6.1.4.1.14179.1.1.4',
      productGroup1 => '1.3.6.1.4.1.14179.1.1.4.1',
      productGroup2 => '1.3.6.1.4.1.14179.1.1.4.2',
      productGroup3 => '1.3.6.1.4.1.14179.1.1.4.3',
      productGroup4 => '1.3.6.1.4.1.14179.1.1.4.4',
      agentResourceInfoGroup => '1.3.6.1.4.1.14179.1.1.5',
      agentCurrentCPUUtilization => '1.3.6.1.4.1.14179.1.1.5.1.0',
      agentTotalMemory => '1.3.6.1.4.1.14179.1.1.5.2.0',
      agentFreeMemory => '1.3.6.1.4.1.14179.1.1.5.3.0',
      agentWcpInfoGroup => '1.3.6.1.4.1.14179.1.1.6',
      agentWcpDeviceName => '1.3.6.1.4.1.14179.1.1.6.1',
      agentWcpSlotNumber => '1.3.6.1.4.1.14179.1.1.6.2',
      agentWcpPortNumber => '1.3.6.1.4.1.14179.1.1.6.3',
      agentWcpPeerPortNumber => '1.3.6.1.4.1.14179.1.1.6.4',
      agentWcpPeerIpAddress => '1.3.6.1.4.1.14179.1.1.6.5',
      agentWcpControllerTableChecksum => '1.3.6.1.4.1.14179.1.1.6.6',

      agentWcpControllerInfoTable => '1.3.6.1.4.1.14179.1.1.6.7',
      agentWcpControllerInfoEntry => '1.3.6.1.4.1.14179.1.1.6.7.1',
      agentWcpControllerInfoSlotNumber => '1.3.6.1.4.1.14179.1.1.6.7.1.1',
      agentWcpControllerInfoIpAddress => '1.3.6.1.4.1.14179.1.1.6.7.1.10',
      agentWcpControllerInfoPortNumber => '1.3.6.1.4.1.14179.1.1.6.7.1.2',

      agentConfigGroup => '1.3.6.1.4.1.14179.1.2',
      agentCLIConfigGroup => '1.3.6.1.4.1.14179.1.2.1',

      agentLoginSessionTable => '1.3.6.1.4.1.14179.1.2.1.1',
      agentLoginSessionEntry => '1.3.6.1.4.1.14179.1.2.1.1.1',
      agentLoginSessionIndex => '1.3.6.1.4.1.14179.1.2.1.1.1.1',
      agentLoginSessionUserName => '1.3.6.1.4.1.14179.1.2.1.1.1.2',
      agentLoginSessionStatus => '1.3.6.1.4.1.14179.1.2.1.1.1.26',
      agentLoginSessionIPAddress => '1.3.6.1.4.1.14179.1.2.1.1.1.3',
      agentLoginSessionConnectionType => '1.3.6.1.4.1.14179.1.2.1.1.1.4',
      agentLoginSessionIdleTime => '1.3.6.1.4.1.14179.1.2.1.1.1.5',
      agentLoginSessionSessionTime => '1.3.6.1.4.1.14179.1.2.1.1.1.6',

      agentTelnetConfigGroup => '1.3.6.1.4.1.14179.1.2.1.2',
      agentTelnetLoginTimeout => '1.3.6.1.4.1.14179.1.2.1.2.1',
      agentTelnetMaxSessions => '1.3.6.1.4.1.14179.1.2.1.2.2',
      agentTelnetAllowNewMode => '1.3.6.1.4.1.14179.1.2.1.2.3',
      agentSSHAllowNewMode => '1.3.6.1.4.1.14179.1.2.1.2.4',
      agentSerialGroup => '1.3.6.1.4.1.14179.1.2.1.5',
      agentSerialTimeout => '1.3.6.1.4.1.14179.1.2.1.5.1',
      agentSerialBaudrate => '1.3.6.1.4.1.14179.1.2.1.5.2',
      agentSerialCharacterSize => '1.3.6.1.4.1.14179.1.2.1.5.3',
      agentSerialHWFlowControlMode => '1.3.6.1.4.1.14179.1.2.1.5.4',
      agentSerialStopBits => '1.3.6.1.4.1.14179.1.2.1.5.5',
      agentSerialParityType => '1.3.6.1.4.1.14179.1.2.1.5.6',
      agentDot3adAggPortTable => '1.3.6.1.4.1.14179.1.2.11',
      agentDot3adAggPortEntry => '1.3.6.1.4.1.14179.1.2.11.1',
      agentDot3adAggPort => '1.3.6.1.4.1.14179.1.2.11.1.1',
      agentDot3adAggPortLACPMode => '1.3.6.1.4.1.14179.1.2.11.1.21',
      agentPortConfigTable => '1.3.6.1.4.1.14179.1.2.12',
      agentPortConfigEntry => '1.3.6.1.4.1.14179.1.2.12.1',
      agentPortDot1dBasePort => '1.3.6.1.4.1.14179.1.2.12.1.1',
      agentPortClearStats => '1.3.6.1.4.1.14179.1.2.12.1.10',
      agentPortDefaultType => '1.3.6.1.4.1.14179.1.2.12.1.11',
      agentPortType => '1.3.6.1.4.1.14179.1.2.12.1.12',
      agentPortAutoNegAdminStatus => '1.3.6.1.4.1.14179.1.2.12.1.13',
      agentPortDot3FlowControlMode => '1.3.6.1.4.1.14179.1.2.12.1.14',
      agentPortPowerMode => '1.3.6.1.4.1.14179.1.2.12.1.15',
      agentPortGvrpStatus => '1.3.6.1.4.1.14179.1.2.12.1.16',
      agentPortGarpJoinTime => '1.3.6.1.4.1.14179.1.2.12.1.17',
      agentPortGarpLeaveTime => '1.3.6.1.4.1.14179.1.2.12.1.18',
      agentPortGarpLeaveAllTime => '1.3.6.1.4.1.14179.1.2.12.1.19',
      agentPortIfIndex => '1.3.6.1.4.1.14179.1.2.12.1.2',
      agentPortMirrorMode => '1.3.6.1.4.1.14179.1.2.12.1.20',
      agentPortMulticastApplianceMode => '1.3.6.1.4.1.14179.1.2.12.1.21',
      agentPortIanaType => '1.3.6.1.4.1.14179.1.2.12.1.3',
      agentPortSTPMode => '1.3.6.1.4.1.14179.1.2.12.1.4',
      agentPortOperationalStatus => '1.3.6.1.4.1.14179.1.2.12.1.40',
      agentPortSTPState => '1.3.6.1.4.1.14179.1.2.12.1.5',
      agentPortAdminMode => '1.3.6.1.4.1.14179.1.2.12.1.6',
      agentPortPhysicalMode => '1.3.6.1.4.1.14179.1.2.12.1.7',
      agentPortPhysicalStatus => '1.3.6.1.4.1.14179.1.2.12.1.8',
      agentPortLinkTrapMode => '1.3.6.1.4.1.14179.1.2.12.1.9',
      agentInterfaceConfigTable => '1.3.6.1.4.1.14179.1.2.13',
      agentInterfaceConfigEntry => '1.3.6.1.4.1.14179.1.2.13.1',
      agentInterfaceName => '1.3.6.1.4.1.14179.1.2.13.1.1',
      agentInterfaceSecondaryDhcpAddress => '1.3.6.1.4.1.14179.1.2.13.1.10',
      agentInterfaceDhcpProtocol => '1.3.6.1.4.1.14179.1.2.13.1.11',
      agentInterfaceDnsHostName => '1.3.6.1.4.1.14179.1.2.13.1.12',
      agentInterfaceAclName => '1.3.6.1.4.1.14179.1.2.13.1.13',
      agentInterfaceAPManagementFeature => '1.3.6.1.4.1.14179.1.2.13.1.14',
      agentInterfaceActivePortNo => '1.3.6.1.4.1.14179.1.2.13.1.15',
      agentInterfaceBackupPortNo => '1.3.6.1.4.1.14179.1.2.13.1.16',
      agentInterfaceVlanQuarantine => '1.3.6.1.4.1.14179.1.2.13.1.17',
      agentInterfaceVlanId => '1.3.6.1.4.1.14179.1.2.13.1.2',
      agentInterfaceType => '1.3.6.1.4.1.14179.1.2.13.1.3',
      agentInterfaceRowStatus => '1.3.6.1.4.1.14179.1.2.13.1.31',
      agentInterfaceMacAddress => '1.3.6.1.4.1.14179.1.2.13.1.4',
      agentInterfaceIPAddress => '1.3.6.1.4.1.14179.1.2.13.1.5',
      agentInterfaceIPNetmask => '1.3.6.1.4.1.14179.1.2.13.1.6',
      agentInterfaceIPGateway => '1.3.6.1.4.1.14179.1.2.13.1.7',
      agentInterfacePortNo => '1.3.6.1.4.1.14179.1.2.13.1.8',
      agentInterfacePrimaryDhcpAddress => '1.3.6.1.4.1.14179.1.2.13.1.9',
      agentNtpConfigGroup => '1.3.6.1.4.1.14179.1.2.14',
      agentNtpPollingInterval => '1.3.6.1.4.1.14179.1.2.14.1',
      agentNtpServerTable => '1.3.6.1.4.1.14179.1.2.14.2',
      agentNtpServerEntry => '1.3.6.1.4.1.14179.1.2.14.2.1',
      agentNtpServerIndex => '1.3.6.1.4.1.14179.1.2.14.2.1.1',
      agentNtpServerAddress => '1.3.6.1.4.1.14179.1.2.14.2.1.2',
      agentNtpServerRowStatus => '1.3.6.1.4.1.14179.1.2.14.2.1.20',
      agentDhcpConfigGroup => '1.3.6.1.4.1.14179.1.2.15',
      agentDhcpScopeTable => '1.3.6.1.4.1.14179.1.2.15.1',
      agentDhcpScopeEntry => '1.3.6.1.4.1.14179.1.2.15.1.1',
      agentDhcpScopeIndex => '1.3.6.1.4.1.14179.1.2.15.1.1.1',
      agentDhcpScopeDefaultRouterAddress3 => '1.3.6.1.4.1.14179.1.2.15.1.1.10',
      agentDhcpScopeDnsDomainName => '1.3.6.1.4.1.14179.1.2.15.1.1.11',
      agentDhcpScopeDnsServerAddress1 => '1.3.6.1.4.1.14179.1.2.15.1.1.12',
      agentDhcpScopeDnsServerAddress2 => '1.3.6.1.4.1.14179.1.2.15.1.1.13',
      agentDhcpScopeDnsServerAddress3 => '1.3.6.1.4.1.14179.1.2.15.1.1.14',
      agentDhcpScopeNetbiosNameServerAddress1 => '1.3.6.1.4.1.14179.1.2.15.1.1.15',
      agentDhcpScopeNetbiosNameServerAddress2 => '1.3.6.1.4.1.14179.1.2.15.1.1.16',
      agentDhcpScopeNetbiosNameServerAddress3 => '1.3.6.1.4.1.14179.1.2.15.1.1.17',
      agentDhcpScopeState => '1.3.6.1.4.1.14179.1.2.15.1.1.18',
      agentDhcpScopeName => '1.3.6.1.4.1.14179.1.2.15.1.1.2',
      agentDhcpScopeLeaseTime => '1.3.6.1.4.1.14179.1.2.15.1.1.3',
      agentDhcpScopeRowStatus => '1.3.6.1.4.1.14179.1.2.15.1.1.30',
      agentDhcpScopeNetwork => '1.3.6.1.4.1.14179.1.2.15.1.1.4',
      agentDhcpScopeNetmask => '1.3.6.1.4.1.14179.1.2.15.1.1.5',
      agentDhcpScopePoolStartAddress => '1.3.6.1.4.1.14179.1.2.15.1.1.6',
      agentDhcpScopePoolEndAddress => '1.3.6.1.4.1.14179.1.2.15.1.1.7',
      agentDhcpScopeDefaultRouterAddress1 => '1.3.6.1.4.1.14179.1.2.15.1.1.8',
      agentDhcpScopeDefaultRouterAddress2 => '1.3.6.1.4.1.14179.1.2.15.1.1.9',
      agentLagConfigGroup => '1.3.6.1.4.1.14179.1.2.2',
      agentLagConfigCreate => '1.3.6.1.4.1.14179.1.2.2.1',
      agentLagSummaryConfigTable => '1.3.6.1.4.1.14179.1.2.2.2',
      agentLagSummaryConfigEntry => '1.3.6.1.4.1.14179.1.2.2.2.1',
      agentLagSummaryName => '1.3.6.1.4.1.14179.1.2.2.2.1.1',
      agentLagSummaryLagIndex => '1.3.6.1.4.1.14179.1.2.2.2.1.2',
      agentLagSummaryFlushTimer => '1.3.6.1.4.1.14179.1.2.2.2.1.3',
      agentLagSummaryStatus => '1.3.6.1.4.1.14179.1.2.2.2.1.30',
      agentLagSummaryLinkTrap => '1.3.6.1.4.1.14179.1.2.2.2.1.4',
      agentLagSummaryAdminMode => '1.3.6.1.4.1.14179.1.2.2.2.1.5',
      agentLagSummaryStpMode => '1.3.6.1.4.1.14179.1.2.2.2.1.6',
      agentLagSummaryAddPort => '1.3.6.1.4.1.14179.1.2.2.2.1.7',
      agentLagSummaryDeletePort => '1.3.6.1.4.1.14179.1.2.2.2.1.8',
      agentLagSummaryPortsBitMask => '1.3.6.1.4.1.14179.1.2.2.2.1.9',
      agentLagDetailedConfigTable => '1.3.6.1.4.1.14179.1.2.2.3',
      agentLagDetailedConfigEntry => '1.3.6.1.4.1.14179.1.2.2.3.1',
      agentLagDetailedLagIndex => '1.3.6.1.4.1.14179.1.2.2.3.1.1',
      agentLagDetailedIfIndex => '1.3.6.1.4.1.14179.1.2.2.3.1.2',
      agentLagDetailedPortSpeed => '1.3.6.1.4.1.14179.1.2.2.3.1.22',
      agentLagConfigMode => '1.3.6.1.4.1.14179.1.2.2.4',
      agentNetworkConfigGroup => '1.3.6.1.4.1.14179.1.2.3',
      agentNetworkIPAddress => '1.3.6.1.4.1.14179.1.2.3.1',
      agentNetworkMulticastMode => '1.3.6.1.4.1.14179.1.2.3.10',
      agentNetworkDsPortNumber => '1.3.6.1.4.1.14179.1.2.3.11',
      agentNetworkUserIdleTimeout => '1.3.6.1.4.1.14179.1.2.3.12',
      agentNetworkArpTimeout => '1.3.6.1.4.1.14179.1.2.3.13',
      agentNetworkManagementVlan => '1.3.6.1.4.1.14179.1.2.3.14',
      agentNetworkGvrpStatus => '1.3.6.1.4.1.14179.1.2.3.15',
      agentNetworkAllowMgmtViaWireless => '1.3.6.1.4.1.14179.1.2.3.16',
      agentNetworkBroadcastSsidMode => '1.3.6.1.4.1.14179.1.2.3.17',
      agentNetworkSecureWebPassword => '1.3.6.1.4.1.14179.1.2.3.18',
      agentNetworkWebAdminCertType => '1.3.6.1.4.1.14179.1.2.3.19',
      agentNetworkSubnetMask => '1.3.6.1.4.1.14179.1.2.3.2',
      agentNetworkWebAdminCertRegenerateCmdInvoke => '1.3.6.1.4.1.14179.1.2.3.20',
      agentNetworkWebAuthCertType => '1.3.6.1.4.1.14179.1.2.3.21',
      agentNetworkWebAuthCertRegenerateCmdInvoke => '1.3.6.1.4.1.14179.1.2.3.22',
      agentNetworkRouteConfigTable => '1.3.6.1.4.1.14179.1.2.3.23',
      agentNetworkRouteConfigEntry => '1.3.6.1.4.1.14179.1.2.3.23.1',
      agentNetworkRouteIPAddress => '1.3.6.1.4.1.14179.1.2.3.23.1.1',
      agentNetworkRouteIPNetmask => '1.3.6.1.4.1.14179.1.2.3.23.1.2',
      agentNetworkRouteStatus => '1.3.6.1.4.1.14179.1.2.3.23.1.23',
      agentNetworkRouteGateway => '1.3.6.1.4.1.14179.1.2.3.23.1.3',
      agentNetworkPeerToPeerBlockingMode => '1.3.6.1.4.1.14179.1.2.3.24',
      agentNetworkMulticastGroupAddress => '1.3.6.1.4.1.14179.1.2.3.25',
      agentNetworkDefaultGateway => '1.3.6.1.4.1.14179.1.2.3.3',
      agentNetworkBurnedInMacAddress => '1.3.6.1.4.1.14179.1.2.3.4',
      agentNetworkConfigProtocol => '1.3.6.1.4.1.14179.1.2.3.7',
      agentNetworkWebMode => '1.3.6.1.4.1.14179.1.2.3.8',
      agentNetworkSecureWebMode => '1.3.6.1.4.1.14179.1.2.3.9',
      agentServicePortConfigGroup => '1.3.6.1.4.1.14179.1.2.4',
      agentServicePortIPAddress => '1.3.6.1.4.1.14179.1.2.4.1',
      agentServicePortSubnetMask => '1.3.6.1.4.1.14179.1.2.4.2',
      agentServicePortDefaultGateway => '1.3.6.1.4.1.14179.1.2.4.3',
      agentServicePortBurnedInMacAddress => '1.3.6.1.4.1.14179.1.2.4.4',
      agentServicePortConfigProtocol => '1.3.6.1.4.1.14179.1.2.4.5',
      agentSnmpConfigGroup => '1.3.6.1.4.1.14179.1.2.5',
      agentSnmpTrapPortNumber => '1.3.6.1.4.1.14179.1.2.5.1',
      agentSnmpVersion1Status => '1.3.6.1.4.1.14179.1.2.5.2',
      agentSnmpVersion2cStatus => '1.3.6.1.4.1.14179.1.2.5.3',
      agentSnmpCommunityConfigTable => '1.3.6.1.4.1.14179.1.2.5.5',
      agentSnmpCommunityConfigEntry => '1.3.6.1.4.1.14179.1.2.5.5.1',
      agentSnmpCommunityName => '1.3.6.1.4.1.14179.1.2.5.5.1.1',
      agentSnmpCommunityIPAddress => '1.3.6.1.4.1.14179.1.2.5.5.1.2',
      agentSnmpCommunityStatus => '1.3.6.1.4.1.14179.1.2.5.5.1.25',
      agentSnmpCommunityIPMask => '1.3.6.1.4.1.14179.1.2.5.5.1.3',
      agentSnmpCommunityAccessMode => '1.3.6.1.4.1.14179.1.2.5.5.1.4',
      agentSnmpCommunityEnabled => '1.3.6.1.4.1.14179.1.2.5.5.1.5',
      agentSnmpTrapReceiverConfigTable => '1.3.6.1.4.1.14179.1.2.5.6',
      agentSnmpTrapReceiverConfigEntry => '1.3.6.1.4.1.14179.1.2.5.6.1',
      agentSnmpTrapReceiverName => '1.3.6.1.4.1.14179.1.2.5.6.1.1',
      agentSnmpTrapReceiverIPAddress => '1.3.6.1.4.1.14179.1.2.5.6.1.2',
      agentSnmpTrapReceiverStatus => '1.3.6.1.4.1.14179.1.2.5.6.1.23',
      agentSnmpTrapReceiverEnabled => '1.3.6.1.4.1.14179.1.2.5.6.1.3',
      agentSnmpTrapFlagsConfigGroup => '1.3.6.1.4.1.14179.1.2.5.7',
      agentSnmpAuthenticationTrapFlag => '1.3.6.1.4.1.14179.1.2.5.7.1',
      agentSnmpLinkUpDownTrapFlag => '1.3.6.1.4.1.14179.1.2.5.7.2',
      agentSnmpMultipleUsersTrapFlag => '1.3.6.1.4.1.14179.1.2.5.7.3',
      agentSnmpSpanningTreeTrapFlag => '1.3.6.1.4.1.14179.1.2.5.7.4',
      agentSnmpBroadcastStormTrapFlag => '1.3.6.1.4.1.14179.1.2.5.7.5',
      agentSnmpV3ConfigGroup => '1.3.6.1.4.1.14179.1.2.6',
      agentSnmpVersion3Status => '1.3.6.1.4.1.14179.1.2.6.1',
      agentSnmpV3UserConfigTable => '1.3.6.1.4.1.14179.1.2.6.2',
      agentSnmpV3UserConfigEntry => '1.3.6.1.4.1.14179.1.2.6.2.1',
      agentSnmpV3UserName => '1.3.6.1.4.1.14179.1.2.6.2.1.1',
      agentSnmpV3UserAccessMode => '1.3.6.1.4.1.14179.1.2.6.2.1.2',
      agentSnmpV3UserStatus => '1.3.6.1.4.1.14179.1.2.6.2.1.26',
      agentSnmpV3UserAuthenticationType => '1.3.6.1.4.1.14179.1.2.6.2.1.3',
      agentSnmpV3UserEncryptionType => '1.3.6.1.4.1.14179.1.2.6.2.1.4',
      agentSnmpV3UserAuthenticationPassword => '1.3.6.1.4.1.14179.1.2.6.2.1.5',
      agentSnmpV3UserEncryptionPassword => '1.3.6.1.4.1.14179.1.2.6.2.1.6',
      agentSpanningTreeConfigGroup => '1.3.6.1.4.1.14179.1.2.7',
      agentSpanningTreeMode => '1.3.6.1.4.1.14179.1.2.7.1',
      agentSwitchConfigGroup => '1.3.6.1.4.1.14179.1.2.8',
      agentSwitchBroadcastControlMode => '1.3.6.1.4.1.14179.1.2.8.2',
      agentSwitchDot3FlowControlMode => '1.3.6.1.4.1.14179.1.2.8.3',
      agentSwitchAddressAgingTimeoutTable => '1.3.6.1.4.1.14179.1.2.8.4',
      agentSwitchAddressAgingTimeoutEntry => '1.3.6.1.4.1.14179.1.2.8.4.1',
      agentSwitchAddressAgingTimeout => '1.3.6.1.4.1.14179.1.2.8.4.1.10',
      agentSwitchLwappTransportMode => '1.3.6.1.4.1.14179.1.2.8.5',
      agentTransferConfigGroup => '1.3.6.1.4.1.14179.1.2.9',
      agentTransferUploadGroup => '1.3.6.1.4.1.14179.1.2.9.1',
      agentTransferUploadMode => '1.3.6.1.4.1.14179.1.2.9.1.1',
      agentTransferUploadServerIP => '1.3.6.1.4.1.14179.1.2.9.1.2',
      agentTransferUploadPath => '1.3.6.1.4.1.14179.1.2.9.1.3',
      agentTransferUploadFilename => '1.3.6.1.4.1.14179.1.2.9.1.4',
      agentTransferUploadDataType => '1.3.6.1.4.1.14179.1.2.9.1.5',
      agentTransferUploadStart => '1.3.6.1.4.1.14179.1.2.9.1.6',
      agentTransferUploadStatus => '1.3.6.1.4.1.14179.1.2.9.1.7',
      agentTransferDownloadGroup => '1.3.6.1.4.1.14179.1.2.9.2',
      agentTransferDownloadMode => '1.3.6.1.4.1.14179.1.2.9.2.1',
      agentTransferDownloadServerIP => '1.3.6.1.4.1.14179.1.2.9.2.2',
      agentTransferDownloadPath => '1.3.6.1.4.1.14179.1.2.9.2.3',
      agentTransferDownloadFilename => '1.3.6.1.4.1.14179.1.2.9.2.4',
      agentTransferDownloadDataType => '1.3.6.1.4.1.14179.1.2.9.2.5',
      agentTransferDownloadStart => '1.3.6.1.4.1.14179.1.2.9.2.6',
      agentTransferDownloadStatus => '1.3.6.1.4.1.14179.1.2.9.2.7',
      agentTransferDownloadTftpMaxRetries => '1.3.6.1.4.1.14179.1.2.9.2.8',
      agentTransferDownloadTftpTimeout => '1.3.6.1.4.1.14179.1.2.9.2.9',
      agentTransferConfigurationFileEncryption => '1.3.6.1.4.1.14179.1.2.9.3',
      agentTransferConfigurationFileEncryptionKey => '1.3.6.1.4.1.14179.1.2.9.4',
      agentSystemGroup => '1.3.6.1.4.1.14179.1.3',
      agentSaveConfig => '1.3.6.1.4.1.14179.1.3.1',
      agentResetSystem => '1.3.6.1.4.1.14179.1.3.10',
      agentClearConfig => '1.3.6.1.4.1.14179.1.3.2',
      agentClearLags => '1.3.6.1.4.1.14179.1.3.3',
      agentClearLoginSessions => '1.3.6.1.4.1.14179.1.3.4',
      agentClearPortStats => '1.3.6.1.4.1.14179.1.3.6',
      agentClearSwitchStats => '1.3.6.1.4.1.14179.1.3.7',
      agentClearTrapLog => '1.3.6.1.4.1.14179.1.3.8',
      stats => '1.3.6.1.4.1.14179.1.4',
      portStatsTable => '1.3.6.1.4.1.14179.1.4.1',
      portStatsEntry => '1.3.6.1.4.1.14179.1.4.1.1',
      portStatsIndex => '1.3.6.1.4.1.14179.1.4.1.1.1',
      portStatsPktsTx64Octets => '1.3.6.1.4.1.14179.1.4.1.1.2',
      portStatsPktsTx65to127Octets => '1.3.6.1.4.1.14179.1.4.1.1.3',
      portStatsPktsTxOversizeOctets => '1.3.6.1.4.1.14179.1.4.1.1.30',
      portStatsPktsTx128to255Octets => '1.3.6.1.4.1.14179.1.4.1.1.4',
      portStatsPktsTx256to511Octets => '1.3.6.1.4.1.14179.1.4.1.1.5',
      portStatsPktsTx512to1023Octets => '1.3.6.1.4.1.14179.1.4.1.1.6',
      portStatsPktsTx1024to1518Octets => '1.3.6.1.4.1.14179.1.4.1.1.7',
      portStatsPktsRx1519to1530Octets => '1.3.6.1.4.1.14179.1.4.1.1.8',
      portStatsPktsTx1519to1530Octets => '1.3.6.1.4.1.14179.1.4.1.1.9',
      switchingTraps => '1.3.6.1.4.1.14179.1.50',
      multipleUsersTrap => '1.3.6.1.4.1.14179.1.50.1',
      stpInstanceNewRootTrap => '1.3.6.1.4.1.14179.1.50.10',
      stpInstanceTopologyChangeTrap => '1.3.6.1.4.1.14179.1.50.11',
      powerSupplyStatusChangeTrap => '1.3.6.1.4.1.14179.1.50.12',
      broadcastStormStartTrap => '1.3.6.1.4.1.14179.1.50.2',
      broadcastStormEndTrap => '1.3.6.1.4.1.14179.1.50.3',
      linkFailureTrap => '1.3.6.1.4.1.14179.1.50.4',
      vlanRequestFailureTrap => '1.3.6.1.4.1.14179.1.50.5',
      vlanDeleteLastTrap => '1.3.6.1.4.1.14179.1.50.6',
      vlanDefaultCfgFailureTrap => '1.3.6.1.4.1.14179.1.50.7',
      vlanRestoreFailureTrap => '1.3.6.1.4.1.14179.1.50.8',
      fanFailureTrap => '1.3.6.1.4.1.14179.1.50.9',
      bsnSwitchingGroups => '1.3.6.1.4.1.14179.1.51',
      bsnSwitchingAgentInfoGroup => '1.3.6.1.4.1.14179.1.51.1',
      bsnSwitchingAgentConfigGroup => '1.3.6.1.4.1.14179.1.51.2',
      bsnSwitchingAgentSystemGroup => '1.3.6.1.4.1.14179.1.51.3',
      bsnSwitchingAgentStatsGroup => '1.3.6.1.4.1.14179.1.51.4',
      bsnSwitchingObsGroup => '1.3.6.1.4.1.14179.1.51.5',
      bsnSwitchingTrap => '1.3.6.1.4.1.14179.1.51.6',
      bsnSwitchingCompliances => '1.3.6.1.4.1.14179.1.52',
      bsnSwitchingCompliance => '1.3.6.1.4.1.14179.1.52.1',
  },
  'AIRESPACE-WIRELESS-MIB' => {
      bsnWireless => '1.3.6.1.4.1.14179.2',
      bsnEss => '1.3.6.1.4.1.14179.2.1',
      bsnDot11EssTable => '1.3.6.1.4.1.14179.2.1.1',
      bsnDot11EssEntry => '1.3.6.1.4.1.14179.2.1.1.1',
      bsnDot11EssIndex => '1.3.6.1.4.1.14179.2.1.1.1.1',
      bsnDot11EssStaticWEPDefaultKey => '1.3.6.1.4.1.14179.2.1.1.1.10',
      bsnDot11EssRadiusAcctTertiaryServer => '1.3.6.1.4.1.14179.2.1.1.1.100',
      bsnDot11EssStaticWEPKeyIndex => '1.3.6.1.4.1.14179.2.1.1.1.11',
      bsnDot11EssStaticWEPKeyFormat => '1.3.6.1.4.1.14179.2.1.1.1.12',
      bsnDot11Ess8021xSecurity => '1.3.6.1.4.1.14179.2.1.1.1.13',
      bsnDot11Ess8021xEncryptionType => '1.3.6.1.4.1.14179.2.1.1.1.14',
      bsnDot11EssWPASecurity => '1.3.6.1.4.1.14179.2.1.1.1.16',
      bsnDot11EssWPAEncryptionType => '1.3.6.1.4.1.14179.2.1.1.1.17',
      bsnDot11EssIpsecSecurity => '1.3.6.1.4.1.14179.2.1.1.1.18',
      bsnDot11EssVpnEncrTransform => '1.3.6.1.4.1.14179.2.1.1.1.19',
      bsnDot11EssSsid => '1.3.6.1.4.1.14179.2.1.1.1.2',
      bsnDot11EssVpnAuthTransform => '1.3.6.1.4.1.14179.2.1.1.1.20',
      bsnDot11EssVpnIkeAuthMode => '1.3.6.1.4.1.14179.2.1.1.1.21',
      bsnDot11EssVpnSharedKey => '1.3.6.1.4.1.14179.2.1.1.1.22',
      bsnDot11EssVpnSharedKeySize => '1.3.6.1.4.1.14179.2.1.1.1.23',
      bsnDot11EssVpnIkePhase1Mode => '1.3.6.1.4.1.14179.2.1.1.1.24',
      bsnDot11EssVpnIkeLifetime => '1.3.6.1.4.1.14179.2.1.1.1.25',
      bsnDot11EssVpnIkeDHGroup => '1.3.6.1.4.1.14179.2.1.1.1.26',
      bsnDot11EssIpsecPassthruSecurity => '1.3.6.1.4.1.14179.2.1.1.1.27',
      bsnDot11EssVpnPassthruGateway => '1.3.6.1.4.1.14179.2.1.1.1.28',
      bsnDot11EssWebSecurity => '1.3.6.1.4.1.14179.2.1.1.1.29',
      bsnDot11EssRadioPolicy => '1.3.6.1.4.1.14179.2.1.1.1.30',
      bsnDot11EssQualityOfService => '1.3.6.1.4.1.14179.2.1.1.1.31',
      bsnDot11EssDhcpRequired => '1.3.6.1.4.1.14179.2.1.1.1.32',
      bsnDot11EssDhcpServerIpAddress => '1.3.6.1.4.1.14179.2.1.1.1.33',
      bsnDot11EssVpnContivityMode => '1.3.6.1.4.1.14179.2.1.1.1.34',
      bsnDot11EssVpnQotdServerAddress => '1.3.6.1.4.1.14179.2.1.1.1.35',
      bsnDot11EssBlacklistTimeout => '1.3.6.1.4.1.14179.2.1.1.1.37',
      bsnDot11EssNumberOfMobileStations => '1.3.6.1.4.1.14179.2.1.1.1.38',
      bsnDot11EssWebPassthru => '1.3.6.1.4.1.14179.2.1.1.1.39',
      bsnDot11EssSessionTimeout => '1.3.6.1.4.1.14179.2.1.1.1.4',
      bsnDot11EssCraniteSecurity => '1.3.6.1.4.1.14179.2.1.1.1.40',
      bsnDot11EssBlacklistingCapability => '1.3.6.1.4.1.14179.2.1.1.1.41',
      bsnDot11EssInterfaceName => '1.3.6.1.4.1.14179.2.1.1.1.42',
      bsnDot11EssAclName => '1.3.6.1.4.1.14179.2.1.1.1.43',
      bsnDot11EssAAAOverride => '1.3.6.1.4.1.14179.2.1.1.1.44',
      bsnDot11EssWPAAuthKeyMgmtMode => '1.3.6.1.4.1.14179.2.1.1.1.45',
      bsnDot11EssWPAAuthPresharedKey => '1.3.6.1.4.1.14179.2.1.1.1.46',
      bsnDot11EssFortressSecurity => '1.3.6.1.4.1.14179.2.1.1.1.47',
      bsnDot11EssWepAllowSharedKeyAuth => '1.3.6.1.4.1.14179.2.1.1.1.48',
      bsnDot11EssL2tpSecurity => '1.3.6.1.4.1.14179.2.1.1.1.49',
      bsnDot11EssMacFiltering => '1.3.6.1.4.1.14179.2.1.1.1.5',
      bsnDot11EssWPAAuthPresharedKeyHex => '1.3.6.1.4.1.14179.2.1.1.1.50',
      bsnDot11EssBroadcastSsid => '1.3.6.1.4.1.14179.2.1.1.1.51',
      bsnDot11EssExternalPolicyValidation => '1.3.6.1.4.1.14179.2.1.1.1.52',
      bsnDot11EssRSNSecurity => '1.3.6.1.4.1.14179.2.1.1.1.53',
      bsnDot11EssRSNWPACompatibilityMode => '1.3.6.1.4.1.14179.2.1.1.1.54',
      bsnDot11EssRSNAllowTKIPClients => '1.3.6.1.4.1.14179.2.1.1.1.55',
      bsnDot11EssRSNAuthKeyMgmtMode => '1.3.6.1.4.1.14179.2.1.1.1.56',
      bsnDot11EssRSNAuthPresharedKey => '1.3.6.1.4.1.14179.2.1.1.1.57',
      bsnDot11EssRSNAuthPresharedKeyHex => '1.3.6.1.4.1.14179.2.1.1.1.58',
      bsnDot11EssIPv6Bridging => '1.3.6.1.4.1.14179.2.1.1.1.59',
      bsnDot11EssAdminStatus => '1.3.6.1.4.1.14179.2.1.1.1.6',
      bsnDot11EssRowStatus => '1.3.6.1.4.1.14179.2.1.1.1.60',
      bsnDot11EssWmePolicySetting => '1.3.6.1.4.1.14179.2.1.1.1.61',
      bsnDot11Ess80211ePolicySetting => '1.3.6.1.4.1.14179.2.1.1.1.62',
      bsnDot11EssWebPassthroughEmail => '1.3.6.1.4.1.14179.2.1.1.1.63',
      bsnDot11Ess7920PhoneSupport => '1.3.6.1.4.1.14179.2.1.1.1.64',
      bsnDot11EssSecurityAuthType => '1.3.6.1.4.1.14179.2.1.1.1.7',
      bsnDot11EssStaticWEPSecurity => '1.3.6.1.4.1.14179.2.1.1.1.8',
      bsnDot11EssStaticWEPEncryptionType => '1.3.6.1.4.1.14179.2.1.1.1.9',
      bsnDot11EssRadiusAuthPrimaryServer => '1.3.6.1.4.1.14179.2.1.1.1.95',
      bsnDot11EssRadiusAuthSecondaryServer => '1.3.6.1.4.1.14179.2.1.1.1.96',
      bsnDot11EssRadiusAuthTertiaryServer => '1.3.6.1.4.1.14179.2.1.1.1.97',
      bsnDot11EssRadiusAcctPrimaryServer => '1.3.6.1.4.1.14179.2.1.1.1.98',
      bsnDot11EssRadiusAcctSecondaryServer => '1.3.6.1.4.1.14179.2.1.1.1.99',
      bsnMobileStationByIpTable => '1.3.6.1.4.1.14179.2.1.10',
      bsnMobileStationByIpEntry => '1.3.6.1.4.1.14179.2.1.10.1',
      bsnMobileStationByIpAddress => '1.3.6.1.4.1.14179.2.1.10.1.1',
      bsnMobileStationByIpMacAddress => '1.3.6.1.4.1.14179.2.1.10.1.2',
      bsnMobileStationRssiDataTable => '1.3.6.1.4.1.14179.2.1.11',
      bsnMobileStationRssiDataEntry => '1.3.6.1.4.1.14179.2.1.11.1',
      bsnMobileStationRssiDataApMacAddress => '1.3.6.1.4.1.14179.2.1.11.1.1',
      bsnMobileStationRssiDataApIfSlotId => '1.3.6.1.4.1.14179.2.1.11.1.2',
      bsnMobileStationRssiDataLastHeard => '1.3.6.1.4.1.14179.2.1.11.1.25',
      bsnMobileStationRssiDataApIfType => '1.3.6.1.4.1.14179.2.1.11.1.3',
      bsnMobileStationRssiDataApName => '1.3.6.1.4.1.14179.2.1.11.1.4',
      bsnMobileStationRssiData => '1.3.6.1.4.1.14179.2.1.11.1.5',
      bsnAPIfPhyAntennaIndex => '1.3.6.1.4.1.14179.2.1.11.1.6',
      bsnWatchListClientTable => '1.3.6.1.4.1.14179.2.1.12',
      bsnWatchListClientEntry => '1.3.6.1.4.1.14179.2.1.12.1',
      bsnWatchListClientKey => '1.3.6.1.4.1.14179.2.1.12.1.1',
      bsnWatchListClientType => '1.3.6.1.4.1.14179.2.1.12.1.2',
      bsnWatchListClientRowStatus => '1.3.6.1.4.1.14179.2.1.12.1.20',
      bsnMobileStationByUsernameTable => '1.3.6.1.4.1.14179.2.1.13',
      bsnMobileStationByUsernameEntry => '1.3.6.1.4.1.14179.2.1.13.1',
      bsnMobileStationByUserName => '1.3.6.1.4.1.14179.2.1.13.1.1',
      bsnMobileStationByUserMacAddress => '1.3.6.1.4.1.14179.2.1.13.1.2',
      bsnRogueClientTable => '1.3.6.1.4.1.14179.2.1.14',
      bsnRogueClientEntry => '1.3.6.1.4.1.14179.2.1.14.1',
      bsnRogueClientDot11MacAddress => '1.3.6.1.4.1.14179.2.1.14.1.1',
      bsnRogueClientTotalDetectingAPs => '1.3.6.1.4.1.14179.2.1.14.1.2',
      bsnRogueClientState => '1.3.6.1.4.1.14179.2.1.14.1.24',
      bsnRogueClientFirstReported => '1.3.6.1.4.1.14179.2.1.14.1.3',
      bsnRogueClientLastReported => '1.3.6.1.4.1.14179.2.1.14.1.4',
      bsnRogueClientBSSID => '1.3.6.1.4.1.14179.2.1.14.1.5',
      bsnRogueClientContainmentLevel => '1.3.6.1.4.1.14179.2.1.14.1.6',
      bsnRogueClientLastHeard => '1.3.6.1.4.1.14179.2.1.14.1.7',
      bsnRogueClientAirespaceAPTable => '1.3.6.1.4.1.14179.2.1.15',
      bsnRogueClientAirespaceAPEntry => '1.3.6.1.4.1.14179.2.1.15.1',
      bsnRogueClientAirespaceAPMacAddress => '1.3.6.1.4.1.14179.2.1.15.1.1',
      bsnRogueClientAirespaceAPLastHeard => '1.3.6.1.4.1.14179.2.1.15.1.11',
      bsnRogueClientAirespaceAPSlotId => '1.3.6.1.4.1.14179.2.1.15.1.2',
      bsnRogueClientAirespaceAPSNR => '1.3.6.1.4.1.14179.2.1.15.1.27',
      bsnRogueClientRadioType => '1.3.6.1.4.1.14179.2.1.15.1.3',
      bsnRogueClientAirespaceAPName => '1.3.6.1.4.1.14179.2.1.15.1.4',
      bsnRogueClientChannelNumber => '1.3.6.1.4.1.14179.2.1.15.1.5',
      bsnRogueClientAirespaceAPRSSI => '1.3.6.1.4.1.14179.2.1.15.1.7',
      bsnRogueClientPerRogueAPTable => '1.3.6.1.4.1.14179.2.1.16',
      bsnRogueClientPerRogueAPEntry => '1.3.6.1.4.1.14179.2.1.16.1',
      bsnRogueAPDot11MacAddr => '1.3.6.1.4.1.14179.2.1.16.1.1',
      bsnRogueClientDot11MacAddr => '1.3.6.1.4.1.14179.2.1.16.1.20',
      bsnDot11QosProfileTable => '1.3.6.1.4.1.14179.2.1.17',
      bsnDot11QosProfileEntry => '1.3.6.1.4.1.14179.2.1.17.1',
      bsnDot11QosProfileName => '1.3.6.1.4.1.14179.2.1.17.1.1',
      bsnDot11802Dot1PTag => '1.3.6.1.4.1.14179.2.1.17.1.10',
      bsnDot11QosProfileDesc => '1.3.6.1.4.1.14179.2.1.17.1.2',
      bsnDot11QosAverageDataRate => '1.3.6.1.4.1.14179.2.1.17.1.3',
      bsnDot11QosBurstDataRate => '1.3.6.1.4.1.14179.2.1.17.1.4',
      bsnDot11ResetProfileToDefault => '1.3.6.1.4.1.14179.2.1.17.1.40',
      bsnDot11QosAvgRealTimeDataRate => '1.3.6.1.4.1.14179.2.1.17.1.5',
      bsnDot11QosBurstRealTimeDataRate => '1.3.6.1.4.1.14179.2.1.17.1.6',
      bsnDot11QosMaxRFUsagePerAP => '1.3.6.1.4.1.14179.2.1.17.1.7',
      bsnDot11QosProfileQueueDepth => '1.3.6.1.4.1.14179.2.1.17.1.8',
      bsnDot11WiredQosProtocol => '1.3.6.1.4.1.14179.2.1.17.1.9',
      bsnTagTable => '1.3.6.1.4.1.14179.2.1.18',
      bsnTagEntry => '1.3.6.1.4.1.14179.2.1.18.1',
      bsnTagDot11MacAddress => '1.3.6.1.4.1.14179.2.1.18.1.1',
      bsnTagType => '1.3.6.1.4.1.14179.2.1.18.1.2',
      bsnTagLastReported => '1.3.6.1.4.1.14179.2.1.18.1.23',
      bsnTagTimeInterval => '1.3.6.1.4.1.14179.2.1.18.1.3',
      bsnTagBatteryStatus => '1.3.6.1.4.1.14179.2.1.18.1.4',
      bsnTagRssiDataTable => '1.3.6.1.4.1.14179.2.1.19',
      bsnTagRssiDataEntry => '1.3.6.1.4.1.14179.2.1.19.1',
      bsnTagRssiDataApMacAddress => '1.3.6.1.4.1.14179.2.1.19.1.1',
      bsnTagRssiDataApIfSlotId => '1.3.6.1.4.1.14179.2.1.19.1.2',
      bsnTagRssiDataSnr => '1.3.6.1.4.1.14179.2.1.19.1.26',
      bsnTagRssiDataApIfType => '1.3.6.1.4.1.14179.2.1.19.1.3',
      bsnTagRssiDataApName => '1.3.6.1.4.1.14179.2.1.19.1.4',
      bsnTagRssiDataLastHeard => '1.3.6.1.4.1.14179.2.1.19.1.5',
      bsnTagRssiData => '1.3.6.1.4.1.14179.2.1.19.1.6',
      bsnTagStatsTable => '1.3.6.1.4.1.14179.2.1.20',
      bsnTagStatsEntry => '1.3.6.1.4.1.14179.2.1.20.1',
      bsnTagBytesReceived => '1.3.6.1.4.1.14179.2.1.20.1.1',
      bsnTagPacketsReceived => '1.3.6.1.4.1.14179.2.1.20.1.20',
      bsnMobileStationExtStatsTable => '1.3.6.1.4.1.14179.2.1.21',
      bsnMobileStationExtStatsEntry => '1.3.6.1.4.1.14179.2.1.21.1',
      bsnMobileStationSampleTime => '1.3.6.1.4.1.14179.2.1.21.1.1',
      bsnMobileStationTxExcessiveRetries => '1.3.6.1.4.1.14179.2.1.21.1.2',
      bsnMobileStationTxFiltered => '1.3.6.1.4.1.14179.2.1.21.1.20',
      bsnMobileStationTxRetries => '1.3.6.1.4.1.14179.2.1.21.1.3',
      bsnMobileStationTable => '1.3.6.1.4.1.14179.2.1.4',
      bsnMobileStationEntry => '1.3.6.1.4.1.14179.2.1.4.1',
      bsnMobileStationMacAddress => '1.3.6.1.4.1.14179.2.1.4.1.1',
      bsnMobileStationReasonCode => '1.3.6.1.4.1.14179.2.1.4.1.10',
      bsnMobileStationMobilityStatus => '1.3.6.1.4.1.14179.2.1.4.1.11',
      bsnMobileStationAnchorAddress => '1.3.6.1.4.1.14179.2.1.4.1.12',
      bsnMobileStationCFPollable => '1.3.6.1.4.1.14179.2.1.4.1.13',
      bsnMobileStationCFPollRequest => '1.3.6.1.4.1.14179.2.1.4.1.14',
      bsnMobileStationChannelAgilityEnabled => '1.3.6.1.4.1.14179.2.1.4.1.15',
      bsnMobileStationPBCCOptionImplemented => '1.3.6.1.4.1.14179.2.1.4.1.16',
      bsnMobileStationShortPreambleOptionImplemented => '1.3.6.1.4.1.14179.2.1.4.1.17',
      bsnMobileStationSessionTimeout => '1.3.6.1.4.1.14179.2.1.4.1.18',
      bsnMobileStationAuthenticationAlgorithm => '1.3.6.1.4.1.14179.2.1.4.1.19',
      bsnMobileStationIpAddress => '1.3.6.1.4.1.14179.2.1.4.1.2',
      bsnMobileStationWepState => '1.3.6.1.4.1.14179.2.1.4.1.20',
      bsnMobileStationPortNumber => '1.3.6.1.4.1.14179.2.1.4.1.21',
      bsnMobileStationDeleteAction => '1.3.6.1.4.1.14179.2.1.4.1.22',
      bsnMobileStationPolicyManagerState => '1.3.6.1.4.1.14179.2.1.4.1.23',
      bsnMobileStationSecurityPolicyStatus => '1.3.6.1.4.1.14179.2.1.4.1.24',
      bsnMobileStationProtocol => '1.3.6.1.4.1.14179.2.1.4.1.25',
      bsnMobileStationMirrorMode => '1.3.6.1.4.1.14179.2.1.4.1.26',
      bsnMobileStationInterface => '1.3.6.1.4.1.14179.2.1.4.1.27',
      bsnMobileStationApMode => '1.3.6.1.4.1.14179.2.1.4.1.28',
      bsnMobileStationVlanId => '1.3.6.1.4.1.14179.2.1.4.1.29',
      bsnMobileStationUserName => '1.3.6.1.4.1.14179.2.1.4.1.3',
      bsnMobileStationPolicyType => '1.3.6.1.4.1.14179.2.1.4.1.30',
      bsnMobileStationEncryptionCypher => '1.3.6.1.4.1.14179.2.1.4.1.31',
      bsnMobileStationEapType => '1.3.6.1.4.1.14179.2.1.4.1.32',
      bsnMobileStationCcxVersion => '1.3.6.1.4.1.14179.2.1.4.1.33',
      bsnMobileStationE2eVersion => '1.3.6.1.4.1.14179.2.1.4.1.34',
      bsnMobileStationAPMacAddr => '1.3.6.1.4.1.14179.2.1.4.1.4',
      bsnMobileStationStatusCode => '1.3.6.1.4.1.14179.2.1.4.1.42',
      bsnMobileStationAPIfSlotId => '1.3.6.1.4.1.14179.2.1.4.1.5',
      bsnMobileStationEssIndex => '1.3.6.1.4.1.14179.2.1.4.1.6',
      bsnMobileStationSsid => '1.3.6.1.4.1.14179.2.1.4.1.7',
      bsnMobileStationAID => '1.3.6.1.4.1.14179.2.1.4.1.8',
      bsnMobileStationStatus => '1.3.6.1.4.1.14179.2.1.4.1.9',
      bsnMobileStationPerRadioPerVapTable => '1.3.6.1.4.1.14179.2.1.5',
      bsnMobileStationPerRadioPerVapEntry => '1.3.6.1.4.1.14179.2.1.5.1',
      bsnMobileStationPerRadioPerVapIndex => '1.3.6.1.4.1.14179.2.1.5.1.1',
      bsnMobileStationMacAddr => '1.3.6.1.4.1.14179.2.1.5.1.20',
      bsnMobileStationStatsTable => '1.3.6.1.4.1.14179.2.1.6',
      bsnMobileStationStatsEntry => '1.3.6.1.4.1.14179.2.1.6.1',
      bsnMobileStationRSSI => '1.3.6.1.4.1.14179.2.1.6.1.1',
      bsnMobileStationBytesReceived => '1.3.6.1.4.1.14179.2.1.6.1.2',
      bsnMobileStationSnr => '1.3.6.1.4.1.14179.2.1.6.1.26',
      bsnMobileStationBytesSent => '1.3.6.1.4.1.14179.2.1.6.1.3',
      bsnMobileStationPolicyErrors => '1.3.6.1.4.1.14179.2.1.6.1.4',
      bsnMobileStationPacketsReceived => '1.3.6.1.4.1.14179.2.1.6.1.5',
      bsnMobileStationPacketsSent => '1.3.6.1.4.1.14179.2.1.6.1.6',
      bsnRogueAPTable => '1.3.6.1.4.1.14179.2.1.7',
      bsnRogueAPEntry => '1.3.6.1.4.1.14179.2.1.7.1',
      bsnRogueAPDot11MacAddress => '1.3.6.1.4.1.14179.2.1.7.1.1',
      bsnRogueAPMaxDetectedRSSI => '1.3.6.1.4.1.14179.2.1.7.1.10',
      bsnRogueAPSSID => '1.3.6.1.4.1.14179.2.1.7.1.11',
      bsnRogueAPDetectingAPRadioType => '1.3.6.1.4.1.14179.2.1.7.1.12',
      bsnRogueAPDetectingAPMacAddress => '1.3.6.1.4.1.14179.2.1.7.1.13',
      bsnRogueAPMaxRssiRadioType => '1.3.6.1.4.1.14179.2.1.7.1.14',
      bsnRogueAPTotalDetectingAPs => '1.3.6.1.4.1.14179.2.1.7.1.2',
      bsnRogueAPState => '1.3.6.1.4.1.14179.2.1.7.1.24',
      bsnRogueAPClassType => '1.3.6.1.4.1.14179.2.1.7.1.25',
      bsnRogueAPChannel => '1.3.6.1.4.1.14179.2.1.7.1.26',
      bsnRogueAPDetectingAPName => '1.3.6.1.4.1.14179.2.1.7.1.27',
      bsnRogueAPFirstReported => '1.3.6.1.4.1.14179.2.1.7.1.3',
      bsnRogueAPLastReported => '1.3.6.1.4.1.14179.2.1.7.1.4',
      bsnRogueAPContainmentLevel => '1.3.6.1.4.1.14179.2.1.7.1.5',
      bsnRogueAPType => '1.3.6.1.4.1.14179.2.1.7.1.6',
      bsnRogueAPOnNetwork => '1.3.6.1.4.1.14179.2.1.7.1.7',
      bsnRogueAPTotalClients => '1.3.6.1.4.1.14179.2.1.7.1.8',
      bsnRogueAPRowStatus => '1.3.6.1.4.1.14179.2.1.7.1.9',
      bsnRogueAPAirespaceAPTable => '1.3.6.1.4.1.14179.2.1.8',
      bsnRogueAPAirespaceAPEntry => '1.3.6.1.4.1.14179.2.1.8.1',
      bsnRogueAPAirespaceAPMacAddress => '1.3.6.1.4.1.14179.2.1.8.1.1',
      bsnRogueAPContainmentChannels => '1.3.6.1.4.1.14179.2.1.8.1.10',
      bsnRogueAPAirespaceAPLastHeard => '1.3.6.1.4.1.14179.2.1.8.1.11',
      bsnRogueAPAirespaceAPWepMode => '1.3.6.1.4.1.14179.2.1.8.1.12',
      bsnRogueAPAirespaceAPPreamble => '1.3.6.1.4.1.14179.2.1.8.1.13',
      bsnRogueAPAirespaceAPWpaMode => '1.3.6.1.4.1.14179.2.1.8.1.14',
      bsnRogueAPAirespaceAPSlotId => '1.3.6.1.4.1.14179.2.1.8.1.2',
      bsnRogueAPAirespaceAPSNR => '1.3.6.1.4.1.14179.2.1.8.1.27',
      bsnRogueAPChannelWidth => '1.3.6.1.4.1.14179.2.1.8.1.28',
      bsnRogueAPRadioType => '1.3.6.1.4.1.14179.2.1.8.1.3',
      bsnRogueAPAirespaceAPName => '1.3.6.1.4.1.14179.2.1.8.1.4',
      bsnRogueAPChannelNumber => '1.3.6.1.4.1.14179.2.1.8.1.5',
      bsnRogueAPSsid => '1.3.6.1.4.1.14179.2.1.8.1.6',
      bsnRogueAPAirespaceAPRSSI => '1.3.6.1.4.1.14179.2.1.8.1.7',
      bsnRogueAPContainmentMode => '1.3.6.1.4.1.14179.2.1.8.1.8',
      bsnRogueAPContainmentChannelCount => '1.3.6.1.4.1.14179.2.1.8.1.9',
      bsnThirdPartyAPTable => '1.3.6.1.4.1.14179.2.1.9',
      bsnThirdPartyAPEntry => '1.3.6.1.4.1.14179.2.1.9.1',
      bsnThirdPartyAPMacAddress => '1.3.6.1.4.1.14179.2.1.9.1.1',
      bsnThirdPartyAPInterface => '1.3.6.1.4.1.14179.2.1.9.1.2',
      bsnThirdPartyAPRowStatus => '1.3.6.1.4.1.14179.2.1.9.1.24',
      bsnThirdPartyAPIpAddress => '1.3.6.1.4.1.14179.2.1.9.1.3',
      bsnThirdPartyAP802Dot1XRequired => '1.3.6.1.4.1.14179.2.1.9.1.4',
      bsnThirdPartyAPMirrorMode => '1.3.6.1.4.1.14179.2.1.9.1.5',
      bsnAPGroupsVlanConfig => '1.3.6.1.4.1.14179.2.10',
      bsnAPGroupsVlanFeature => '1.3.6.1.4.1.14179.2.10.1',
      bsnAPGroupsVlanTable => '1.3.6.1.4.1.14179.2.10.2',
      bsnAPGroupsVlanEntry => '1.3.6.1.4.1.14179.2.10.2.1',
      bsnAPGroupsVlanName => '1.3.6.1.4.1.14179.2.10.2.1.1',
      bsnAPGroupsVlanDescription => '1.3.6.1.4.1.14179.2.10.2.1.2',
      bsnAPGroupsVlanRowStatus => '1.3.6.1.4.1.14179.2.10.2.1.20',
      bsnAPGroupsVlanMappingTable => '1.3.6.1.4.1.14179.2.10.3',
      bsnAPGroupsVlanMappingEntry => '1.3.6.1.4.1.14179.2.10.3.1',
      bsnAPGroupsVlanMappingSsid => '1.3.6.1.4.1.14179.2.10.3.1.1',
      bsnAPGroupsVlanMappingInterfaceName => '1.3.6.1.4.1.14179.2.10.3.1.2',
      bsnAPGroupsVlanMappingRowStatus => '1.3.6.1.4.1.14179.2.10.3.1.20',
      bsnAP => '1.3.6.1.4.1.14179.2.2',
      bsnAPTable => '1.3.6.1.4.1.14179.2.2.1',
      bsnAPEntry => '1.3.6.1.4.1.14179.2.2.1.1',
      bsnAPDot3MacAddress => '1.3.6.1.4.1.14179.2.2.1.1.1',
      bsnAPPrimaryMwarName => '1.3.6.1.4.1.14179.2.2.1.1.10',
      bsnAPReset => '1.3.6.1.4.1.14179.2.2.1.1.11',
      bsnAPStatsTimer => '1.3.6.1.4.1.14179.2.2.1.1.12',
      bsnAPPortNumber => '1.3.6.1.4.1.14179.2.2.1.1.13',
      bsnAPModel => '1.3.6.1.4.1.14179.2.2.1.1.16',
      bsnAPSerialNumber => '1.3.6.1.4.1.14179.2.2.1.1.17',
      bsnAPClearConfig => '1.3.6.1.4.1.14179.2.2.1.1.18',
      bsnApIpAddress => '1.3.6.1.4.1.14179.2.2.1.1.19',
      bsnAPNumOfSlots => '1.3.6.1.4.1.14179.2.2.1.1.2',
      bsnAPMirrorMode => '1.3.6.1.4.1.14179.2.2.1.1.20',
      bsnAPRemoteModeSupport => '1.3.6.1.4.1.14179.2.2.1.1.21',
      bsnAPType => '1.3.6.1.4.1.14179.2.2.1.1.22',
      bsnAPTypeDefinition => {
      1 => 'ap1000',
      2 => 'ap1030',
      3 => 'mimo',
      4 => 'unknown',
      5 => 'ap1100',
      6 => 'ap1130',
      7 => 'ap1240',
      8 => 'ap1200',
      9 => 'ap1310',
      10 => 'ap1500',
      11 => 'ap1250',
      12 => 'ap1505',
      13 => 'ap3201',
      14 => 'ap1520',
      15 => 'ap800',
      16 => 'ap1140',
      17 => 'ap800agn',
      18 => 'ap3500i',
      19 => 'ap3500e',
      20 => 'ap1260',
      },
      bsnAPSecondaryMwarName => '1.3.6.1.4.1.14179.2.2.1.1.23',
      bsnAPTertiaryMwarName => '1.3.6.1.4.1.14179.2.2.1.1.24',
      bsnAPIsStaticIP => '1.3.6.1.4.1.14179.2.2.1.1.25',
      bsnAPNetmask => '1.3.6.1.4.1.14179.2.2.1.1.26',
      bsnAPGateway => '1.3.6.1.4.1.14179.2.2.1.1.27',
      bsnAPStaticIPAddress => '1.3.6.1.4.1.14179.2.2.1.1.28',
      bsnAPBridgingSupport => '1.3.6.1.4.1.14179.2.2.1.1.29',
      bsnAPName => '1.3.6.1.4.1.14179.2.2.1.1.3',
      bsnAPGroupVlanName => '1.3.6.1.4.1.14179.2.2.1.1.30',
      bsnAPIOSVersion => '1.3.6.1.4.1.14179.2.2.1.1.31',
      bsnAPCertificateType => '1.3.6.1.4.1.14179.2.2.1.1.32',
      bsnAPEthernetMacAddress => '1.3.6.1.4.1.14179.2.2.1.1.33',
      bsnAPAdminStatus => '1.3.6.1.4.1.14179.2.2.1.1.37',
      bsnAPLocation => '1.3.6.1.4.1.14179.2.2.1.1.4',
      bsnAPMonitorOnlyMode => '1.3.6.1.4.1.14179.2.2.1.1.5',
      bsnAPOperationStatus => '1.3.6.1.4.1.14179.2.2.1.1.6',
      bsnAPOperationStatusDefinition => {
          1 => 'associated',
          2 => 'disassociating',
          3 => 'downloading',
      },
      bsnAPSoftwareVersion => '1.3.6.1.4.1.14179.2.2.1.1.8',
      bsnAPBootVersion => '1.3.6.1.4.1.14179.2.2.1.1.9',
      bsnAPIfProfileThresholdConfigTable => '1.3.6.1.4.1.14179.2.2.12',
      bsnAPIfProfileThresholdConfigEntry => '1.3.6.1.4.1.14179.2.2.12.1',
      bsnAPIfProfileParamAssignment => '1.3.6.1.4.1.14179.2.2.12.1.1',
      bsnAPIfForeignInterferenceThreshold => '1.3.6.1.4.1.14179.2.2.12.1.2',
      bsnAPIfCoverageExceptionLevel => '1.3.6.1.4.1.14179.2.2.12.1.28',
      bsnAPIfForeignNoiseThreshold => '1.3.6.1.4.1.14179.2.2.12.1.3',
      bsnAPIfRFUtilizationThreshold => '1.3.6.1.4.1.14179.2.2.12.1.4',
      bsnAPIfThroughputThreshold => '1.3.6.1.4.1.14179.2.2.12.1.5',
      bsnAPIfMobilesThreshold => '1.3.6.1.4.1.14179.2.2.12.1.6',
      bsnAPIfCoverageThreshold => '1.3.6.1.4.1.14179.2.2.12.1.7',
      bsnAPIfMobileMinExceptionLevel => '1.3.6.1.4.1.14179.2.2.12.1.8',
      bsnAPIfLoadParametersTable => '1.3.6.1.4.1.14179.2.2.13',
      bsnAPIfLoadParametersEntry => '1.3.6.1.4.1.14179.2.2.13.1',
      bsnAPIfLoadRxUtilization => '1.3.6.1.4.1.14179.2.2.13.1.1',
      bsnAPIfLoadTxUtilization => '1.3.6.1.4.1.14179.2.2.13.1.2',
      bsnAPIfPoorSNRClients => '1.3.6.1.4.1.14179.2.2.13.1.24',
      bsnAPIfLoadChannelUtilization => '1.3.6.1.4.1.14179.2.2.13.1.3',
      bsnAPIfLoadNumOfClients => '1.3.6.1.4.1.14179.2.2.13.1.4',
      bsnAPIfChannelInterferenceInfoTable => '1.3.6.1.4.1.14179.2.2.14',
      bsnAPIfChannelInterferenceInfoEntry => '1.3.6.1.4.1.14179.2.2.14.1',
      bsnAPIfInterferenceChannelNo => '1.3.6.1.4.1.14179.2.2.14.1.1',
      bsnAPIfInterferencePower => '1.3.6.1.4.1.14179.2.2.14.1.2',
      bsnAPIfInterferenceUtilization => '1.3.6.1.4.1.14179.2.2.14.1.22',
      bsnAPIfChannelNoiseInfoTable => '1.3.6.1.4.1.14179.2.2.15',
      bsnAPIfChannelNoiseInfoEntry => '1.3.6.1.4.1.14179.2.2.15.1',
      bsnAPIfNoiseChannelNo => '1.3.6.1.4.1.14179.2.2.15.1.1',
      bsnAPIfDBNoisePower => '1.3.6.1.4.1.14179.2.2.15.1.21',
      bsnAPIfProfileStateTable => '1.3.6.1.4.1.14179.2.2.16',
      bsnAPIfProfileStateEntry => '1.3.6.1.4.1.14179.2.2.16.1',
      bsnAPIfLoadProfileState => '1.3.6.1.4.1.14179.2.2.16.1.1',
      bsnAPIfInterferenceProfileState => '1.3.6.1.4.1.14179.2.2.16.1.2',
      bsnAPIfCoverageProfileState => '1.3.6.1.4.1.14179.2.2.16.1.24',
      bsnAPIfNoiseProfileState => '1.3.6.1.4.1.14179.2.2.16.1.3',
      bsnAPIfRxNeighborsTable => '1.3.6.1.4.1.14179.2.2.17',
      bsnAPIfRxNeighborsEntry => '1.3.6.1.4.1.14179.2.2.17.1',
      bsnAPIfRxNeighborMacAddress => '1.3.6.1.4.1.14179.2.2.17.1.1',
      bsnAPIfRxNeighborIpAddress => '1.3.6.1.4.1.14179.2.2.17.1.2',
      bsnAPIfRxNeighborSlot => '1.3.6.1.4.1.14179.2.2.17.1.24',
      bsnAPIfRxNeighborChannel => '1.3.6.1.4.1.14179.2.2.17.1.26',
      bsnAPIfRxNeighborChannelWidth => '1.3.6.1.4.1.14179.2.2.17.1.27',
      bsnAPIfRxNeighborRSSI => '1.3.6.1.4.1.14179.2.2.17.1.3',
      bsnAPIfStationRSSICoverageInfoTable => '1.3.6.1.4.1.14179.2.2.18',
      bsnAPIfStationRSSICoverageInfoEntry => '1.3.6.1.4.1.14179.2.2.18.1',
      bsnAPIfStationRSSICoverageIndex => '1.3.6.1.4.1.14179.2.2.18.1.1',
      bsnAPIfRSSILevel => '1.3.6.1.4.1.14179.2.2.18.1.2',
      bsnAPIfStationCountOnRSSI => '1.3.6.1.4.1.14179.2.2.18.1.23',
      bsnAPIfStationSNRCoverageInfoTable => '1.3.6.1.4.1.14179.2.2.19',
      bsnAPIfStationSNRCoverageInfoEntry => '1.3.6.1.4.1.14179.2.2.19.1',
      bsnAPIfStationSNRCoverageIndex => '1.3.6.1.4.1.14179.2.2.19.1.1',
      bsnAPIfSNRLevel => '1.3.6.1.4.1.14179.2.2.19.1.2',
      bsnAPIfStationCountOnSNR => '1.3.6.1.4.1.14179.2.2.19.1.23',
      bsnAPIfTable => '1.3.6.1.4.1.14179.2.2.2',
      bsnAPIfEntry => '1.3.6.1.4.1.14179.2.2.2.1',
      bsnAPIfSlotId => '1.3.6.1.4.1.14179.2.2.2.1.1',
      bsnAPIfCellSiteConfigId => '1.3.6.1.4.1.14179.2.2.2.1.10',
      bsnAPIfNumberOfVaps => '1.3.6.1.4.1.14179.2.2.2.1.11',
      bsnAPIfOperStatus => '1.3.6.1.4.1.14179.2.2.2.1.12',
      bsnAPIfPortNumber => '1.3.6.1.4.1.14179.2.2.2.1.13',
      bsnAPIfPhyAntennaOptions => '1.3.6.1.4.1.14179.2.2.2.1.14',
      bsnApIfNoOfUsers => '1.3.6.1.4.1.14179.2.2.2.1.15',
      bsnAPIfWlanOverride => '1.3.6.1.4.1.14179.2.2.2.1.16',
      bsnAPIfPacketsSniffingFeature => '1.3.6.1.4.1.14179.2.2.2.1.17',
      bsnAPIfSniffChannel => '1.3.6.1.4.1.14179.2.2.2.1.18',
      bsnAPIfSniffServerIPAddress => '1.3.6.1.4.1.14179.2.2.2.1.19',
      bsnAPIfType => '1.3.6.1.4.1.14179.2.2.2.1.2',
      bsnAPIfAntennaGain => '1.3.6.1.4.1.14179.2.2.2.1.20',
      bsnAPIfChannelList => '1.3.6.1.4.1.14179.2.2.2.1.21',
      bsnAPIfAbsolutePowerList => '1.3.6.1.4.1.14179.2.2.2.1.22',
      bsnAPIfRegulatoryDomainSupport => '1.3.6.1.4.1.14179.2.2.2.1.23',
      bsnAPIfPhyChannelAssignment => '1.3.6.1.4.1.14179.2.2.2.1.3',
      bsnAPIfAdminStatus => '1.3.6.1.4.1.14179.2.2.2.1.34',
      bsnAPIfPhyChannelNumber => '1.3.6.1.4.1.14179.2.2.2.1.4',
      bsnAPIfPhyTxPowerControl => '1.3.6.1.4.1.14179.2.2.2.1.5',
      bsnAPIfPhyTxPowerLevel => '1.3.6.1.4.1.14179.2.2.2.1.6',
      bsnAPIfPhyAntennaMode => '1.3.6.1.4.1.14179.2.2.2.1.7',
      bsnAPIfPhyAntennaType => '1.3.6.1.4.1.14179.2.2.2.1.8',
      bsnAPIfPhyAntennaDiversity => '1.3.6.1.4.1.14179.2.2.2.1.9',
      bsnAPIfRecommendedRFParametersTable => '1.3.6.1.4.1.14179.2.2.20',
      bsnAPIfRecommendedRFParametersEntry => '1.3.6.1.4.1.14179.2.2.20.1',
      bsnAPIfRecommendedChannelNumber => '1.3.6.1.4.1.14179.2.2.20.1.1',
      bsnAPIfRecommendedTxPowerLevel => '1.3.6.1.4.1.14179.2.2.20.1.2',
      bsnAPIfRecommendedFragmentationThreshold => '1.3.6.1.4.1.14179.2.2.20.1.24',
      bsnAPIfRecommendedRTSThreshold => '1.3.6.1.4.1.14179.2.2.20.1.3',
      bsnAPIfWlanOverrideTable => '1.3.6.1.4.1.14179.2.2.21',
      bsnAPIfWlanOverrideEntry => '1.3.6.1.4.1.14179.2.2.21.1',
      bsnAPIfWlanOverrideId => '1.3.6.1.4.1.14179.2.2.21.1.1',
      bsnAPIfWlanOverrideRowStatus => '1.3.6.1.4.1.14179.2.2.21.1.15',
      bsnAPIfWlanOverrideSsid => '1.3.6.1.4.1.14179.2.2.21.1.2',
      bsnMeshNodeTable => '1.3.6.1.4.1.14179.2.2.22',
      bsnMeshNodeEntry => '1.3.6.1.4.1.14179.2.2.22.1',
      bsnMeshNodeRole => '1.3.6.1.4.1.14179.2.2.22.1.1',
      bsnMeshNodePoorNeighSnr => '1.3.6.1.4.1.14179.2.2.22.1.10',
      bsnMeshNodeBlacklistPackets => '1.3.6.1.4.1.14179.2.2.22.1.11',
      bsnMeshNodeInsufficientMemory => '1.3.6.1.4.1.14179.2.2.22.1.12',
      bsnMeshNodeRxNeighReq => '1.3.6.1.4.1.14179.2.2.22.1.13',
      bsnMeshNodeRxNeighRsp => '1.3.6.1.4.1.14179.2.2.22.1.14',
      bsnMeshNodeTxNeighReq => '1.3.6.1.4.1.14179.2.2.22.1.15',
      bsnMeshNodeTxNeighRsp => '1.3.6.1.4.1.14179.2.2.22.1.16',
      bsnMeshNodeParentChanges => '1.3.6.1.4.1.14179.2.2.22.1.17',
      bsnMeshNodeNeighTimeout => '1.3.6.1.4.1.14179.2.2.22.1.18',
      bsnMeshNodeParentMacAddress => '1.3.6.1.4.1.14179.2.2.22.1.19',
      bsnMeshNodeGroup => '1.3.6.1.4.1.14179.2.2.22.1.2',
      bsnMeshNodeAPType => '1.3.6.1.4.1.14179.2.2.22.1.20',
      bsnMeshNodeEthernetBridge => '1.3.6.1.4.1.14179.2.2.22.1.21',
      bsnMeshNodeBackhaul => '1.3.6.1.4.1.14179.2.2.22.1.3',
      bsnMeshNodeHops => '1.3.6.1.4.1.14179.2.2.22.1.30',
      bsnMeshNodeBackhaulPAP => '1.3.6.1.4.1.14179.2.2.22.1.4',
      bsnMeshNodeBackhaulRAP => '1.3.6.1.4.1.14179.2.2.22.1.5',
      bsnMeshNodeDataRate => '1.3.6.1.4.1.14179.2.2.22.1.6',
      bsnMeshNodeChannel => '1.3.6.1.4.1.14179.2.2.22.1.7',
      bsnMeshNodeRoutingState => '1.3.6.1.4.1.14179.2.2.22.1.8',
      bsnMeshNodeMalformedNeighPackets => '1.3.6.1.4.1.14179.2.2.22.1.9',
      bsnMeshNeighsTable => '1.3.6.1.4.1.14179.2.2.23',
      bsnMeshNeighsEntry => '1.3.6.1.4.1.14179.2.2.23.1',
      bsnMeshNeighMacAddress => '1.3.6.1.4.1.14179.2.2.23.1.1',
      bsnMeshNeighRapEase => '1.3.6.1.4.1.14179.2.2.23.1.10',
      bsnMeshNeighTxParent => '1.3.6.1.4.1.14179.2.2.23.1.11',
      bsnMeshNeighRxParent => '1.3.6.1.4.1.14179.2.2.23.1.12',
      bsnMeshNeighPoorSnr => '1.3.6.1.4.1.14179.2.2.23.1.13',
      bsnMeshNeighLastUpdate => '1.3.6.1.4.1.14179.2.2.23.1.14',
      bsnMeshNeighType => '1.3.6.1.4.1.14179.2.2.23.1.2',
      bsnMeshNeighParentChange => '1.3.6.1.4.1.14179.2.2.23.1.20',
      bsnMeshNeighState => '1.3.6.1.4.1.14179.2.2.23.1.3',
      bsnMeshNeighSnr => '1.3.6.1.4.1.14179.2.2.23.1.4',
      bsnMeshNeighSnrUp => '1.3.6.1.4.1.14179.2.2.23.1.5',
      bsnMeshNeighSnrDown => '1.3.6.1.4.1.14179.2.2.23.1.6',
      bsnMeshNeighLinkSnr => '1.3.6.1.4.1.14179.2.2.23.1.7',
      bsnMeshNeighAdjustedEase => '1.3.6.1.4.1.14179.2.2.23.1.8',
      bsnMeshNeighUnadjustedEase => '1.3.6.1.4.1.14179.2.2.23.1.9',
      bsnAPIfRadarChannelStatisticsTable => '1.3.6.1.4.1.14179.2.2.24',
      bsnAPIfRadarChannelStatisticsEntry => '1.3.6.1.4.1.14179.2.2.24.1',
      bsnAPIfRadarDetectedChannelNumber => '1.3.6.1.4.1.14179.2.2.24.1.1',
      bsnAPIfRadarSignalLastHeard => '1.3.6.1.4.1.14179.2.2.24.1.2',
      bsnAPIfSmtParamTable => '1.3.6.1.4.1.14179.2.2.3',
      bsnAPIfSmtParamEntry => '1.3.6.1.4.1.14179.2.2.3.1',
      bsnAPIfDot11BeaconPeriod => '1.3.6.1.4.1.14179.2.2.3.1.1',
      bsnAPIfDot11SmtParamsConfigType => '1.3.6.1.4.1.14179.2.2.3.1.10',
      bsnAPIfDot11MediumOccupancyLimit => '1.3.6.1.4.1.14179.2.2.3.1.2',
      bsnAPIfDot11CFPPeriod => '1.3.6.1.4.1.14179.2.2.3.1.3',
      bsnAPIfDot11BSSID => '1.3.6.1.4.1.14179.2.2.3.1.30',
      bsnAPIfDot11CFPMaxDuration => '1.3.6.1.4.1.14179.2.2.3.1.4',
      bsnAPIfDot11OperationalRateSet => '1.3.6.1.4.1.14179.2.2.3.1.5',
      bsnAPIfDot11DTIMPeriod => '1.3.6.1.4.1.14179.2.2.3.1.6',
      bsnAPIfDot11MultiDomainCapabilityImplemented => '1.3.6.1.4.1.14179.2.2.3.1.7',
      bsnAPIfDot11MultiDomainCapabilityEnabled => '1.3.6.1.4.1.14179.2.2.3.1.8',
      bsnAPIfDot11CountryString => '1.3.6.1.4.1.14179.2.2.3.1.9',
      bsnAPIfMultiDomainCapabilityTable => '1.3.6.1.4.1.14179.2.2.4',
      bsnAPIfMultiDomainCapabilityEntry => '1.3.6.1.4.1.14179.2.2.4.1',
      bsnAPIfDot11MaximumTransmitPowerLevel => '1.3.6.1.4.1.14179.2.2.4.1.1',
      bsnAPIfDot11FirstChannelNumber => '1.3.6.1.4.1.14179.2.2.4.1.2',
      bsnAPIfDot11NumberofChannels => '1.3.6.1.4.1.14179.2.2.4.1.20',
      bsnAPIfMacOperationParamTable => '1.3.6.1.4.1.14179.2.2.5',
      bsnAPIfMacOperationParamEntry => '1.3.6.1.4.1.14179.2.2.5.1',
      bsnAPIfDot11MacRTSThreshold => '1.3.6.1.4.1.14179.2.2.5.1.1',
      bsnAPIfDot11MacShortRetryLimit => '1.3.6.1.4.1.14179.2.2.5.1.2',
      bsnAPIfDot11MacMaxReceiveLifetime => '1.3.6.1.4.1.14179.2.2.5.1.25',
      bsnAPIfDot11MacLongRetryLimit => '1.3.6.1.4.1.14179.2.2.5.1.3',
      bsnAPIfDot11MacFragmentationThreshold => '1.3.6.1.4.1.14179.2.2.5.1.4',
      bsnAPIfDot11MacMaxTransmitMSDULifetime => '1.3.6.1.4.1.14179.2.2.5.1.5',
      bsnAPIfDot11MacParamsConfigType => '1.3.6.1.4.1.14179.2.2.5.1.6',
      bsnAPIfDot11CountersTable => '1.3.6.1.4.1.14179.2.2.6',
      bsnAPIfDot11CountersEntry => '1.3.6.1.4.1.14179.2.2.6.1',
      bsnAPIfDot11TransmittedFragmentCount => '1.3.6.1.4.1.14179.2.2.6.1.1',
      bsnAPIfDot11MulticastReceivedFrameCount => '1.3.6.1.4.1.14179.2.2.6.1.10',
      bsnAPIfDot11FCSErrorCount => '1.3.6.1.4.1.14179.2.2.6.1.11',
      bsnAPIfDot11TransmittedFrameCount => '1.3.6.1.4.1.14179.2.2.6.1.12',
      bsnAPIfDot11WEPUndecryptableCount => '1.3.6.1.4.1.14179.2.2.6.1.13',
      bsnAPIfDot11MulticastTransmittedFrameCount => '1.3.6.1.4.1.14179.2.2.6.1.2',
      bsnAPIfDot11RetryCount => '1.3.6.1.4.1.14179.2.2.6.1.3',
      bsnAPIfDot11FailedCount => '1.3.6.1.4.1.14179.2.2.6.1.33',
      bsnAPIfDot11MultipleRetryCount => '1.3.6.1.4.1.14179.2.2.6.1.4',
      bsnAPIfDot11FrameDuplicateCount => '1.3.6.1.4.1.14179.2.2.6.1.5',
      bsnAPIfDot11RTSSuccessCount => '1.3.6.1.4.1.14179.2.2.6.1.6',
      bsnAPIfDot11RTSFailureCount => '1.3.6.1.4.1.14179.2.2.6.1.7',
      bsnAPIfDot11ACKFailureCount => '1.3.6.1.4.1.14179.2.2.6.1.8',
      bsnAPIfDot11ReceivedFragmentCount => '1.3.6.1.4.1.14179.2.2.6.1.9',
      bsnAPIfDot11PhyTxPowerTable => '1.3.6.1.4.1.14179.2.2.8',
      bsnAPIfDot11PhyTxPowerEntry => '1.3.6.1.4.1.14179.2.2.8.1',
      bsnAPIfDot11NumberSupportedPowerLevels => '1.3.6.1.4.1.14179.2.2.8.1.1',
      bsnAPIfDot11TxPowerLevel1 => '1.3.6.1.4.1.14179.2.2.8.1.2',
      bsnAPIfDot11TxPowerLevel8 => '1.3.6.1.4.1.14179.2.2.8.1.28',
      bsnAPIfDot11TxPowerLevel2 => '1.3.6.1.4.1.14179.2.2.8.1.3',
      bsnAPIfDot11TxPowerLevel3 => '1.3.6.1.4.1.14179.2.2.8.1.4',
      bsnAPIfDot11TxPowerLevel4 => '1.3.6.1.4.1.14179.2.2.8.1.5',
      bsnAPIfDot11TxPowerLevel5 => '1.3.6.1.4.1.14179.2.2.8.1.6',
      bsnAPIfDot11TxPowerLevel6 => '1.3.6.1.4.1.14179.2.2.8.1.7',
      bsnAPIfDot11TxPowerLevel7 => '1.3.6.1.4.1.14179.2.2.8.1.8',
      bsnAPIfDot11PhyChannelTable => '1.3.6.1.4.1.14179.2.2.9',
      bsnAPIfDot11PhyChannelEntry => '1.3.6.1.4.1.14179.2.2.9.1',
      bsnAPIfDot11CurrentCCAMode => '1.3.6.1.4.1.14179.2.2.9.1.1',
      bsnAPIfDot11EDThreshold => '1.3.6.1.4.1.14179.2.2.9.1.2',
      bsnAPIfDot11TIThreshold => '1.3.6.1.4.1.14179.2.2.9.1.23',
      bsnGlobalDot11 => '1.3.6.1.4.1.14179.2.3',
      bsnGlobalDot11Config => '1.3.6.1.4.1.14179.2.3.1',
      bsnGlobalDot11PrivacyOptionImplemented => '1.3.6.1.4.1.14179.2.3.1.1',
      bsnSystemCurrentTime => '1.3.6.1.4.1.14179.2.3.1.10',
      bsnUpdateSystemTime => '1.3.6.1.4.1.14179.2.3.1.11',
      bsnOperatingTemperatureEnvironment => '1.3.6.1.4.1.14179.2.3.1.12',
      bsnOperatingTemperatureEnvironmentDefinition => {
          0 => 'unknown',
          1 => 'commercial', # 0 - 40
          2 => 'industrial', # -10 - 70
      },
      bsnSensorTemperature => '1.3.6.1.4.1.14179.2.3.1.13',
      bsnTemperatureAlarmLowLimit => '1.3.6.1.4.1.14179.2.3.1.14',
      bsnTemperatureAlarmHighLimit => '1.3.6.1.4.1.14179.2.3.1.15',
      bsnVirtualGatewayAddress => '1.3.6.1.4.1.14179.2.3.1.16',
      bsnRFMobilityDomainName => '1.3.6.1.4.1.14179.2.3.1.17',
      bsnClientWatchListFeature => '1.3.6.1.4.1.14179.2.3.1.18',
      bsnRogueLocationDiscoveryProtocol => '1.3.6.1.4.1.14179.2.3.1.19',
      bsnGlobalDot11AuthenticationResponseTimeOut => '1.3.6.1.4.1.14179.2.3.1.2',
      bsnRogueAutoContainFeature => '1.3.6.1.4.1.14179.2.3.1.20',
      bsnOverAirProvisionApMode => '1.3.6.1.4.1.14179.2.3.1.21',
      bsnMaximumNumberOfConcurrentLogins => '1.3.6.1.4.1.14179.2.3.1.22',
      bsnAutoContainRoguesAdvertisingSsid => '1.3.6.1.4.1.14179.2.3.1.23',
      bsnAutoContainAdhocNetworks => '1.3.6.1.4.1.14179.2.3.1.24',
      bsnAutoContainTrustedClientsOnRogueAps => '1.3.6.1.4.1.14179.2.3.1.25',
      bsnValidateRogueClientsAgainstAAA => '1.3.6.1.4.1.14179.2.3.1.26',
      bsnSystemTimezoneDelta => '1.3.6.1.4.1.14179.2.3.1.27',
      bsnSystemTimezoneDaylightSavings => '1.3.6.1.4.1.14179.2.3.1.28',
      bsnAllowAuthorizeApAgainstAAA => '1.3.6.1.4.1.14179.2.3.1.29',
      bsnGlobalDot11MultiDomainCapabilityImplemented => '1.3.6.1.4.1.14179.2.3.1.3',
      bsnSystemTimezoneDeltaMinutes => '1.3.6.1.4.1.14179.2.3.1.30',
      bsnApFallbackEnabled => '1.3.6.1.4.1.14179.2.3.1.31',
      bsnAppleTalkEnabled => '1.3.6.1.4.1.14179.2.3.1.32',
      bsnGlobalDot11MultiDomainCapabilityEnabled => '1.3.6.1.4.1.14179.2.3.1.4',
      bsnTrustedApPolicyConfig => '1.3.6.1.4.1.14179.2.3.1.40',
      bsnPolicyForMisconfiguredAps => '1.3.6.1.4.1.14179.2.3.1.40.1',
      bsnEncryptionPolicyEnforced => '1.3.6.1.4.1.14179.2.3.1.40.2',
      bsnPreamblePolicyEnforced => '1.3.6.1.4.1.14179.2.3.1.40.3',
      bsnDot11ModePolicyEnforced => '1.3.6.1.4.1.14179.2.3.1.40.4',
      bsnRadioTypePolicyEnforced => '1.3.6.1.4.1.14179.2.3.1.40.5',
      bsnValidateSsidForTrustedAp => '1.3.6.1.4.1.14179.2.3.1.40.6',
      bsnAlertIfTrustedApMissing => '1.3.6.1.4.1.14179.2.3.1.40.7',
      bsnTrustedApEntryExpirationTimeout => '1.3.6.1.4.1.14179.2.3.1.40.8',
      bsnClientExclusionPolicyConfig => '1.3.6.1.4.1.14179.2.3.1.41',
      bsnExcessive80211AssocFailures => '1.3.6.1.4.1.14179.2.3.1.41.1',
      bsnExcessive80211AuthFailures => '1.3.6.1.4.1.14179.2.3.1.41.2',
      bsnExcessive8021xAuthFailures => '1.3.6.1.4.1.14179.2.3.1.41.3',
      bsnExternalPolicyServerFailures => '1.3.6.1.4.1.14179.2.3.1.41.4',
      bsnExcessiveWebAuthFailures => '1.3.6.1.4.1.14179.2.3.1.41.5',
      bsnIPTheftORReuse => '1.3.6.1.4.1.14179.2.3.1.41.6',
      bsnSignatureConfig => '1.3.6.1.4.1.14179.2.3.1.42',
      bsnStandardSignatureTable => '1.3.6.1.4.1.14179.2.3.1.42.1',
      bsnStandardSignatureEntry => '1.3.6.1.4.1.14179.2.3.1.42.1.1',
      bsnStandardSignaturePrecedence => '1.3.6.1.4.1.14179.2.3.1.42.1.1.1',
      bsnStandardSignatureConfigType => '1.3.6.1.4.1.14179.2.3.1.42.1.1.10',
      bsnStandardSignatureEnable => '1.3.6.1.4.1.14179.2.3.1.42.1.1.11',
      bsnStandardSignatureMacInfo => '1.3.6.1.4.1.14179.2.3.1.42.1.1.12',
      bsnStandardSignatureMacFreq => '1.3.6.1.4.1.14179.2.3.1.42.1.1.13',
      bsnStandardSignatureName => '1.3.6.1.4.1.14179.2.3.1.42.1.1.2',
      bsnStandardSignatureRowStatus => '1.3.6.1.4.1.14179.2.3.1.42.1.1.20',
      bsnStandardSignatureInterval => '1.3.6.1.4.1.14179.2.3.1.42.1.1.21',
      bsnStandardSignatureDescription => '1.3.6.1.4.1.14179.2.3.1.42.1.1.3',
      bsnStandardSignatureFrameType => '1.3.6.1.4.1.14179.2.3.1.42.1.1.4',
      bsnStandardSignatureAction => '1.3.6.1.4.1.14179.2.3.1.42.1.1.5',
      bsnStandardSignatureState => '1.3.6.1.4.1.14179.2.3.1.42.1.1.6',
      bsnStandardSignatureFrequency => '1.3.6.1.4.1.14179.2.3.1.42.1.1.7',
      bsnStandardSignatureQuietTime => '1.3.6.1.4.1.14179.2.3.1.42.1.1.8',
      bsnStandardSignatureVersion => '1.3.6.1.4.1.14179.2.3.1.42.1.1.9',
      bsnStandardSignaturePatternTable => '1.3.6.1.4.1.14179.2.3.1.42.2',
      bsnStandardSignaturePatternEntry => '1.3.6.1.4.1.14179.2.3.1.42.2.1',
      bsnStandardSignaturePatternIndex => '1.3.6.1.4.1.14179.2.3.1.42.2.1.1',
      bsnStandardSignaturePatternRowStatus => '1.3.6.1.4.1.14179.2.3.1.42.2.1.15',
      bsnStandardSignaturePatternOffset => '1.3.6.1.4.1.14179.2.3.1.42.2.1.2',
      bsnStandardSignaturePatternString => '1.3.6.1.4.1.14179.2.3.1.42.2.1.3',
      bsnStandardSignaturePatternMask => '1.3.6.1.4.1.14179.2.3.1.42.2.1.4',
      bsnStandardSignaturePatternOffSetStart => '1.3.6.1.4.1.14179.2.3.1.42.2.1.5',
      bsnCustomSignatureTable => '1.3.6.1.4.1.14179.2.3.1.42.3',
      bsnCustomSignatureEntry => '1.3.6.1.4.1.14179.2.3.1.42.3.1',
      bsnCustomSignaturePrecedence => '1.3.6.1.4.1.14179.2.3.1.42.3.1.1',
      bsnCustomSignatureConfigType => '1.3.6.1.4.1.14179.2.3.1.42.3.1.10',
      bsnCustomSignatureEnable => '1.3.6.1.4.1.14179.2.3.1.42.3.1.11',
      bsnCustomSignatureMacInfo => '1.3.6.1.4.1.14179.2.3.1.42.3.1.12',
      bsnCustomSignatureMacFreq => '1.3.6.1.4.1.14179.2.3.1.42.3.1.13',
      bsnCustomSignatureName => '1.3.6.1.4.1.14179.2.3.1.42.3.1.2',
      bsnCustomSignatureRowStatus => '1.3.6.1.4.1.14179.2.3.1.42.3.1.20',
      bsnCustomSignatureInterval => '1.3.6.1.4.1.14179.2.3.1.42.3.1.21',
      bsnCustomSignatureDescription => '1.3.6.1.4.1.14179.2.3.1.42.3.1.3',
      bsnCustomSignatureFrameType => '1.3.6.1.4.1.14179.2.3.1.42.3.1.4',
      bsnCustomSignatureAction => '1.3.6.1.4.1.14179.2.3.1.42.3.1.5',
      bsnCustomSignatureState => '1.3.6.1.4.1.14179.2.3.1.42.3.1.6',
      bsnCustomSignatureFrequency => '1.3.6.1.4.1.14179.2.3.1.42.3.1.7',
      bsnCustomSignatureQuietTime => '1.3.6.1.4.1.14179.2.3.1.42.3.1.8',
      bsnCustomSignatureVersion => '1.3.6.1.4.1.14179.2.3.1.42.3.1.9',
      bsnCustomSignaturePatternTable => '1.3.6.1.4.1.14179.2.3.1.42.4',
      bsnCustomSignaturePatternEntry => '1.3.6.1.4.1.14179.2.3.1.42.4.1',
      bsnCustomSignaturePatternIndex => '1.3.6.1.4.1.14179.2.3.1.42.4.1.1',
      bsnCustomSignaturePatternRowStatus => '1.3.6.1.4.1.14179.2.3.1.42.4.1.15',
      bsnCustomSignaturePatternOffset => '1.3.6.1.4.1.14179.2.3.1.42.4.1.2',
      bsnCustomSignaturePatternString => '1.3.6.1.4.1.14179.2.3.1.42.4.1.3',
      bsnCustomSignaturePatternMask => '1.3.6.1.4.1.14179.2.3.1.42.4.1.4',
      bsnCustomSignaturePatternOffSetStart => '1.3.6.1.4.1.14179.2.3.1.42.4.1.5',
      bsnSignatureCheckState => '1.3.6.1.4.1.14179.2.3.1.42.5',
      bsnRfIdTagConfig => '1.3.6.1.4.1.14179.2.3.1.43',
      bsnRfIdTagStatus => '1.3.6.1.4.1.14179.2.3.1.43.1',
      bsnRfIdTagDataTimeout => '1.3.6.1.4.1.14179.2.3.1.43.2',
      bsnRfIdTagAutoTimeoutStatus => '1.3.6.1.4.1.14179.2.3.1.43.3',
      bsnAPNeighborAuthConfig => '1.3.6.1.4.1.14179.2.3.1.44',
      bsnAPNeighborAuthStatus => '1.3.6.1.4.1.14179.2.3.1.44.1',
      bsnAPNeighborAuthAlarmThreshold => '1.3.6.1.4.1.14179.2.3.1.44.2',
      bsnRFNetworkName => '1.3.6.1.4.1.14179.2.3.1.45',
      bsnFastSSIDChangeFeature => '1.3.6.1.4.1.14179.2.3.1.46',
      bsnBridgingPolicyConfig => '1.3.6.1.4.1.14179.2.3.1.47',
      bsnBridgingZeroTouchConfig => '1.3.6.1.4.1.14179.2.3.1.47.1',
      bsnBridgingSharedSecretKey => '1.3.6.1.4.1.14179.2.3.1.47.2',
      bsnAcceptSelfSignedCertificate => '1.3.6.1.4.1.14179.2.3.1.48',
      bsnSystemClockTime => '1.3.6.1.4.1.14179.2.3.1.49',
      bsnGlobalDot11CountryIndex => '1.3.6.1.4.1.14179.2.3.1.5',
      bsnGlobalDot11LoadBalancing => '1.3.6.1.4.1.14179.2.3.1.6',
      bsnGlobalDot11RogueTimer => '1.3.6.1.4.1.14179.2.3.1.7',
      bsnPrimaryMwarForAPs => '1.3.6.1.4.1.14179.2.3.1.8',
      bsnRtpProtocolPriority => '1.3.6.1.4.1.14179.2.3.1.9',
      bsnGlobalDot11b => '1.3.6.1.4.1.14179.2.3.2',
      bsnGlobalDot11bConfig => '1.3.6.1.4.1.14179.2.3.2.1',
      bsnGlobalDot11bNetworkStatus => '1.3.6.1.4.1.14179.2.3.2.1.1',
      bsnGlobalDot11bDynamicTxPowerControlInterval => '1.3.6.1.4.1.14179.2.3.2.1.10',
      bsnGlobalDot11bCurrentTxPowerLevel => '1.3.6.1.4.1.14179.2.3.2.1.11',
      bsnGlobalDot11bInputsForDTP => '1.3.6.1.4.1.14179.2.3.2.1.12',
      bsnGlobalDot11bPowerUpdateCmdInvoke => '1.3.6.1.4.1.14179.2.3.2.1.13',
      bsnGlobalDot11bPowerUpdateCmdStatus => '1.3.6.1.4.1.14179.2.3.2.1.14',
      bsnGlobalDot11bDataRate1Mhz => '1.3.6.1.4.1.14179.2.3.2.1.15',
      bsnGlobalDot11bDataRate2Mhz => '1.3.6.1.4.1.14179.2.3.2.1.16',
      bsnGlobalDot11bDataRate5AndHalfMhz => '1.3.6.1.4.1.14179.2.3.2.1.17',
      bsnGlobalDot11bDataRate11Mhz => '1.3.6.1.4.1.14179.2.3.2.1.18',
      bsnGlobalDot11bShortPreamble => '1.3.6.1.4.1.14179.2.3.2.1.19',
      bsnGlobalDot11bBeaconPeriod => '1.3.6.1.4.1.14179.2.3.2.1.2',
      bsnGlobalDot11bDot11gSupport => '1.3.6.1.4.1.14179.2.3.2.1.20',
      bsnGlobalDot11bDataRate6Mhz => '1.3.6.1.4.1.14179.2.3.2.1.21',
      bsnGlobalDot11bDataRate9Mhz => '1.3.6.1.4.1.14179.2.3.2.1.22',
      bsnGlobalDot11bDataRate12Mhz => '1.3.6.1.4.1.14179.2.3.2.1.23',
      bsnGlobalDot11bDataRate18Mhz => '1.3.6.1.4.1.14179.2.3.2.1.24',
      bsnGlobalDot11bDataRate24Mhz => '1.3.6.1.4.1.14179.2.3.2.1.25',
      bsnGlobalDot11bDataRate36Mhz => '1.3.6.1.4.1.14179.2.3.2.1.26',
      bsnGlobalDot11bDataRate48Mhz => '1.3.6.1.4.1.14179.2.3.2.1.27',
      bsnGlobalDot11bDataRate54Mhz => '1.3.6.1.4.1.14179.2.3.2.1.28',
      bsnGlobalDot11bPicoCellMode => '1.3.6.1.4.1.14179.2.3.2.1.29',
      bsnGlobalDot11bDynamicChannelAssignment => '1.3.6.1.4.1.14179.2.3.2.1.3',
      bsnGlobalDot11bFastRoamingMode => '1.3.6.1.4.1.14179.2.3.2.1.30',
      bsnGlobalDot11bFastRoamingVoipMinRate => '1.3.6.1.4.1.14179.2.3.2.1.31',
      bsnGlobalDot11bFastRoamingVoipPercentage => '1.3.6.1.4.1.14179.2.3.2.1.32',
      bsnGlobalDot11b80211eMaxBandwidth => '1.3.6.1.4.1.14179.2.3.2.1.33',
      bsnGlobalDot11bDTPCSupport => '1.3.6.1.4.1.14179.2.3.2.1.34',
      bsnGlobalDot11bCurrentChannel => '1.3.6.1.4.1.14179.2.3.2.1.4',
      bsnGlobalDot11bDynamicChannelUpdateInterval => '1.3.6.1.4.1.14179.2.3.2.1.5',
      bsnGlobalDot11bInputsForDCA => '1.3.6.1.4.1.14179.2.3.2.1.6',
      bsnGlobalDot11bChannelUpdateCmdInvoke => '1.3.6.1.4.1.14179.2.3.2.1.7',
      bsnGlobalDot11bChannelUpdateCmdStatus => '1.3.6.1.4.1.14179.2.3.2.1.8',
      bsnGlobalDot11bDynamicTransmitPowerControl => '1.3.6.1.4.1.14179.2.3.2.1.9',
      bsnGlobalDot11bPhy => '1.3.6.1.4.1.14179.2.3.2.2',
      bsnGlobalDot11bMediumOccupancyLimit => '1.3.6.1.4.1.14179.2.3.2.2.1',
      bsnGlobalDot11bNumberofChannels => '1.3.6.1.4.1.14179.2.3.2.2.10',
      bsnGlobalDot11bRTSThreshold => '1.3.6.1.4.1.14179.2.3.2.2.11',
      bsnGlobalDot11bShortRetryLimit => '1.3.6.1.4.1.14179.2.3.2.2.12',
      bsnGlobalDot11bLongRetryLimit => '1.3.6.1.4.1.14179.2.3.2.2.13',
      bsnGlobalDot11bFragmentationThreshold => '1.3.6.1.4.1.14179.2.3.2.2.14',
      bsnGlobalDot11bMaxTransmitMSDULifetime => '1.3.6.1.4.1.14179.2.3.2.2.15',
      bsnGlobalDot11bMaxReceiveLifetime => '1.3.6.1.4.1.14179.2.3.2.2.16',
      bsnGlobalDot11bEDThreshold => '1.3.6.1.4.1.14179.2.3.2.2.17',
      bsnGlobalDot11bChannelAgilityEnabled => '1.3.6.1.4.1.14179.2.3.2.2.18',
      bsnGlobalDot11bPBCCOptionImplemented => '1.3.6.1.4.1.14179.2.3.2.2.19',
      bsnGlobalDot11bCFPPeriod => '1.3.6.1.4.1.14179.2.3.2.2.2',
      bsnGlobalDot11bShortPreambleOptionImplemented => '1.3.6.1.4.1.14179.2.3.2.2.20',
      bsnGlobalDot11bCFPMaxDuration => '1.3.6.1.4.1.14179.2.3.2.2.3',
      bsnGlobalDot11bCFPollable => '1.3.6.1.4.1.14179.2.3.2.2.5',
      bsnGlobalDot11bCFPollRequest => '1.3.6.1.4.1.14179.2.3.2.2.6',
      bsnGlobalDot11bDTIMPeriod => '1.3.6.1.4.1.14179.2.3.2.2.7',
      bsnGlobalDot11bMaximumTransmitPowerLevel => '1.3.6.1.4.1.14179.2.3.2.2.8',
      bsnGlobalDot11bFirstChannelNumber => '1.3.6.1.4.1.14179.2.3.2.2.9',
      bsnGlobalDot11a => '1.3.6.1.4.1.14179.2.3.3',
      bsnGlobalDot11aConfig => '1.3.6.1.4.1.14179.2.3.3.1',
      bsnGlobalDot11aNetworkStatus => '1.3.6.1.4.1.14179.2.3.3.1.1',
      bsnGlobalDot11aChannelUpdateCmdInvoke => '1.3.6.1.4.1.14179.2.3.3.1.10',
      bsnGlobalDot11aChannelUpdateCmdStatus => '1.3.6.1.4.1.14179.2.3.3.1.11',
      bsnGlobalDot11aDynamicTransmitPowerControl => '1.3.6.1.4.1.14179.2.3.3.1.12',
      bsnGlobalDot11aCurrentTxPowerLevel => '1.3.6.1.4.1.14179.2.3.3.1.13',
      bsnGlobalDot11aDynamicTxPowerControlInterval => '1.3.6.1.4.1.14179.2.3.3.1.14',
      bsnGlobalDot11aInputsForDTP => '1.3.6.1.4.1.14179.2.3.3.1.15',
      bsnGlobalDot11aPowerUpdateCmdInvoke => '1.3.6.1.4.1.14179.2.3.3.1.16',
      bsnGlobalDot11aPowerUpdateCmdStatus => '1.3.6.1.4.1.14179.2.3.3.1.17',
      bsnGlobalDot11aDataRate6Mhz => '1.3.6.1.4.1.14179.2.3.3.1.19',
      bsnGlobalDot11aLowBandNetwork => '1.3.6.1.4.1.14179.2.3.3.1.2',
      bsnGlobalDot11aDataRate9Mhz => '1.3.6.1.4.1.14179.2.3.3.1.20',
      bsnGlobalDot11aDataRate12Mhz => '1.3.6.1.4.1.14179.2.3.3.1.21',
      bsnGlobalDot11aDataRate18Mhz => '1.3.6.1.4.1.14179.2.3.3.1.22',
      bsnGlobalDot11aDataRate24Mhz => '1.3.6.1.4.1.14179.2.3.3.1.23',
      bsnGlobalDot11aDataRate36Mhz => '1.3.6.1.4.1.14179.2.3.3.1.24',
      bsnGlobalDot11aDataRate48Mhz => '1.3.6.1.4.1.14179.2.3.3.1.25',
      bsnGlobalDot11aDataRate54Mhz => '1.3.6.1.4.1.14179.2.3.3.1.26',
      bsnGlobalDot11aPicoCellMode => '1.3.6.1.4.1.14179.2.3.3.1.27',
      bsnGlobalDot11aFastRoamingMode => '1.3.6.1.4.1.14179.2.3.3.1.28',
      bsnGlobalDot11aFastRoamingVoipMinRate => '1.3.6.1.4.1.14179.2.3.3.1.29',
      bsnGlobalDot11aMediumBandNetwork => '1.3.6.1.4.1.14179.2.3.3.1.3',
      bsnGlobalDot11aFastRoamingVoipPercentage => '1.3.6.1.4.1.14179.2.3.3.1.30',
      bsnGlobalDot11a80211eMaxBandwidth => '1.3.6.1.4.1.14179.2.3.3.1.31',
      bsnGlobalDot11aDTPCSupport => '1.3.6.1.4.1.14179.2.3.3.1.32',
      bsnGlobalDot11aHighBandNetwork => '1.3.6.1.4.1.14179.2.3.3.1.4',
      bsnGlobalDot11aBeaconPeriod => '1.3.6.1.4.1.14179.2.3.3.1.5',
      bsnGlobalDot11aDynamicChannelAssignment => '1.3.6.1.4.1.14179.2.3.3.1.6',
      bsnGlobalDot11aCurrentChannel => '1.3.6.1.4.1.14179.2.3.3.1.7',
      bsnGlobalDot11aDynamicChannelUpdateInterval => '1.3.6.1.4.1.14179.2.3.3.1.8',
      bsnGlobalDot11aInputsForDCA => '1.3.6.1.4.1.14179.2.3.3.1.9',
      bsnGlobalDot11aPhy => '1.3.6.1.4.1.14179.2.3.3.2',
      bsnGlobalDot11aMediumOccupancyLimit => '1.3.6.1.4.1.14179.2.3.3.2.1',
      bsnGlobalDot11aNumberofChannels => '1.3.6.1.4.1.14179.2.3.3.2.10',
      bsnGlobalDot11aRTSThreshold => '1.3.6.1.4.1.14179.2.3.3.2.11',
      bsnGlobalDot11aShortRetryLimit => '1.3.6.1.4.1.14179.2.3.3.2.12',
      bsnGlobalDot11aLongRetryLimit => '1.3.6.1.4.1.14179.2.3.3.2.13',
      bsnGlobalDot11aFragmentationThreshold => '1.3.6.1.4.1.14179.2.3.3.2.14',
      bsnGlobalDot11aMaxTransmitMSDULifetime => '1.3.6.1.4.1.14179.2.3.3.2.15',
      bsnGlobalDot11aMaxReceiveLifetime => '1.3.6.1.4.1.14179.2.3.3.2.16',
      bsnGlobalDot11aTIThreshold => '1.3.6.1.4.1.14179.2.3.3.2.17',
      bsnGlobalDot11aChannelAgilityEnabled => '1.3.6.1.4.1.14179.2.3.3.2.18',
      bsnGlobalDot11aCFPPeriod => '1.3.6.1.4.1.14179.2.3.3.2.2',
      bsnGlobalDot11aCFPMaxDuration => '1.3.6.1.4.1.14179.2.3.3.2.3',
      bsnGlobalDot11aCFPollable => '1.3.6.1.4.1.14179.2.3.3.2.5',
      bsnGlobalDot11aCFPollRequest => '1.3.6.1.4.1.14179.2.3.3.2.6',
      bsnGlobalDot11aDTIMPeriod => '1.3.6.1.4.1.14179.2.3.3.2.7',
      bsnGlobalDot11aMaximumTransmitPowerLevel => '1.3.6.1.4.1.14179.2.3.3.2.8',
      bsnGlobalDot11aFirstChannelNumber => '1.3.6.1.4.1.14179.2.3.3.2.9',
      bsnGlobalDot11h => '1.3.6.1.4.1.14179.2.3.4',
      bsnGlobalDot11hConfig => '1.3.6.1.4.1.14179.2.3.4.1',
      bsnGlobalDot11hPowerConstraint => '1.3.6.1.4.1.14179.2.3.4.1.1',
      bsnGlobalDot11hChannelSwitchEnable => '1.3.6.1.4.1.14179.2.3.4.1.2',
      bsnGlobalDot11hChannelSwitchMode => '1.3.6.1.4.1.14179.2.3.4.1.3',
      bsnRrm => '1.3.6.1.4.1.14179.2.4',
      bsnRrmDot11a => '1.3.6.1.4.1.14179.2.4.1',
      bsnRrmDot11aGroup => '1.3.6.1.4.1.14179.2.4.1.1',
      bsnRrmDot11aGlobalAutomaticGrouping => '1.3.6.1.4.1.14179.2.4.1.1.1',
      bsnRrmDot11aGroupLeaderMacAddr => '1.3.6.1.4.1.14179.2.4.1.1.2',
      bsnRrmIsDot11aGroupLeader => '1.3.6.1.4.1.14179.2.4.1.1.3',
      bsnRrmDot11aGroupLastUpdateTime => '1.3.6.1.4.1.14179.2.4.1.1.4',
      bsnRrmDot11aGlobalGroupInterval => '1.3.6.1.4.1.14179.2.4.1.1.5',
      bsnWrasDot11aGroupTable => '1.3.6.1.4.1.14179.2.4.1.1.9',
      bsnWrasDot11aGroupEntry => '1.3.6.1.4.1.14179.2.4.1.1.9.1',
      bsnWrasDot11aPeerMacAddress => '1.3.6.1.4.1.14179.2.4.1.1.9.1.1',
      bsnWrasDot11aPeerIpAddress => '1.3.6.1.4.1.14179.2.4.1.1.9.1.21',
      bsnRrmDot11aAPDefault => '1.3.6.1.4.1.14179.2.4.1.6',
      bsnRrmDot11aForeignInterferenceThreshold => '1.3.6.1.4.1.14179.2.4.1.6.1',
      bsnRrmDot11aNoiseMeasurementInterval => '1.3.6.1.4.1.14179.2.4.1.6.10',
      bsnRrmDot11aLoadMeasurementInterval => '1.3.6.1.4.1.14179.2.4.1.6.11',
      bsnRrmDot11aCoverageMeasurementInterval => '1.3.6.1.4.1.14179.2.4.1.6.12',
      bsnRrmDot11aChannelMonitorList => '1.3.6.1.4.1.14179.2.4.1.6.13',
      bsnRrmDot11aForeignNoiseThreshold => '1.3.6.1.4.1.14179.2.4.1.6.2',
      bsnRrmDot11aRFUtilizationThreshold => '1.3.6.1.4.1.14179.2.4.1.6.3',
      bsnRrmDot11aThroughputThreshold => '1.3.6.1.4.1.14179.2.4.1.6.4',
      bsnRrmDot11aMobilesThreshold => '1.3.6.1.4.1.14179.2.4.1.6.5',
      bsnRrmDot11aCoverageThreshold => '1.3.6.1.4.1.14179.2.4.1.6.6',
      bsnRrmDot11aMobileMinExceptionLevel => '1.3.6.1.4.1.14179.2.4.1.6.7',
      bsnRrmDot11aCoverageExceptionLevel => '1.3.6.1.4.1.14179.2.4.1.6.8',
      bsnRrmDot11aSignalMeasurementInterval => '1.3.6.1.4.1.14179.2.4.1.6.9',
      bsnRrmDot11aSetFactoryDefault => '1.3.6.1.4.1.14179.2.4.1.7',
      bsnRrmDot11b => '1.3.6.1.4.1.14179.2.4.2',
      bsnRrmDot11bGroup => '1.3.6.1.4.1.14179.2.4.2.1',
      bsnRrmDot11bGlobalAutomaticGrouping => '1.3.6.1.4.1.14179.2.4.2.1.1',
      bsnRrmDot11bGroupLeaderMacAddr => '1.3.6.1.4.1.14179.2.4.2.1.2',
      bsnRrmIsDot11bGroupLeader => '1.3.6.1.4.1.14179.2.4.2.1.3',
      bsnRrmDot11bGroupLastUpdateTime => '1.3.6.1.4.1.14179.2.4.2.1.4',
      bsnRrmDot11bGlobalGroupInterval => '1.3.6.1.4.1.14179.2.4.2.1.5',
      bsnWrasDot11bGroupTable => '1.3.6.1.4.1.14179.2.4.2.1.9',
      bsnWrasDot11bGroupEntry => '1.3.6.1.4.1.14179.2.4.2.1.9.1',
      bsnWrasDot11bPeerMacAddress => '1.3.6.1.4.1.14179.2.4.2.1.9.1.1',
      bsnWrasDot11bPeerIpAddress => '1.3.6.1.4.1.14179.2.4.2.1.9.1.21',
      bsnRrmDot11bAPDefault => '1.3.6.1.4.1.14179.2.4.2.6',
      bsnRrmDot11bForeignInterferenceThreshold => '1.3.6.1.4.1.14179.2.4.2.6.1',
      bsnRrmDot11bNoiseMeasurementInterval => '1.3.6.1.4.1.14179.2.4.2.6.10',
      bsnRrmDot11bLoadMeasurementInterval => '1.3.6.1.4.1.14179.2.4.2.6.11',
      bsnRrmDot11bCoverageMeasurementInterval => '1.3.6.1.4.1.14179.2.4.2.6.12',
      bsnRrmDot11bChannelMonitorList => '1.3.6.1.4.1.14179.2.4.2.6.13',
      bsnRrmDot11bForeignNoiseThreshold => '1.3.6.1.4.1.14179.2.4.2.6.2',
      bsnRrmDot11bRFUtilizationThreshold => '1.3.6.1.4.1.14179.2.4.2.6.3',
      bsnRrmDot11bThroughputThreshold => '1.3.6.1.4.1.14179.2.4.2.6.4',
      bsnRrmDot11bMobilesThreshold => '1.3.6.1.4.1.14179.2.4.2.6.5',
      bsnRrmDot11bCoverageThreshold => '1.3.6.1.4.1.14179.2.4.2.6.6',
      bsnRrmDot11bMobileMinExceptionLevel => '1.3.6.1.4.1.14179.2.4.2.6.7',
      bsnRrmDot11bCoverageExceptionLevel => '1.3.6.1.4.1.14179.2.4.2.6.8',
      bsnRrmDot11bSignalMeasurementInterval => '1.3.6.1.4.1.14179.2.4.2.6.9',
      bsnRrmDot11bSetFactoryDefault => '1.3.6.1.4.1.14179.2.4.2.7',
      bsnAAA => '1.3.6.1.4.1.14179.2.5',
      bsnRadiusAuthServerTable => '1.3.6.1.4.1.14179.2.5.1',
      bsnRadiusAuthServerEntry => '1.3.6.1.4.1.14179.2.5.1.1',
      bsnRadiusAuthServerIndex => '1.3.6.1.4.1.14179.2.5.1.1.1',
      bsnRadiusAuthServerIPSecEncryption => '1.3.6.1.4.1.14179.2.5.1.1.10',
      bsnRadiusAuthServerIPSecIKEPhase1 => '1.3.6.1.4.1.14179.2.5.1.1.11',
      bsnRadiusAuthServerIPSecIKELifetime => '1.3.6.1.4.1.14179.2.5.1.1.12',
      bsnRadiusAuthServerIPSecDHGroup => '1.3.6.1.4.1.14179.2.5.1.1.13',
      bsnRadiusAuthServerNetworkUserConfig => '1.3.6.1.4.1.14179.2.5.1.1.14',
      bsnRadiusAuthServerMgmtUserConfig => '1.3.6.1.4.1.14179.2.5.1.1.15',
      bsnRadiusAuthServerRetransmitTimeout => '1.3.6.1.4.1.14179.2.5.1.1.17',
      bsnRadiusAuthServerKeyWrapKEKkey => '1.3.6.1.4.1.14179.2.5.1.1.18',
      bsnRadiusAuthServerKeyWrapMACKkey => '1.3.6.1.4.1.14179.2.5.1.1.19',
      bsnRadiusAuthServerAddress => '1.3.6.1.4.1.14179.2.5.1.1.2',
      bsnRadiusAuthServerKeyWrapFormat => '1.3.6.1.4.1.14179.2.5.1.1.20',
      bsnRadiusAuthServerRowStatus => '1.3.6.1.4.1.14179.2.5.1.1.26',
      bsnRadiusAuthClientServerPortNumber => '1.3.6.1.4.1.14179.2.5.1.1.3',
      bsnRadiusAuthServerKey => '1.3.6.1.4.1.14179.2.5.1.1.4',
      bsnRadiusAuthServerStatus => '1.3.6.1.4.1.14179.2.5.1.1.5',
      bsnRadiusAuthServerKeyFormat => '1.3.6.1.4.1.14179.2.5.1.1.6',
      bsnRadiusAuthServerRFC3576 => '1.3.6.1.4.1.14179.2.5.1.1.7',
      bsnRadiusAuthServerIPSec => '1.3.6.1.4.1.14179.2.5.1.1.8',
      bsnRadiusAuthServerIPSecAuth => '1.3.6.1.4.1.14179.2.5.1.1.9',
      bsnLocalNetUserTable => '1.3.6.1.4.1.14179.2.5.10',
      bsnLocalNetUserEntry => '1.3.6.1.4.1.14179.2.5.10.1',
      bsnLocalNetUserName => '1.3.6.1.4.1.14179.2.5.10.1.1',
      bsnLocalNetUserWlanId => '1.3.6.1.4.1.14179.2.5.10.1.2',
      bsnLocalNetUserRowStatus => '1.3.6.1.4.1.14179.2.5.10.1.24',
      bsnLocalNetUserPassword => '1.3.6.1.4.1.14179.2.5.10.1.3',
      bsnLocalNetUserDescription => '1.3.6.1.4.1.14179.2.5.10.1.4',
      bsnLocalNetUserLifetime => '1.3.6.1.4.1.14179.2.5.10.1.5',
      bsnLocalNetUserStartTime => '1.3.6.1.4.1.14179.2.5.10.1.6',
      bsnLocalNetUserRemainingTime => '1.3.6.1.4.1.14179.2.5.10.1.7',
      bsnLocalManagementUserTable => '1.3.6.1.4.1.14179.2.5.11',
      bsnLocalManagementUserEntry => '1.3.6.1.4.1.14179.2.5.11.1',
      bsnLocalManagementUserName => '1.3.6.1.4.1.14179.2.5.11.1.1',
      bsnLocalManagementUserPassword => '1.3.6.1.4.1.14179.2.5.11.1.2',
      bsnLocalManagementUserRowStatus => '1.3.6.1.4.1.14179.2.5.11.1.23',
      bsnLocalManagementUserAccessMode => '1.3.6.1.4.1.14179.2.5.11.1.3',
      bsnRadiusAuthKeyWrapEnable => '1.3.6.1.4.1.14179.2.5.12',
      bsnRadiusAuthCacheCredentialsLocally => '1.3.6.1.4.1.14179.2.5.14',
      bsnAAAMacDelimiter => '1.3.6.1.4.1.14179.2.5.15',
      bsnAAARadiusCompatibilityMode => '1.3.6.1.4.1.14179.2.5.16',
      bsnAAARadiusCallStationIdType => '1.3.6.1.4.1.14179.2.5.17',
      bsnExternalPolicyServerAclName => '1.3.6.1.4.1.14179.2.5.18',
      bsnExternalPolicyServerTable => '1.3.6.1.4.1.14179.2.5.19',
      bsnExternalPolicyServerEntry => '1.3.6.1.4.1.14179.2.5.19.1',
      bsnExternalPolicyServerIndex => '1.3.6.1.4.1.14179.2.5.19.1.1',
      bsnExternalPolicyServerAddress => '1.3.6.1.4.1.14179.2.5.19.1.2',
      bsnExternalPolicyServerRowStatus => '1.3.6.1.4.1.14179.2.5.19.1.26',
      bsnExternalPolicyServerPortNumber => '1.3.6.1.4.1.14179.2.5.19.1.3',
      bsnExternalPolicyServerKey => '1.3.6.1.4.1.14179.2.5.19.1.4',
      bsnExternalPolicyServerAdminStatus => '1.3.6.1.4.1.14179.2.5.19.1.5',
      bsnExternalPolicyServerConnectionStatus => '1.3.6.1.4.1.14179.2.5.19.1.6',
      bsnRadiusAccServerTable => '1.3.6.1.4.1.14179.2.5.2',
      bsnRadiusAccServerEntry => '1.3.6.1.4.1.14179.2.5.2.1',
      bsnRadiusAccServerIndex => '1.3.6.1.4.1.14179.2.5.2.1.1',
      bsnRadiusAccServerIPSecIKEPhase1 => '1.3.6.1.4.1.14179.2.5.2.1.10',
      bsnRadiusAccServerIPSecIKELifetime => '1.3.6.1.4.1.14179.2.5.2.1.11',
      bsnRadiusAccServerIPSecDHGroup => '1.3.6.1.4.1.14179.2.5.2.1.12',
      bsnRadiusAccServerNetworkUserConfig => '1.3.6.1.4.1.14179.2.5.2.1.13',
      bsnRadiusAccServerRetransmitTimeout => '1.3.6.1.4.1.14179.2.5.2.1.14',
      bsnRadiusAccServerAddress => '1.3.6.1.4.1.14179.2.5.2.1.2',
      bsnRadiusAccServerRowStatus => '1.3.6.1.4.1.14179.2.5.2.1.26',
      bsnRadiusAccClientServerPortNumber => '1.3.6.1.4.1.14179.2.5.2.1.3',
      bsnRadiusAccServerKey => '1.3.6.1.4.1.14179.2.5.2.1.4',
      bsnRadiusAccServerStatus => '1.3.6.1.4.1.14179.2.5.2.1.5',
      bsnRadiusAccServerKeyFormat => '1.3.6.1.4.1.14179.2.5.2.1.6',
      bsnRadiusAccServerIPSec => '1.3.6.1.4.1.14179.2.5.2.1.7',
      bsnRadiusAccServerIPSecAuth => '1.3.6.1.4.1.14179.2.5.2.1.8',
      bsnRadiusAccServerIPSecEncryption => '1.3.6.1.4.1.14179.2.5.2.1.9',
      bsnAAALocalDatabaseSize => '1.3.6.1.4.1.14179.2.5.20',
      bsnAAACurrentLocalDatabaseSize => '1.3.6.1.4.1.14179.2.5.21',
      bsnAPAuthorizationTable => '1.3.6.1.4.1.14179.2.5.22',
      bsnAPAuthorizationEntry => '1.3.6.1.4.1.14179.2.5.22.1',
      bsnAPAuthMacAddress => '1.3.6.1.4.1.14179.2.5.22.1.1',
      bsnAPAuthCertificateType => '1.3.6.1.4.1.14179.2.5.22.1.2',
      bsnAPAuthRowStatus => '1.3.6.1.4.1.14179.2.5.22.1.20',
      bsnAPAuthHashKey => '1.3.6.1.4.1.14179.2.5.22.1.3',
      bsnRadiusAuthServerStatsTable => '1.3.6.1.4.1.14179.2.5.3',
      bsnRadiusAuthServerStatsEntry => '1.3.6.1.4.1.14179.2.5.3.1',
      bsnRadiusAuthClientAccessRejects => '1.3.6.1.4.1.14179.2.5.3.1.10',
      bsnRadiusAuthClientAccessChallenges => '1.3.6.1.4.1.14179.2.5.3.1.11',
      bsnRadiusAuthClientMalformedAccessResponses => '1.3.6.1.4.1.14179.2.5.3.1.12',
      bsnRadiusAuthClientBadAuthenticators => '1.3.6.1.4.1.14179.2.5.3.1.13',
      bsnRadiusAuthClientPendingRequests => '1.3.6.1.4.1.14179.2.5.3.1.14',
      bsnRadiusAuthClientTimeouts => '1.3.6.1.4.1.14179.2.5.3.1.15',
      bsnRadiusAuthClientUnknownTypes => '1.3.6.1.4.1.14179.2.5.3.1.16',
      bsnRadiusAuthClientPacketsDropped => '1.3.6.1.4.1.14179.2.5.3.1.36',
      bsnRadiusAuthClientRoundTripTime => '1.3.6.1.4.1.14179.2.5.3.1.6',
      bsnRadiusAuthClientAccessRequests => '1.3.6.1.4.1.14179.2.5.3.1.7',
      bsnRadiusAuthClientAccessRetransmissions => '1.3.6.1.4.1.14179.2.5.3.1.8',
      bsnRadiusAuthClientAccessAccepts => '1.3.6.1.4.1.14179.2.5.3.1.9',
      bsnRadiusAccServerStatsTable => '1.3.6.1.4.1.14179.2.5.4',
      bsnRadiusAccServerStatsEntry => '1.3.6.1.4.1.14179.2.5.4.1',
      bsnRadiusAccClientMalformedResponses => '1.3.6.1.4.1.14179.2.5.4.1.10',
      bsnRadiusAccClientBadAuthenticators => '1.3.6.1.4.1.14179.2.5.4.1.11',
      bsnRadiusAccClientPendingRequests => '1.3.6.1.4.1.14179.2.5.4.1.12',
      bsnRadiusAccClientTimeouts => '1.3.6.1.4.1.14179.2.5.4.1.13',
      bsnRadiusAccClientUnknownTypes => '1.3.6.1.4.1.14179.2.5.4.1.14',
      bsnRadiusAccClientPacketsDropped => '1.3.6.1.4.1.14179.2.5.4.1.34',
      bsnRadiusAccClientRoundTripTime => '1.3.6.1.4.1.14179.2.5.4.1.6',
      bsnRadiusAccClientRequests => '1.3.6.1.4.1.14179.2.5.4.1.7',
      bsnRadiusAccClientRetransmissions => '1.3.6.1.4.1.14179.2.5.4.1.8',
      bsnRadiusAccClientResponses => '1.3.6.1.4.1.14179.2.5.4.1.9',
      bsnUsersTable => '1.3.6.1.4.1.14179.2.5.5',
      bsnUsersEntry => '1.3.6.1.4.1.14179.2.5.5.1',
      bsnUserName => '1.3.6.1.4.1.14179.2.5.5.1.2',
      bsnUserRowStatus => '1.3.6.1.4.1.14179.2.5.5.1.26',
      bsnUserPassword => '1.3.6.1.4.1.14179.2.5.5.1.3',
      bsnUserEssIndex => '1.3.6.1.4.1.14179.2.5.5.1.4',
      bsnUserAccessMode => '1.3.6.1.4.1.14179.2.5.5.1.5',
      bsnUserType => '1.3.6.1.4.1.14179.2.5.5.1.6',
      bsnUserInterfaceName => '1.3.6.1.4.1.14179.2.5.5.1.7',
      bsnBlackListClientTable => '1.3.6.1.4.1.14179.2.5.6',
      bsnBlackListClientEntry => '1.3.6.1.4.1.14179.2.5.6.1',
      bsnBlackListClientMacAddress => '1.3.6.1.4.1.14179.2.5.6.1.1',
      bsnBlackListClientDescription => '1.3.6.1.4.1.14179.2.5.6.1.2',
      bsnBlackListClientRowStatus => '1.3.6.1.4.1.14179.2.5.6.1.22',
      bsnAclTable => '1.3.6.1.4.1.14179.2.5.7',
      bsnAclEntry => '1.3.6.1.4.1.14179.2.5.7.1',
      bsnAclName => '1.3.6.1.4.1.14179.2.5.7.1.1',
      bsnAclApplyMode => '1.3.6.1.4.1.14179.2.5.7.1.2',
      bsnAclRowStatus => '1.3.6.1.4.1.14179.2.5.7.1.20',
      bsnAclRuleTable => '1.3.6.1.4.1.14179.2.5.8',
      bsnAclRuleEntry => '1.3.6.1.4.1.14179.2.5.8.1',
      bsnAclRuleStartSourcePort => '1.3.6.1.4.1.14179.2.5.8.1.10',
      bsnAclRuleEndSourcePort => '1.3.6.1.4.1.14179.2.5.8.1.11',
      bsnAclRuleStartDestinationPort => '1.3.6.1.4.1.14179.2.5.8.1.12',
      bsnAclRuleEndDestinationPort => '1.3.6.1.4.1.14179.2.5.8.1.13',
      bsnAclRuleDscp => '1.3.6.1.4.1.14179.2.5.8.1.14',
      bsnAclNewRuleIndex => '1.3.6.1.4.1.14179.2.5.8.1.15',
      bsnAclRuleIndex => '1.3.6.1.4.1.14179.2.5.8.1.2',
      bsnAclRuleAction => '1.3.6.1.4.1.14179.2.5.8.1.3',
      bsnAclRuleDirection => '1.3.6.1.4.1.14179.2.5.8.1.4',
      bsnAclRuleRowStatus => '1.3.6.1.4.1.14179.2.5.8.1.40',
      bsnAclRuleSourceIpAddress => '1.3.6.1.4.1.14179.2.5.8.1.5',
      bsnAclRuleSourceIpNetmask => '1.3.6.1.4.1.14179.2.5.8.1.6',
      bsnAclRuleDestinationIpAddress => '1.3.6.1.4.1.14179.2.5.8.1.7',
      bsnAclRuleDestinationIpNetmask => '1.3.6.1.4.1.14179.2.5.8.1.8',
      bsnAclRuleProtocol => '1.3.6.1.4.1.14179.2.5.8.1.9',
      bsnMacFilterTable => '1.3.6.1.4.1.14179.2.5.9',
      bsnMacFilterEntry => '1.3.6.1.4.1.14179.2.5.9.1',
      bsnMacFilterAddress => '1.3.6.1.4.1.14179.2.5.9.1.1',
      bsnMacFilterWlanId => '1.3.6.1.4.1.14179.2.5.9.1.2',
      bsnMacFilterRowStatus => '1.3.6.1.4.1.14179.2.5.9.1.24',
      bsnMacFilterInterfaceName => '1.3.6.1.4.1.14179.2.5.9.1.3',
      bsnMacFilterDescription => '1.3.6.1.4.1.14179.2.5.9.1.4',
      bsnWrasGroups => '1.3.6.1.4.1.14179.2.50',
      bsnEssGroup => '1.3.6.1.4.1.14179.2.50.1',
      bsnWrasDepGroup => '1.3.6.1.4.1.14179.2.50.10',
      bsnWrasObsGroup => '1.3.6.1.4.1.14179.2.50.11',
      bsnWrasTrap => '1.3.6.1.4.1.14179.2.50.12',
      bsnEssGroupRev1 => '1.3.6.1.4.1.14179.2.50.13',
      bsnGlobalDot11GroupRev1 => '1.3.6.1.4.1.14179.2.50.14',
      bsnAAAGroupRev1 => '1.3.6.1.4.1.14179.2.50.15',
      bsnTrapsGroupRev1 => '1.3.6.1.4.1.14179.2.50.16',
      bsnWrasTrapRev1 => '1.3.6.1.4.1.14179.2.50.17',
      bsnApGroupRev1 => '1.3.6.1.4.1.14179.2.50.18',
      bsnUtilityGroupRev1 => '1.3.6.1.4.1.14179.2.50.19',
      bsnApGroup => '1.3.6.1.4.1.14179.2.50.2',
      bsnWrasObsGroupRev1 => '1.3.6.1.4.1.14179.2.50.20',
      bsnWrasObsTrap => '1.3.6.1.4.1.14179.2.50.21',
      bsnGlobalDot11Group => '1.3.6.1.4.1.14179.2.50.3',
      bsnRrmGroup => '1.3.6.1.4.1.14179.2.50.4',
      bsnAAAGroup => '1.3.6.1.4.1.14179.2.50.5',
      bsnTrapsGroup => '1.3.6.1.4.1.14179.2.50.6',
      bsnUtilityGroup => '1.3.6.1.4.1.14179.2.50.7',
      bsnMobilityGroup => '1.3.6.1.4.1.14179.2.50.8',
      bsnIpsecGroup => '1.3.6.1.4.1.14179.2.50.9',
      bsnWrasCompliances => '1.3.6.1.4.1.14179.2.51',
      bsnWrasCompliance => '1.3.6.1.4.1.14179.2.51.1',
      bsnWrasComplianceRev1 => '1.3.6.1.4.1.14179.2.51.2',
      bsnTrap => '1.3.6.1.4.1.14179.2.6',
      bsnTrapControl => '1.3.6.1.4.1.14179.2.6.1',
      bsnDot11StationTrapControlMask => '1.3.6.1.4.1.14179.2.6.1.1',
      bsn80211SecurityTrapControlMask => '1.3.6.1.4.1.14179.2.6.1.10',
      bsnWpsTrapControlEnable => '1.3.6.1.4.1.14179.2.6.1.11',
      bsnAPTrapControlMask => '1.3.6.1.4.1.14179.2.6.1.2',
      bsnAPProfileTrapControlMask => '1.3.6.1.4.1.14179.2.6.1.3',
      bsnAPParamUpdateTrapControlMask => '1.3.6.1.4.1.14179.2.6.1.4',
      bsnIpsecTrapsMask => '1.3.6.1.4.1.14179.2.6.1.5',
      bsnRogueAPTrapEnable => '1.3.6.1.4.1.14179.2.6.1.6',
      bsnRADIUSServerTrapEnable => '1.3.6.1.4.1.14179.2.6.1.7',
      bsnAuthenticationFailureTrapEnable => '1.3.6.1.4.1.14179.2.6.1.8',
      bsnConfigSaveTrapEnable => '1.3.6.1.4.1.14179.2.6.1.9',
      bsnTrapVariable => '1.3.6.1.4.1.14179.2.6.2',
      bsnAuthFailureUserName => '1.3.6.1.4.1.14179.2.6.2.1',
      bsnIkeTotalRespFailures => '1.3.6.1.4.1.14179.2.6.2.10',
      bsnNotifiesSent => '1.3.6.1.4.1.14179.2.6.2.11',
      bsnNotifiesReceived => '1.3.6.1.4.1.14179.2.6.2.12',
      bsnSuiteInitFailures => '1.3.6.1.4.1.14179.2.6.2.13',
      bsnSuiteRespondFailures => '1.3.6.1.4.1.14179.2.6.2.14',
      bsnInitiatorCookie => '1.3.6.1.4.1.14179.2.6.2.15',
      bsnResponderCookie => '1.3.6.1.4.1.14179.2.6.2.16',
      bsnIsakmpInvalidCookies => '1.3.6.1.4.1.14179.2.6.2.17',
      bsnCurrentRadiosCount => '1.3.6.1.4.1.14179.2.6.2.18',
      bsnLicenseRadioCount => '1.3.6.1.4.1.14179.2.6.2.19',
      bsnAuthFailureUserType => '1.3.6.1.4.1.14179.2.6.2.2',
      bsnAPMacAddrTrapVariable => '1.3.6.1.4.1.14179.2.6.2.20',
      bsnAPNameTrapVariable => '1.3.6.1.4.1.14179.2.6.2.21',
      bsnAPSlotIdTrapVariable => '1.3.6.1.4.1.14179.2.6.2.22',
      bsnAPChannelNumberTrapVariable => '1.3.6.1.4.1.14179.2.6.2.23',
      bsnAPCoverageThresholdTrapVariable => '1.3.6.1.4.1.14179.2.6.2.24',
      bsnAPCoverageFailedClients => '1.3.6.1.4.1.14179.2.6.2.25',
      bsnAPCoverageTotalClients => '1.3.6.1.4.1.14179.2.6.2.26',
      bsnClientMacAddr => '1.3.6.1.4.1.14179.2.6.2.27',
      bsnClientRssi => '1.3.6.1.4.1.14179.2.6.2.28',
      bsnClientSnr => '1.3.6.1.4.1.14179.2.6.2.29',
      bsnRemoteIPv4Address => '1.3.6.1.4.1.14179.2.6.2.3',
      bsnInterferenceEnergyBeforeChannelUpdate => '1.3.6.1.4.1.14179.2.6.2.30',
      bsnInterferenceEnergyAfterChannelUpdate => '1.3.6.1.4.1.14179.2.6.2.31',
      bsnAPPortNumberTrapVariable => '1.3.6.1.4.1.14179.2.6.2.32',
      bsnMaxRogueCount => '1.3.6.1.4.1.14179.2.6.2.33',
      bsnStationMacAddress => '1.3.6.1.4.1.14179.2.6.2.34',
      bsnStationAPMacAddr => '1.3.6.1.4.1.14179.2.6.2.35',
      bsnStationAPIfSlotId => '1.3.6.1.4.1.14179.2.6.2.36',
      bsnStationReasonCode => '1.3.6.1.4.1.14179.2.6.2.37',
      bsnStationBlacklistingReasonCode => '1.3.6.1.4.1.14179.2.6.2.38',
      bsnStationUserName => '1.3.6.1.4.1.14179.2.6.2.39',
      bsnIpsecErrorCount => '1.3.6.1.4.1.14179.2.6.2.4',
      bsnRogueAPOnWiredNetwork => '1.3.6.1.4.1.14179.2.6.2.40',
      bsnNavDosAttackSourceMacAddr => '1.3.6.1.4.1.14179.2.6.2.41',
      bsnWlanIdTrapVariable => '1.3.6.1.4.1.14179.2.6.2.42',
      bsnUserIpAddress => '1.3.6.1.4.1.14179.2.6.2.43',
      bsnRogueAdhocMode => '1.3.6.1.4.1.14179.2.6.2.44',
      bsnClearTrapVariable => '1.3.6.1.4.1.14179.2.6.2.45',
      bsnDuplicateIpTrapVariable => '1.3.6.1.4.1.14179.2.6.2.46',
      bsnDuplicateIpTrapClear => '1.3.6.1.4.1.14179.2.6.2.47',
      bsnDuplicateIpReportedByAP => '1.3.6.1.4.1.14179.2.6.2.48',
      bsnTrustedApRadioPolicyRequired => '1.3.6.1.4.1.14179.2.6.2.49',
      bsnIpsecSPI => '1.3.6.1.4.1.14179.2.6.2.5',
      bsnTrustedApEncryptionUsed => '1.3.6.1.4.1.14179.2.6.2.50',
      bsnTrustedApEncryptionRequired => '1.3.6.1.4.1.14179.2.6.2.51',
      bsnTrustedApRadioPolicyUsed => '1.3.6.1.4.1.14179.2.6.2.52',
      bsnNetworkType => '1.3.6.1.4.1.14179.2.6.2.53',
      bsnNetworkState => '1.3.6.1.4.1.14179.2.6.2.54',
      bsnSignatureType => '1.3.6.1.4.1.14179.2.6.2.55',
      bsnSignatureName => '1.3.6.1.4.1.14179.2.6.2.56',
      bsnSignatureDescription => '1.3.6.1.4.1.14179.2.6.2.57',
      bsnImpersonatedAPMacAddr => '1.3.6.1.4.1.14179.2.6.2.58',
      bsnTrustedApPreambleUsed => '1.3.6.1.4.1.14179.2.6.2.59',
      bsnRemoteUdpPort => '1.3.6.1.4.1.14179.2.6.2.6',
      bsnTrustedApPreambleRequired => '1.3.6.1.4.1.14179.2.6.2.60',
      bsnSignatureAttackPreced => '1.3.6.1.4.1.14179.2.6.2.61',
      bsnSignatureAttackFrequency => '1.3.6.1.4.1.14179.2.6.2.62',
      bsnSignatureAttackChannel => '1.3.6.1.4.1.14179.2.6.2.63',
      bsnSignatureAttackerMacAddress => '1.3.6.1.4.1.14179.2.6.2.64',
      bsnLicenseKeyTrapVariable => '1.3.6.1.4.1.14179.2.6.2.65',
      bsnApFunctionalityDisableReasonCode => '1.3.6.1.4.1.14179.2.6.2.66',
      bsnLicenseKeyFeatureSetTrapVariable => '1.3.6.1.4.1.14179.2.6.2.67',
      bsnApRegulatoryDomain => '1.3.6.1.4.1.14179.2.6.2.68',
      bsnAPAuthorizationFailureCause => '1.3.6.1.4.1.14179.2.6.2.69',
      bsnIkeAuthMethod => '1.3.6.1.4.1.14179.2.6.2.7',
      bsnAPIfUpDownCause => '1.3.6.1.4.1.14179.2.6.2.70',
      bsnAPInvalidRadioType => '1.3.6.1.4.1.14179.2.6.2.71',
      locationNotifyContent => '1.3.6.1.4.1.14179.2.6.2.72',
      bsnSignatureMacInfo => '1.3.6.1.4.1.14179.2.6.2.73',
      bsnImpersonatingSourceMacAddr => '1.3.6.1.4.1.14179.2.6.2.74',
      bsnIkeTotalInitFailures => '1.3.6.1.4.1.14179.2.6.2.8',
      bsnAPPreviousChannelNumberTrapVariable => '1.3.6.1.4.1.14179.2.6.2.83',
      bsnAPReasonCodeTrapVariable => '1.3.6.1.4.1.14179.2.6.2.84',
      bsnNoiseBeforeChannelUpdate => '1.3.6.1.4.1.14179.2.6.2.85',
      bsnNoiseAfterChannelUpdate => '1.3.6.1.4.1.14179.2.6.2.86',
      bsnInterferenceBeforeChannelUpdate => '1.3.6.1.4.1.14179.2.6.2.87',
      bsnInterferenceAfterChannelUpdate => '1.3.6.1.4.1.14179.2.6.2.88',
      bsnIkeTotalInitNoResponses => '1.3.6.1.4.1.14179.2.6.2.9',
      bsnTraps => '1.3.6.1.4.1.14179.2.6.3',
      bsnDot11StationDisassociate => '1.3.6.1.4.1.14179.2.6.3.1',
      bsnAPIfDown => '1.3.6.1.4.1.14179.2.6.3.10',
      bsnAPLoadProfileFailed => '1.3.6.1.4.1.14179.2.6.3.11',
      bsnAPNoiseProfileFailed => '1.3.6.1.4.1.14179.2.6.3.12',
      bsnAPInterferenceProfileFailed => '1.3.6.1.4.1.14179.2.6.3.13',
      bsnAPCoverageProfileFailed => '1.3.6.1.4.1.14179.2.6.3.14',
      bsnAPCurrentTxPowerChanged => '1.3.6.1.4.1.14179.2.6.3.15',
      bsnAPCurrentChannelChanged => '1.3.6.1.4.1.14179.2.6.3.16',
      bsnDot11StationDeauthenticate => '1.3.6.1.4.1.14179.2.6.3.2',
      bsnRrmDot11aGroupingDone => '1.3.6.1.4.1.14179.2.6.3.21',
      bsnRrmDot11bGroupingDone => '1.3.6.1.4.1.14179.2.6.3.22',
      bsnConfigSaved => '1.3.6.1.4.1.14179.2.6.3.23',
      bsnDot11EssCreated => '1.3.6.1.4.1.14179.2.6.3.24',
      bsnDot11EssDeleted => '1.3.6.1.4.1.14179.2.6.3.25',
      bsnRADIUSServerNotResponding => '1.3.6.1.4.1.14179.2.6.3.26',
      bsnAuthenticationFailure => '1.3.6.1.4.1.14179.2.6.3.27',
      bsnIpsecEspAuthFailureTrap => '1.3.6.1.4.1.14179.2.6.3.28',
      bsnIpsecEspReplayFailureTrap => '1.3.6.1.4.1.14179.2.6.3.29',
      bsnDot11StationAuthenticateFail => '1.3.6.1.4.1.14179.2.6.3.3',
      bsnIpsecEspInvalidSpiTrap => '1.3.6.1.4.1.14179.2.6.3.31',
      bsnIpsecIkeNegFailure => '1.3.6.1.4.1.14179.2.6.3.33',
      bsnIpsecSuiteNegFailure => '1.3.6.1.4.1.14179.2.6.3.34',
      bsnIpsecInvalidCookieTrap => '1.3.6.1.4.1.14179.2.6.3.35',
      bsnRogueAPDetected => '1.3.6.1.4.1.14179.2.6.3.36',
      bsnAPLoadProfileUpdatedToPass => '1.3.6.1.4.1.14179.2.6.3.37',
      bsnAPNoiseProfileUpdatedToPass => '1.3.6.1.4.1.14179.2.6.3.38',
      bsnAPInterferenceProfileUpdatedToPass => '1.3.6.1.4.1.14179.2.6.3.39',
      bsnDot11StationAssociateFail => '1.3.6.1.4.1.14179.2.6.3.4',
      bsnAPCoverageProfileUpdatedToPass => '1.3.6.1.4.1.14179.2.6.3.40',
      bsnRogueAPRemoved => '1.3.6.1.4.1.14179.2.6.3.41',
      bsnRadiosExceedLicenseCount => '1.3.6.1.4.1.14179.2.6.3.42',
      bsnSensedTemperatureTooHigh => '1.3.6.1.4.1.14179.2.6.3.43',
      bsnSensedTemperatureTooLow => '1.3.6.1.4.1.14179.2.6.3.44',
      bsnTemperatureSensorFailure => '1.3.6.1.4.1.14179.2.6.3.45',
      bsnTemperatureSensorClear => '1.3.6.1.4.1.14179.2.6.3.46',
      bsnPOEControllerFailure => '1.3.6.1.4.1.14179.2.6.3.47',
      bsnMaxRogueCountExceeded => '1.3.6.1.4.1.14179.2.6.3.48',
      bsnMaxRogueCountClear => '1.3.6.1.4.1.14179.2.6.3.49',
      bsnAPUp => '1.3.6.1.4.1.14179.2.6.3.5',
      bsnApMaxRogueCountExceeded => '1.3.6.1.4.1.14179.2.6.3.50',
      bsnApMaxRogueCountClear => '1.3.6.1.4.1.14179.2.6.3.51',
      bsnDot11StationBlacklisted => '1.3.6.1.4.1.14179.2.6.3.52',
      bsnDot11StationAssociate => '1.3.6.1.4.1.14179.2.6.3.53',
      bsnApBigNavDosAttack => '1.3.6.1.4.1.14179.2.6.3.55',
      bsnTooManyUnsuccessLoginAttempts => '1.3.6.1.4.1.14179.2.6.3.56',
      bsnWepKeyDecryptError => '1.3.6.1.4.1.14179.2.6.3.57',
      bsnWpaMicErrorCounterActivated => '1.3.6.1.4.1.14179.2.6.3.58',
      bsnRogueAPDetectedOnWiredNetwork => '1.3.6.1.4.1.14179.2.6.3.59',
      bsnAPDown => '1.3.6.1.4.1.14179.2.6.3.6',
      bsnApHasNoRadioCards => '1.3.6.1.4.1.14179.2.6.3.60',
      bsnDuplicateIpAddressReported => '1.3.6.1.4.1.14179.2.6.3.61',
      bsnAPContainedAsARogue => '1.3.6.1.4.1.14179.2.6.3.62',
      bsnTrustedApHasInvalidSsid => '1.3.6.1.4.1.14179.2.6.3.63',
      bsnTrustedApIsMissing => '1.3.6.1.4.1.14179.2.6.3.64',
      bsnAdhocRogueAutoContained => '1.3.6.1.4.1.14179.2.6.3.65',
      bsnRogueApAutoContained => '1.3.6.1.4.1.14179.2.6.3.66',
      bsnTrustedApHasInvalidEncryption => '1.3.6.1.4.1.14179.2.6.3.67',
      bsnTrustedApHasInvalidRadioPolicy => '1.3.6.1.4.1.14179.2.6.3.68',
      bsnNetworkStateChanged => '1.3.6.1.4.1.14179.2.6.3.69',
      bsnAPAssociated => '1.3.6.1.4.1.14179.2.6.3.7',
      bsnSignatureAttackDetected => '1.3.6.1.4.1.14179.2.6.3.70',
      bsnAPRadioCardTxFailure => '1.3.6.1.4.1.14179.2.6.3.71',
      bsnAPRadioCardTxFailureClear => '1.3.6.1.4.1.14179.2.6.3.72',
      bsnAPRadioCardRxFailure => '1.3.6.1.4.1.14179.2.6.3.73',
      bsnAPRadioCardRxFailureClear => '1.3.6.1.4.1.14179.2.6.3.74',
      bsnAPImpersonationDetected => '1.3.6.1.4.1.14179.2.6.3.75',
      bsnTrustedApHasInvalidPreamble => '1.3.6.1.4.1.14179.2.6.3.76',
      bsnAPIPAddressFallback => '1.3.6.1.4.1.14179.2.6.3.77',
      bsnAPFunctionalityDisabled => '1.3.6.1.4.1.14179.2.6.3.78',
      bsnAPRegulatoryDomainMismatch => '1.3.6.1.4.1.14179.2.6.3.79',
      bsnAPDisassociated => '1.3.6.1.4.1.14179.2.6.3.8',
      bsnRxMulticastQueueFull => '1.3.6.1.4.1.14179.2.6.3.80',
      bsnRadarChannelDetected => '1.3.6.1.4.1.14179.2.6.3.81',
      bsnRadarChannelCleared => '1.3.6.1.4.1.14179.2.6.3.82',
      bsnAPAuthorizationFailure => '1.3.6.1.4.1.14179.2.6.3.83',
      radioCoreDumpTrap => '1.3.6.1.4.1.14179.2.6.3.84',
      invalidRadioTrap => '1.3.6.1.4.1.14179.2.6.3.85',
      countryChangeTrap => '1.3.6.1.4.1.14179.2.6.3.86',
      unsupportedAPTrap => '1.3.6.1.4.1.14179.2.6.3.87',
      heartbeatLossTrap => '1.3.6.1.4.1.14179.2.6.3.88',
      locationNotifyTrap => '1.3.6.1.4.1.14179.2.6.3.89',
      bsnAPIfUp => '1.3.6.1.4.1.14179.2.6.3.9',
      bsnUtility => '1.3.6.1.4.1.14179.2.7',
      bsnSyslog => '1.3.6.1.4.1.14179.2.7.1',
      bsnSyslogEnable => '1.3.6.1.4.1.14179.2.7.1.1',
      bsnSyslogRemoteAddress => '1.3.6.1.4.1.14179.2.7.1.2',
      bsnPing => '1.3.6.1.4.1.14179.2.7.2',
      bsnPingTestTable => '1.3.6.1.4.1.14179.2.7.2.1',
      bsnPingTestEntry => '1.3.6.1.4.1.14179.2.7.2.1.1',
      bsnPingTestId => '1.3.6.1.4.1.14179.2.7.2.1.1.1',
      bsnPingTestIPAddress => '1.3.6.1.4.1.14179.2.7.2.1.1.2',
      bsnPingTestRowStatus => '1.3.6.1.4.1.14179.2.7.2.1.1.25',
      bsnPingTestSendCount => '1.3.6.1.4.1.14179.2.7.2.1.1.3',
      bsnPingTestReceivedCount => '1.3.6.1.4.1.14179.2.7.2.1.1.4',
      bsnPingTestStatus => '1.3.6.1.4.1.14179.2.7.2.1.1.5',
      bsnPingTestMaxTimeInterval => '1.3.6.1.4.1.14179.2.7.2.1.1.6',
      bsnPingTestMinTimeInterval => '1.3.6.1.4.1.14179.2.7.2.1.1.7',
      bsnPingTestAvgTimeInterval => '1.3.6.1.4.1.14179.2.7.2.1.1.8',
      bsnLinkTest => '1.3.6.1.4.1.14179.2.7.3',
      bsnLinkTestTable => '1.3.6.1.4.1.14179.2.7.3.1',
      bsnLinkTestEntry => '1.3.6.1.4.1.14179.2.7.3.1.1',
      bsnLinkTestId => '1.3.6.1.4.1.14179.2.7.3.1.1.1',
      bsnLinkTestMacAddress => '1.3.6.1.4.1.14179.2.7.3.1.1.2',
      bsnLinkTestSendPktCount => '1.3.6.1.4.1.14179.2.7.3.1.1.3',
      bsnLinkTestRowStatus => '1.3.6.1.4.1.14179.2.7.3.1.1.30',
      bsnLinkTestSendPktLength => '1.3.6.1.4.1.14179.2.7.3.1.1.4',
      bsnLinkTestReceivedPktCount => '1.3.6.1.4.1.14179.2.7.3.1.1.5',
      bsnLinkTestClientRSSI => '1.3.6.1.4.1.14179.2.7.3.1.1.6',
      bsnLinkTestLocalSNR => '1.3.6.1.4.1.14179.2.7.3.1.1.7',
      bsnLinkTestLocalRSSI => '1.3.6.1.4.1.14179.2.7.3.1.1.8',
      bsnLinkTestStatus => '1.3.6.1.4.1.14179.2.7.3.1.1.9',
      bsnMobility => '1.3.6.1.4.1.14179.2.8',
      bsnMobilityConfig => '1.3.6.1.4.1.14179.2.8.1',
      bsnMobilityProtocolPortNum => '1.3.6.1.4.1.14179.2.8.1.1',
      bsnMobilityGroupMembersTable => '1.3.6.1.4.1.14179.2.8.1.10',
      bsnMobilityGroupMembersEntry => '1.3.6.1.4.1.14179.2.8.1.10.1',
      bsnMobilityGroupMemberMacAddress => '1.3.6.1.4.1.14179.2.8.1.10.1.1',
      bsnMobilityGroupMemberIPAddress => '1.3.6.1.4.1.14179.2.8.1.10.1.2',
      bsnMobilityGroupMemberRowStatus => '1.3.6.1.4.1.14179.2.8.1.10.1.22',
      bsnMobilityGroupMemberGroupName => '1.3.6.1.4.1.14179.2.8.1.10.1.3',
      bsnMobilityAnchorsTable => '1.3.6.1.4.1.14179.2.8.1.11',
      bsnMobilityAnchorsEntry => '1.3.6.1.4.1.14179.2.8.1.11.1',
      bsnMobilityAnchorWlanSsid => '1.3.6.1.4.1.14179.2.8.1.11.1.1',
      bsnMobilityAnchorSwitchIPAddress => '1.3.6.1.4.1.14179.2.8.1.11.1.2',
      bsnMobilityAnchorRowStatus => '1.3.6.1.4.1.14179.2.8.1.11.1.20',
      bsnMobilityDynamicDiscovery => '1.3.6.1.4.1.14179.2.8.1.3',
      bsnMobilityStatsReset => '1.3.6.1.4.1.14179.2.8.1.4',
      bsnMobilityStats => '1.3.6.1.4.1.14179.2.8.2',
      bsnTotalHandoffRequests => '1.3.6.1.4.1.14179.2.8.2.1',
      bsnTotalReceiveErrors => '1.3.6.1.4.1.14179.2.8.2.10',
      bsnTotalTransmitErrors => '1.3.6.1.4.1.14179.2.8.2.11',
      bsnTotalResponsesRetransmitted => '1.3.6.1.4.1.14179.2.8.2.12',
      bsnTotalHandoffEndRequestsReceived => '1.3.6.1.4.1.14179.2.8.2.13',
      bsnTotalStateTransitionsDisallowed => '1.3.6.1.4.1.14179.2.8.2.14',
      bsnTotalResourceErrors => '1.3.6.1.4.1.14179.2.8.2.15',
      bsnTotalHandoffRequestsSent => '1.3.6.1.4.1.14179.2.8.2.16',
      bsnTotalHandoffRepliesReceived => '1.3.6.1.4.1.14179.2.8.2.17',
      bsnTotalHandoffAsLocalReceived => '1.3.6.1.4.1.14179.2.8.2.18',
      bsnTotalHandoffAsForeignReceived => '1.3.6.1.4.1.14179.2.8.2.19',
      bsnTotalHandoffs => '1.3.6.1.4.1.14179.2.8.2.2',
      bsnTotalHandoffDeniesReceived => '1.3.6.1.4.1.14179.2.8.2.20',
      bsnTotalAnchorRequestsSent => '1.3.6.1.4.1.14179.2.8.2.21',
      bsnTotalAnchorDenyReceived => '1.3.6.1.4.1.14179.2.8.2.22',
      bsnTotalAnchorGrantReceived => '1.3.6.1.4.1.14179.2.8.2.23',
      bsnTotalAnchorTransferReceived => '1.3.6.1.4.1.14179.2.8.2.24',
      bsnTotalHandoffRequestsIgnored => '1.3.6.1.4.1.14179.2.8.2.25',
      bsnTotalPingPongHandoffRequestsDropped => '1.3.6.1.4.1.14179.2.8.2.26',
      bsnTotalHandoffRequestsDropped => '1.3.6.1.4.1.14179.2.8.2.27',
      bsnTotalHandoffRequestsDenied => '1.3.6.1.4.1.14179.2.8.2.28',
      bsnTotalClientHandoffAsLocal => '1.3.6.1.4.1.14179.2.8.2.29',
      bsnCurrentExportedClients => '1.3.6.1.4.1.14179.2.8.2.3',
      bsnTotalClientHandoffAsForeign => '1.3.6.1.4.1.14179.2.8.2.30',
      bsnTotalAnchorRequestsReceived => '1.3.6.1.4.1.14179.2.8.2.31',
      bsnTotalAnchorRequestsDenied => '1.3.6.1.4.1.14179.2.8.2.32',
      bsnTotalAnchorRequestsGranted => '1.3.6.1.4.1.14179.2.8.2.33',
      bsnTotalAnchorTransferred => '1.3.6.1.4.1.14179.2.8.2.34',
      bsnTotalHandoffRequestsReceived => '1.3.6.1.4.1.14179.2.8.2.35',
      bsnTotalExportedClients => '1.3.6.1.4.1.14179.2.8.2.4',
      bsnCurrentImportedClients => '1.3.6.1.4.1.14179.2.8.2.5',
      bsnTotalImportedClients => '1.3.6.1.4.1.14179.2.8.2.6',
      bsnTotalHandoffErrors => '1.3.6.1.4.1.14179.2.8.2.7',
      bsnTotalCommunicationErrors => '1.3.6.1.4.1.14179.2.8.2.8',
      bsnMobilityGroupDirectoryTable => '1.3.6.1.4.1.14179.2.8.2.9',
      bsnMobilityGroupDirectoryEntry => '1.3.6.1.4.1.14179.2.8.2.9.1',
      bsnGroupDirectoryMemberIPAddress => '1.3.6.1.4.1.14179.2.8.2.9.1.1',
      bsnMemberTotalHandoffErrors => '1.3.6.1.4.1.14179.2.8.2.9.1.10',
      bsnGroupDirectoryMemberMacAddress => '1.3.6.1.4.1.14179.2.8.2.9.1.2',
      bsnGroupDirectoryDicoveryType => '1.3.6.1.4.1.14179.2.8.2.9.1.3',
      bsnMemberTotalCommunicationErrors => '1.3.6.1.4.1.14179.2.8.2.9.1.30',
      bsnMemberCurrentAnchoredClients => '1.3.6.1.4.1.14179.2.8.2.9.1.4',
      bsnMemberTotalAnchoredClients => '1.3.6.1.4.1.14179.2.8.2.9.1.5',
      bsnMemberCurrentExportedClients => '1.3.6.1.4.1.14179.2.8.2.9.1.6',
      bsnMemberTotalExportedClients => '1.3.6.1.4.1.14179.2.8.2.9.1.7',
      bsnMemberCurrentImportedClients => '1.3.6.1.4.1.14179.2.8.2.9.1.8',
      bsnMemberTotalImportedClients => '1.3.6.1.4.1.14179.2.8.2.9.1.9',
      bsnIpsec => '1.3.6.1.4.1.14179.2.9',
      bsnWrasIpsecCACertificate => '1.3.6.1.4.1.14179.2.9.1',
      bsnWrasIpsecCACertificateUpdate => '1.3.6.1.4.1.14179.2.9.2',
      bsnWrasIpsecCertTable => '1.3.6.1.4.1.14179.2.9.3',
      bsnWrasIpsecCertEntry => '1.3.6.1.4.1.14179.2.9.3.1',
      bsnWrasIpsecCertName => '1.3.6.1.4.1.14179.2.9.3.1.1',
      bsnWrasIpsecCertificateUpdate => '1.3.6.1.4.1.14179.2.9.3.1.2',
      bsnWrasIpsecCertStatus => '1.3.6.1.4.1.14179.2.9.3.1.24',
      bsnWrasIpsecCertificate => '1.3.6.1.4.1.14179.2.9.3.1.3',
      bsnWrasIpsecCertPassword => '1.3.6.1.4.1.14179.2.9.3.1.4',
  },
  'ASYNCOS-MAIL-MIB' => {
      asyncOSMailObjects => '1.3.6.1.4.1.15497.1.1.1',
      perCentMemoryUtilization => '1.3.6.1.4.1.15497.1.1.1.1.0',
      perCentCPUUtilization => '1.3.6.1.4.1.15497.1.1.1.2.0',
      perCentDiskIOUtilization => '1.3.6.1.4.1.15497.1.1.1.3.0',
      perCentQueueUtilization => '1.3.6.1.4.1.15497.1.1.1.4.0',
      queueAvailabilityStatus => '1.3.6.1.4.1.15497.1.1.1.5.0',
      queueAvailabilityStatusDefinition => {
        1 => 'queueSpaceAvailable',
        2 => 'queueSpaceShortage',
        3 => 'queueFull',
      },
      resourceConservationReason => '1.3.6.1.4.1.15497.1.1.1.6.0',
      memoryAvailabilityStatus => '1.3.6.1.4.1.15497.1.1.1.7.0',
      memoryAvailabilityStatusDefinition => {
        1 => 'memoryAvailable',
        2 => 'memoryShortage',
        3 => 'memoryFull',
      },
      powerSupplyTable => '1.3.6.1.4.1.15497.1.1.1.8',
      powerSupplyEntry => '1.3.6.1.4.1.15497.1.1.1.8.1',
      powerSupplyIndex => '1.3.6.1.4.1.15497.1.1.1.8.1.1',
      powerSupplyStatus => '1.3.6.1.4.1.15497.1.1.1.8.1.2',
      powerSupplyStatusDefinition => {
        1 => 'powerSupplyNotInstalled',
        2 => 'powerSupplyHealthy',
        3 => 'powerSupplyNoAC',
        4 => 'powerSupplyFaulty',
      },
      powerSupplyRedundancy => '1.3.6.1.4.1.15497.1.1.1.8.1.3',
      powerSupplyName => '1.3.6.1.4.1.15497.1.1.1.8.1.4',
      temperatureTable => '1.3.6.1.4.1.15497.1.1.1.9',
      temperatureEntry => '1.3.6.1.4.1.15497.1.1.1.9.1',
      temperatureIndex => '1.3.6.1.4.1.15497.1.1.1.9.1.1',
      degreesCelsius => '1.3.6.1.4.1.15497.1.1.1.9.1.2',
      temperatureName => '1.3.6.1.4.1.15497.1.1.1.9.1.3',
      fanTable => '1.3.6.1.4.1.15497.1.1.1.10',
      fanEntry => '1.3.6.1.4.1.15497.1.1.1.10.1',
      fanIndex => '1.3.6.1.4.1.15497.1.1.1.10.1.1',
      fanRPMs => '1.3.6.1.4.1.15497.1.1.1.10.1.2',
      fanName => '1.3.6.1.4.1.15497.1.1.1.10.1.3',
      workQueueMessages => '1.3.6.1.4.1.15497.1.1.1.11.0',
      keyExpirationTable => '1.3.6.1.4.1.15497.1.1.1.12',
      keyExpirationEntry => '1.3.6.1.4.1.15497.1.1.1.12.1',
      keyExpirationIndex => '1.3.6.1.4.1.15497.1.1.1.12.1.1',
      keyDescription => '1.3.6.1.4.1.15497.1.1.1.12.1.2',
      keyIsPerpetual => '1.3.6.1.4.1.15497.1.1.1.12.1.3',
      keyIsPerpetualDefinition => 'SNMPv2-TC-v1::TruthValue',
      keySecondsUntilExpire => '1.3.6.1.4.1.15497.1.1.1.12.1.4',
      updateTable => '1.3.6.1.4.1.15497.1.1.1.13',
      updateEntry => '1.3.6.1.4.1.15497.1.1.1.13.1',
      updateIndex => '1.3.6.1.4.1.15497.1.1.1.13.1.1',
      updateServiceName => '1.3.6.1.4.1.15497.1.1.1.13.1.2',
      updates => '1.3.6.1.4.1.15497.1.1.1.13.1.3',
      updateFailures => '1.3.6.1.4.1.15497.1.1.1.13.1.4',
      oldestMessageAge => '1.3.6.1.4.1.15497.1.1.1.14.0',
      outstandingDNSRequests => '1.3.6.1.4.1.15497.1.1.1.15.0',
      pendingDNSRequests => '1.3.6.1.4.1.15497.1.1.1.16.0',
      raidEvents => '1.3.6.1.4.1.15497.1.1.1.17.0',
      raidTable => '1.3.6.1.4.1.15497.1.1.1.18',
      raidEntry => '1.3.6.1.4.1.15497.1.1.1.18.1',
      raidIndex => '1.3.6.1.4.1.15497.1.1.1.18.1.1',
      raidStatus => '1.3.6.1.4.1.15497.1.1.1.18.1.2',
      raidStatusDefinition => {
        1 => 'driveHealthy',
        2 => 'driveFailure',
        3 => 'driveRebuild',
      },
      raidID => '1.3.6.1.4.1.15497.1.1.1.18.1.3',
      raidLastError => '1.3.6.1.4.1.15497.1.1.1.18.1.4',
      openFilesOrSockets => '1.3.6.1.4.1.15497.1.1.1.19.0',
      mailTransferThreads => '1.3.6.1.4.1.15497.1.1.1.20.0',
  },
  # END Cisco
  'SW-MIB' => {
      swFirmwareVersion => '1.3.6.1.4.1.1588.2.1.1.1.1.6.0',
      swSensorTable => '1.3.6.1.4.1.1588.2.1.1.1.1.22',
      swSensorEntry => '1.3.6.1.4.1.1588.2.1.1.1.1.22.1',
      swSensorIndex => '1.3.6.1.4.1.1588.2.1.1.1.1.22.1.1',
      swSensorType => '1.3.6.1.4.1.1588.2.1.1.1.1.22.1.2',
      swSensorTypeDefinition => {
          1 => 'temperature',
          2 => 'fan',
          3 => 'power-supply',
      },
      swSensorStatus => '1.3.6.1.4.1.1588.2.1.1.1.1.22.1.3',
      swSensorStatusDefinition => {
          1 => 'unknown',
          2 => 'faulty',
          3 => 'below-min',
          4 => 'nominal',
          5 => 'above-max',
          6 => 'absent',
      },
      # the value, -2147483648, represents an unknown quantity
      # In V2.0, the temperature sensor
      # value will be in Celsius; the fan value will be in RPM
      # (revoluation per minute); and the power supply sensor reading
      # will be unknown.
      swSensorValue => '1.3.6.1.4.1.1588.2.1.1.1.1.22.1.4',
      swSensorInfo => '1.3.6.1.4.1.1588.2.1.1.1.1.22.1.5',

      swFwThresholdTable => '1.3.6.1.4.1.1588.2.1.1.1.10.3',
      swFwThresholdEntry => '1.3.6.1.4.1.1588.2.1.1.1.10.3.1',
      swFwThresholdIndex => '1.3.6.1.4.1.1588.2.1.1.1.10.3.1.1',
      swFwStatus => '1.3.6.1.4.1.1588.2.1.1.1.10.3.1.2',
      swFwName => '1.3.6.1.4.1.1588.2.1.1.1.10.3.1.3',
      swFwLabel => '1.3.6.1.4.1.1588.2.1.1.1.10.3.1.4',
      swFwCurVal => '1.3.6.1.4.1.1588.2.1.1.1.10.3.1.5',
      swFwLastEvent => '1.3.6.1.4.1.1588.2.1.1.1.10.3.1.6',
      swFwLastEventVal => '1.3.6.1.4.1.1588.2.1.1.1.10.3.1.7',
      swFwLastEventTime => '1.3.6.1.4.1.1588.2.1.1.1.10.3.1.8',
      swFwLastState => '1.3.6.1.4.1.1588.2.1.1.1.10.3.1.9',
      swFwBehaviorType => '1.3.6.1.4.1.1588.2.1.1.1.10.3.1.10',
      swFwBehaviorInt => '1.3.6.1.4.1.1588.2.1.1.1.10.3.1.11',

      swCpuOrMemoryUsage => '1.3.6.1.4.1.1588.2.1.1.1.26',
      swCpuUsage => '1.3.6.1.4.1.1588.2.1.1.1.26.1',
        # The system's CPU usage.
      swCpuNoOfRetries => '1.3.6.1.4.1.1588.2.1.1.1.26.2',
        # The number of times the system should take a CPU utilization sample before sending the CPU utilization trap.
      swCpuUsageLimit => '1.3.6.1.4.1.1588.2.1.1.1.26.3',
        # The CPU usage limit.
      swCpuPollingInterval => '1.3.6.1.4.1.1588.2.1.1.1.26.4',
        # The time after which the next CPU usage value will be recorded.
      swCpuAction => '1.3.6.1.4.1.1588.2.1.1.1.26.5',
        # The action to be taken if the CPU usage exceeds the specified threshold limit.
      swMemUsage => '1.3.6.1.4.1.1588.2.1.1.1.26.6',
        # The system's memory usage.
      swMemNoOfRetries => '1.3.6.1.4.1.1588.2.1.1.1.26.7',
        # The number of times the system should take a memory usage sample before sending the Fabric Watch trap that indicates the current memory usage.
      swMemUsageLimit => '1.3.6.1.4.1.1588.2.1.1.1.26.8',
        # The memory usage limit. This OID specifies the in-between threshold value.
      swMemPollingInterval => '1.3.6.1.4.1.1588.2.1.1.1.26.9',
        # The time after which the next memory usage sample will be taken
      swMemAction => '1.3.6.1.4.1.1588.2.1.1.1.26.10',
        # The action to be taken if the memory usage exceed the specified threshold limit.
      swMemUsageLimit1 => '1.3.6.1.4.1.1588.2.1.1.1.26.11',
        # This OID specifies the low threshold value.
      swMemUsageLimit3 => '1.3.6.1.4.1.1588.2.1.1.1.26.12',
        # This OID specifies the high threshold value.
  },
  'ENTITY-MIB' => {
      entPhysicalTable => '1.3.6.1.2.1.47.1.1.1',
      entPhysicalEntry => '1.3.6.1.2.1.47.1.1.1.1',
      entPhysicalDescr => '1.3.6.1.2.1.47.1.1.1.1.2',
  },
  'UCD-SNMP-MIB' => {
        laTable => '1.3.6.1.4.1.2021.10',
        laEntry => '1.3.6.1.4.1.2021.10.1',
        laIndex => '1.3.6.1.4.1.2021.10.1.1',
        laNames => '1.3.6.1.4.1.2021.10.1.2',
        laLoad => '1.3.6.1.4.1.2021.10.1.3',
        laConfig => '1.3.6.1.4.1.2021.10.1.4',
        laLoadInt => '1.3.6.1.4.1.2021.10.1.5',
        laLoadFloat => '1.3.6.1.4.1.2021.10.1.6',
        laErrorFlag => '1.3.6.1.4.1.2021.10.1.100',
        laErrMessage => '1.3.6.1.4.1.2021.10.1.101',

        memoryGroup => '1.3.6.1.4.1.2021.4',
        memIndex => '1.3.6.1.4.1.2021.4.1',
        memErrorName => '1.3.6.1.4.1.2021.4.2',
        memTotalSwap => '1.3.6.1.4.1.2021.4.3',
        memAvailSwap => '1.3.6.1.4.1.2021.4.4',
        memTotalReal => '1.3.6.1.4.1.2021.4.5',
        memAvailReal => '1.3.6.1.4.1.2021.4.6',
        memTotalSwapTXT => '1.3.6.1.4.1.2021.4.7',
        memAvailSwapTXT => '1.3.6.1.4.1.2021.4.8',
        memTotalRealTXT => '1.3.6.1.4.1.2021.4.9',
        memAvailRealTXT => '1.3.6.1.4.1.2021.4.10',
        memTotalFree => '1.3.6.1.4.1.2021.4.11',
        memMinimumSwap => '1.3.6.1.4.1.2021.4.12',
        memShared => '1.3.6.1.4.1.2021.4.13',
        memBuffer => '1.3.6.1.4.1.2021.4.14',
        memCached => '1.3.6.1.4.1.2021.4.15',
        memSwapError => '1.3.6.1.4.1.2021.4.100',
        memSwapErrorMsg => '1.3.6.1.4.1.2021.4.101',

        systemStatsGroup => '1.3.6.1.4.1.2021.11',
        ssIndex => '1.3.6.1.4.1.2021.11.1',
        ssErrorName => '1.3.6.1.4.1.2021.11.2',
        ssSwapIn => '1.3.6.1.4.1.2021.11.3',
        ssSwapOut => '1.3.6.1.4.1.2021.11.4',
        ssIOSent => '1.3.6.1.4.1.2021.11.5',
        ssIOReceive => '1.3.6.1.4.1.2021.11.6',
        ssSysInterrupts => '1.3.6.1.4.1.2021.11.7',
        ssSysContext => '1.3.6.1.4.1.2021.11.8',
        ssCpuUser => '1.3.6.1.4.1.2021.11.9',
        ssCpuSystem => '1.3.6.1.4.1.2021.11.10',
        ssCpuIdle => '1.3.6.1.4.1.2021.11.11',
        ssCpuRawUser => '1.3.6.1.4.1.2021.11.50',
        ssCpuRawNice => '1.3.6.1.4.1.2021.11.51',
        ssCpuRawSystem => '1.3.6.1.4.1.2021.11.52',
        ssCpuRawIdle => '1.3.6.1.4.1.2021.11.53',
  },
  'FCMGMT-MIB' => {
      fcConnUnitTable => '1.3',
      fcConnUnitEntry => '1.3.1',
      fcConnUnitId => '1.3.1.1',
      fcConnUnitGlobalId => '1.3.1.2',
      fcConnUnitType => '1.3',
      fcConnUnitNumPorts => '1.3.1.4',
      fcConnUnitState => '1.3.1.5',
      fcConnUnitStatus => '1.3.1.6',
      fcConnUnitProduct => '1.3.1.7',
      fcConnUnitSerialNo => '1.3.1.8',
      fcConnUnitUpTime => '1.3.1.9',
      fcConnUnitUrl => '1.3.1.10',
      fcConnUnitDomainId => '1.3.1.11',
      fcConnUnitProxyMaster => '1.3.1.12',
      fcConnUnitPrincipal => '1.3.1.13',
      fcConnUnitNumSensors => '1.3.1.14',
      fcConnUnitNumRevs => '1.3.1.15',
      fcConnUnitModuleId => '1.3.1.16',
      fcConnUnitName => '1.3.1.17',
      fcConnUnitInfo => '1.3.1.18',
      fcConnUnitControl => '1.3.1.19',
      fcConnUnitContact => '1.3.1.20',
      fcConnUnitLocation => '1.3.1.21',
      fcConnUnitEventFilter => '1.3.1.22',
      fcConnUnitNumEvents => '1.3.1.23',
      fcConnUnitMaxEvents => '1.3.1.24',
      fcConnUnitEventCurrID => '1.3.1.25',

      fcConnUnitRevsTable => '1.3.6.1.2.1.8888.1.1.4',
      fcConnUnitRevsEntry => '1.3.6.1.2.1.8888.1.1.4.1',
      fcConnUnitRevsIndex => '1.3.6.1.2.1.8888.1.1.4.1.1',
      fcConnUnitRevsRevision => '1.3.6.1.2.1.8888.1.1.4.1.2',
      fcConnUnitRevsDescription => '1.3',

      fcConnUnitSensorTable => '1.3.6.1.2.1.8888.1.1.5',
      fcConnUnitSensorEntry => '1.3.6.1.2.1.8888.1.1.5.1',
      fcConnUnitSensorIndex => '1.3.6.1.2.1.8888.1.1.5.1.1',
      fcConnUnitSensorName => '1.3.6.1.2.1.8888.1.1.5.1.2',
      fcConnUnitSensorStatus => '1.3.6.1.2.1.8888.1.1.5.1.3',
      fcConnUnitSensorStatusDefinition => {
          1 => 'unknown',
          2 => 'other',
          3 => 'ok',
          4 => 'warning',
          5 => 'failed',
      },
      fcConnUnitSensorInfo => '1.3.6.1.2.1.8888.1.1.5.1.4',
      fcConnUnitSensorMessage => '1.3.6.1.2.1.8888.1.1.5.1.5',
      fcConnUnitSensorType => '1.3.6.1.2.1.8888.1.1.5.1.6',
      fcConnUnitSensorTypeDefinition => {
          1 => 'unknown',
          2 => 'other',
          3 => 'battery',
          4 => 'fan',
          5 => 'powerSupply',
          6 => 'transmitter',
          7 => 'enclosure',
          8 => 'board',
          9 => 'receiver',
      },
      fcConnUnitSensorCharacteristic => '1.3.6.1.2.1.8888.1.1.5.1.7',
      fcConnUnitSensorCharacteristicDefinition => {
          1 => 'unknown',
          2 => 'other',
          3 => 'temperature',
          4 => 'pressure',
          5 => 'emf',
          6 => 'currentValue',
          7 => 'airflow',
          8 => 'frequency',
          9 => 'power',
      },

      fcConnUnitPortTable => '1.3.6.1.2.1.8888.1.1.6',
      fcConnUnitPortEntry => '1.3.6.1.2.1.8888.1.1.6.1',
      fcConnUnitPortIndex => '1.3.6.1.2.1.8888.1.1.6.1.1',
      fcConnUnitPortType => '1.3.6.1.2.1.8888.1.1.6.1.2',
      fcConnUnitPortFCClassCap => '1.3',
      fcConnUnitPortFCClassOp => '1.3.6.1.2.1.8888.1.1.6.1.4',
      fcConnUnitPortState => '1.3.6.1.2.1.8888.1.1.6.1.5',
      fcConnUnitPortStatus => '1.3.6.1.2.1.8888.1.1.6.1.6',
      fcConnUnitPortTransmitterType => '1.3.6.1.2.1.8888.1.1.6.1.7',
      fcConnUnitPortModuleType => '1.3.6.1.2.1.8888.1.1.6.1.8',
      fcConnUnitPortWwn => '1.3.6.1.2.1.8888.1.1.6.1.9',
      fcConnUnitPortFCId => '1.3.6.1.2.1.8888.1.1.6.1.10',
      fcConnUnitPortSerialNo => '1.3.6.1.2.1.8888.1.1.6.1.11',
      fcConnUnitPortRevision => '1.3.6.1.2.1.8888.1.1.6.1.12',
      fcConnUnitPortVendor => '1.3.6.1.2.1.8888.1.1.6.1.13',
      fcConnUnitPortSpeed => '1.3.6.1.2.1.8888.1.1.6.1.14',
      fcConnUnitPortControl => '1.3.6.1.2.1.8888.1.1.6.1.15',
      fcConnUnitPortName => '1.3.6.1.2.1.8888.1.1.6.1.16',
      fcConnUnitPortPhysicalNumber => '1.3.6.1.2.1.8888.1.1.6.1.17',
      fcConnUnitPortProtocolCap => '1.3.6.1.2.1.8888.1.1.6.1.18',
      fcConnUnitPortProtocolOp => '1.3.6.1.2.1.8888.1.1.6.1.19',
      fcConnUnitPortNodeWwn => '1.3.6.1.2.1.8888.1.1.6.1.20',
      fcConnUnitPortHWState => '1.3.6.1.2.1.8888.1.1.6.1.21',

      fcConnUnitEventTable => '1.3.6.1.2.1.8888.1.1.7',
      fcConnUnitEventEntry => '1.3.6.1.2.1.8888.1.1.7.1',
      fcConnUnitEventIndex => '1.3.6.1.2.1.8888.1.1.7.1.1',
      fcConnUnitREventTime => '1.3.6.1.2.1.8888.1.1.7.1.2',
      fcConnUnitSEventTime => '1.3',
      fcConnUnitEventSeverity => '1.3.6.1.2.1.8888.1.1.7.1.4',
      fcConnUnitEventType => '1.3.6.1.2.1.8888.1.1.7.1.5',
      fcConnUnitEventObject => '1.3.6.1.2.1.8888.1.1.7.1.6',
      fcConnUnitEventDescr => '1.3.6.1.2.1.8888.1.1.7.1.7',

      fcConnUnitLinkTable => '1.3.6.1.2.1.8888.1.1.8',
      fcConnUnitLinkEntry => '1.3.6.1.2.1.8888.1.1.8.1',
      fcConnUnitLinkIndex => '1.3.6.1.2.1.8888.1.1.8.1.1',
      fcConnUnitLinkNodeIdX => '1.3.6.1.2.1.8888.1.1.8.1.2',
      fcConnUnitLinkPortNumberX => '1.3',
      fcConnUnitLinkPortWwnX => '1.3.6.1.2.1.8888.1.1.8.1.4',
      fcConnUnitLinkNodeIdY => '1.3.6.1.2.1.8888.1.1.8.1.5',
      fcConnUnitLinkPortNumberY => '1.3.6.1.2.1.8888.1.1.8.1.6',
      fcConnUnitLinkPortWwnY => '1.3.6.1.2.1.8888.1.1.8.1.7',
      fcConnUnitLinkAgentAddressY => '1.3.6.1.2.1.8888.1.1.8.1.8',
      fcConnUnitLinkAgentAddressTypeY => '1.3.6.1.2.1.8888.1.1.8.1.9',
      fcConnUnitLinkAgentPortY => '1.3.6.1.2.1.8888.1.1.8.1.10',
      fcConnUnitLinkUnitTypeY => '1.3.6.1.2.1.8888.1.1.8.1.11',
      fcConnUnitLinkConnIdY => '1.3.6.1.2.1.8888.1.1.8.1.12',

      fcConnUnitPortStatTable => '1.3.1',
      fcConnUnitPortStatEntry => '1.3.1.1',
      fcConnUnitPortStatIndex => '1.3.1.1.1',
      fcConnUnitPortStatErrs => '1.3.1.1.2',
      fcConnUnitPortStatTxObjects => '1.3',
      fcConnUnitPortStatRxObjects => '1.3.1.1.4',
      fcConnUnitPortStatTxElements => '1.3.1.1.5',
      fcConnUnitPortStatRxElements => '1.3.1.1.6',
      fcConnUnitPortStatBBCreditZero => '1.3.1.1.7',
      fcConnUnitPortStatInputBuffsFull => '1.3.1.1.8',
      fcConnUnitPortStatFBSYFrames => '1.3.1.1.9',
      fcConnUnitPortStatPBSYFrames => '1.3.1.1.10',
      fcConnUnitPortStatFRJTFrames => '1.3.1.1.11',
      fcConnUnitPortStatPRJTFrames => '1.3.1.1.12',
      fcConnUnitPortStatC1RxFrames => '1.3.1.1.13',
      fcConnUnitPortStatC1TxFrames => '1.3.1.1.14',
      fcConnUnitPortStatC1FBSYFrames => '1.3.1.1.15',
      fcConnUnitPortStatC1PBSYFrames => '1.3.1.1.16',
      fcConnUnitPortStatC1FRJTFrames => '1.3.1.1.17',
      fcConnUnitPortStatC1PRJTFrames => '1.3.1.1.18',
      fcConnUnitPortStatC2RxFrames => '1.3.1.1.19',
      fcConnUnitPortStatC2TxFrames => '1.3.1.1.20',
      fcConnUnitPortStatC2FBSYFrames => '1.3.1.1.21',
      fcConnUnitPortStatC2PBSYFrames => '1.3.1.1.22',
      fcConnUnitPortStatC2FRJTFrames => '1.3.1.1.23',
      fcConnUnitPortStatC2PRJTFrames => '1.3.1.1.24',
      fcConnUnitPortStatC3RxFrames => '1.3.1.1.25',
      fcConnUnitPortStatC3TxFrames => '1.3.1.1.26',
      fcConnUnitPortStatC3Discards => '1.3.1.1.27',
      fcConnUnitPortStatRxMcastObjects => '1.3.1.1.28',
      fcConnUnitPortStatTxMcastObjects => '1.3.1.1.29',
      fcConnUnitPortStatRxBcastObjects => '1.30',
      fcConnUnitPortStatTxBcastObjects => '1.31',
      fcConnUnitPortStatRxLinkResets => '1.32',
      fcConnUnitPortStatTxLinkResets => '1.33',
      fcConnUnitPortStatLinkResets => '1.34',
      fcConnUnitPortStatRxOfflineSeqs => '1.35',
      fcConnUnitPortStatTxOfflineSeqs => '1.36',
      fcConnUnitPortStatOfflineSeqs => '1.37',
      fcConnUnitPortStatLinkFailures => '1.38',
      fcConnUnitPortStatInvalidCRC => '1.39',
      fcConnUnitPortStatInvalidTxWords => '1.3.1.1.40',
      fcConnUnitPortStatPSPErrs => '1.3.1.1.41',
      fcConnUnitPortStatLossOfSignal => '1.3.1.1.42',
      fcConnUnitPortStatLossOfSync => '1.3.1.1.43',
      fcConnUnitPortStatInvOrderedSets => '1.3.1.1.44',
      fcConnUnitPortStatFramesTooLong => '1.3.1.1.45',
      fcConnUnitPortStatFramesTooShort => '1.3.1.1.46',
      fcConnUnitPortStatAddressErrs => '1.3.1.1.47',
      fcConnUnitPortStatDelimiterErrs => '1.3.1.1.48',
      fcConnUnitPortStatEncodingErrs => '1.3.1.1.49',

      fcConnUnitSnsMaxRows => '1.3.6.1.2.1.8888.1.1.9.0',
      fcConnUnitSnsTable => '1.3.6.1.2.1.8888.1.4.1',
      fcConnUnitSnsEntry => '1.3.6.1.2.1.8888.1.4.1.1',
      fcConnUnitSnsPortIndex => '1.3.6.1.2.1.8888.1.4.1.1.1',
      fcConnUnitSnsPortIdentifier => '1.3.6.1.2.1.8888.1.4.1.1.2',
      fcConnUnitSnsPortName => '1.3',
      fcConnUnitSnsNodeName => '1.3.6.1.2.1.8888.1.4.1.1.4',
      fcConnUnitSnsClassOfSvc => '1.3.6.1.2.1.8888.1.4.1.1.5',
      fcConnUnitSnsNodeIPAddress => '1.3.6.1.2.1.8888.1.4.1.1.6',
      fcConnUnitSnsProcAssoc => '1.3.6.1.2.1.8888.1.4.1.1.7',
      fcConnUnitSnsFC4Type => '1.3.6.1.2.1.8888.1.4.1.1.8',
      fcConnUnitSnsPortType => '1.3.6.1.2.1.8888.1.4.1.1.9',
      fcConnUnitSnsPortIPAddress => '1.3.6.1.2.1.8888.1.4.1.1.10',
      fcConnUnitSnsFabricPortName => '1.3.6.1.2.1.8888.1.4.1.1.11',
      fcConnUnitSnsHardAddress => '1.3.6.1.2.1.8888.1.4.1.1.12',
      fcConnUnitSnsSymbolicPortName => '1.3.6.1.2.1.8888.1.4.1.1.13',
      fcConnUnitSnsSymbolicNodeName => '1.3.6.1.2.1.8888.1.4.1.1.14',
  },
  'FCEOS-MIB' => {
      fcEosSysCurrentDate => '1.3.6.1.4.1.289.2.1.1.2.1.1.0',
      fcEosSysBootDate => '1.3.6.1.4.1.289.2.1.1.2.1.2.0',
      fcEosSysFirmwareVersion => '1.3.6.1.4.1.289.2.1.1.2.1.3.0',
      fcEosSysTypeNum => '1.3.6.1.4.1.289.2.1.1.2.1.4.0',
      fcEosSysModelNum => '1.3.6.1.4.1.289.2.1.1.2.1.5.0',
      fcEosSysMfg => '1.3.6.1.4.1.289.2.1.1.2.1.6.0',
      fcEosSysPlantOfMfg => '1.3.6.1.4.1.289.2.1.1.2.1.7.0',
      fcEosSysEcLevel => '1.3.6.1.4.1.289.2.1.1.2.1.8.0',
      fcEosSysSerialNum => '1.3.6.1.4.1.289.2.1.1.2.1.9.0',
      fcEosSysOperStatus => '1.3.6.1.4.1.289.2.1.1.2.1.10.0',
      fcEosSysOperStatusDefinition => {
          1 => 'operational',
          2 => 'redundant-failure',
          3 => 'minor-failure',
          4 => 'major-failure',
          5 => 'not-operational',
      },
      fcEosSysState => '1.3.6.1.4.1.289.2.1.1.2.1.11.0',
      fcEosSysAdmStatus => '1.3.6.1.4.1.289.2.1.1.2.1.12.0',
      fcEosSysConfigSpeed => '1.3.6.1.4.1.289.2.1.1.2.1.13.0',
      fcEosSysOpenTrunking => '1.3.6.1.4.1.289.2.1.1.2.1.14.0',

      fcEosFruTable => '1.3.6.1.4.1.289.2.1.1.2.2.1',
      fcEosFruEntry => '1.3.6.1.4.1.289.2.1.1.2.2.1.1',
      fcEosFruCode => '1.3.6.1.4.1.289.2.1.1.2.2.1.1.1',
      fcEosFruCodeDefinition => {
          1 => 'fru-bkplane', # Backplane 
          2 => 'fru-ctp', # Control Processor card 
          3 => 'fru-sbar', # Serial Crossbar 
          4 => 'fru-fan2', # Center fan module 
          5 => 'fru-fan', # Fan module 
          6 => 'fru-power', # Power supply module 
          7 => 'fru-reserved', # Reserved, not used 
          8 => 'fru-glsl', # Longwave, Single-Mode, LC connector, 1 Gig 
          9 => 'fru-gsml', # Shortwave, Multi-Mode, LC connector, 1 Gig 
          10 => 'fru-gxxl', # Mixed, LC connector, 1 Gig 
          11 => 'fru-gsf1', # SFO pluggable, 1 Gig 
          12 => 'fru-gsf2', # SFO pluggable, 2 Gig 
          13 => 'fru-glsr', # Longwave, Single-Mode, MT-RJ connector, 1 Gig 
          14 => 'fru-gsmr', # Shortwave, Multi-Mode, MT-RJ connector, 1 Gig 
          15 => 'fru-gxxr', # Mixed, MT-RJ connector, 1 Gig 
          16 => 'fru-fint1', # F-Port, internal, 1 Gig 
      },
      fcEosFruPosition => '1.3.6.1.4.1.289.2.1.1.2.2.1.1.2',
      fcEosFruStatus => '1.3.6.1.4.1.289.2.1.1.2.2.1.1.3',
      fcEosFruStatusDefinition => {
          0 => 'unknown',
          1 => 'active',
          2 => 'backup',
          3 => 'update-busy',
          4 => 'failed',
      },
      fcEosFruPartNumber => '1.3.6.1.4.1.289.2.1.1.2.2.1.1.4',
      fcEosFruSerialNumber => '1.3.6.1.4.1.289.2.1.1.2.2.1.1.5',
      fcEosFruPowerOnHours => '1.3.6.1.4.1.289.2.1.1.2.2.1.1.6',
      fcEosFruTestDate => '1.3.6.1.4.1.289.2.1.1.2.2.1.1.7',

      fcEosTATable => '1.3.6.1.4.1.289.2.1.1.2.6.1',
      fcEosTAEntry => '1.3.6.1.4.1.289.2.1.1.2.6.1.1',
      fcEosTAIndex => '1.3.6.1.4.1.289.2.1.1.2.6.1.1.1',
      fcEosTAName => '1.3.6.1.4.1.289.2.1.1.2.6.1.1.2',
      fcEosTAState => '1.3.6.1.4.1.289.2.1.1.2.6.1.1.3',
      fcEosTAType => '1.3.6.1.4.1.289.2.1.1.2.6.1.1.4',
      fcEosTAPortType => '1.3.6.1.4.1.289.2.1.1.2.6.1.1.5',
      fcEosTAPortList => '1.3.6.1.4.1.289.2.1.1.2.6.1.1.6',
      fcEosTAInterval => '1.3.6.1.4.1.289.2.1.1.2.6.1.1.7',
      fcEosTATriggerValue => '1.3.6.1.4.1.289.2.1.1.2.6.1.1.8',
      fcEosTTADirection => '1.3.6.1.4.1.289.2.1.1.2.6.1.1.9',
      fcEosTTATriggerDuration => '1.3.6.1.4.1.289.2.1.1.2.6.1.1.10',
      fcEosCTACounter => '1.3.6.1.4.1.289.2.1.1.2.6.1.1.11',
  },
  'F5-BIGIP-SYSTEM-MIB' => {
# http://support.f5.com/kb/en-us/products/big-ip_ltm/manuals/product/bigip9_2_2mgmt/BIG-IP_9_2_2nsm_guide-16-1.html
# http://support.f5.com/kb/en-us/products/big-ip_ltm/manuals/product/tmos_management_guide_10_0_0/tmos_appendix_a_traps.html
# http://support.f5.com/kb/en-us/solutions/public/9000/400/sol9476.html
      sysStatMemoryTotal => '1.3.6.1.4.1.3375.2.1.1.2.1.44.0',
      sysStatMemoryUsed => '1.3.6.1.4.1.3375.2.1.1.2.1.45.0',
      sysHostMemoryTotal => '1.3.6.1.4.1.3375.2.1.7.1.1.0',
      sysHostMemoryUsed => '1.3.6.1.4.1.3375.2.1.7.1.2.0',
# http://www.midnight-visions.de/f5-bigip-und-snmp/
      sysStatTmTotalCycles => '1.3.6.1.4.1.3375.2.1.1.2.1.41.0',
      sysStatTmIdleCycles => '1.3.6.1.4.1.3375.2.1.1.2.1.42.0',
      sysStatTmSleepCycles => '1.3.6.1.4.1.3375.2.1.1.2.1.43.0',

      sysCpuNumber => '1.3.6.1.4.1.3375.2.1.3.1.1.0',
      sysCpuTable => '1.3.6.1.4.1.3375.2.1.3.1.2',
      sysCpuEntry => '1.3.6.1.4.1.3375.2.1.3.1.2.1',
      sysCpuIndex => '1.3.6.1.4.1.3375.2.1.3.1.2.1.1',
      sysCpuTemperature => '1.3.6.1.4.1.3375.2.1.3.1.2.1.2',
      sysCpuFanSpeed => '1.3.6.1.4.1.3375.2.1.3.1.2.1.3',
      sysCpuName => '1.3.6.1.4.1.3375.2.1.3.1.2.1.4',
      sysCpuSlot => '1.3.6.1.4.1.3375.2.1.3.1.2.1.5',

      sysChassisFan => '1.3.6.1.4.1.3375.2.1.3.2.1',
      sysChassisFanNumber => '1.3.6.1.4.1.3375.2.1.3.2.1.1.0',
      sysChassisFanTable => '1.3.6.1.4.1.3375.2.1.3.2.1.2',
      sysChassisFanEntry => '1.3.6.1.4.1.3375.2.1.3.2.1.2.1',
      sysChassisFanIndex => '1.3.6.1.4.1.3375.2.1.3.2.1.2.1.1',
      sysChassisFanStatus => '1.3.6.1.4.1.3375.2.1.3.2.1.2.1.2',
      sysChassisFanStatusDefinition => {
          0 => 'bad',
          1 => 'good',
          2 => 'notpresent',
      },
      sysChassisFanSpeed => '1.3.6.1.4.1.3375.2.1.3.2.1.2.1.3',

      sysChassisPowerSupply => '1.3.6.1.4.1.3375.2.1.3.2.2',
      sysChassisPowerSupplyNumber => '1.3.6.1.4.1.3375.2.1.3.2.2.1.0',
      sysChassisPowerSupplyTable => '1.3.6.1.4.1.3375.2.1.3.2.2.2',
      sysChassisPowerSupplyEntry => '1.3.6.1.4.1.3375.2.1.3.2.2.2.1',
      sysChassisPowerSupplyIndex => '1.3.6.1.4.1.3375.2.1.3.2.2.2.1.1',
      sysChassisPowerSupplyStatus => '1.3.6.1.4.1.3375.2.1.3.2.2.2.1.2',
      sysChassisPowerSupplyStatusDefinition => {
          0 => 'bad',
          1 => 'good',
          2 => 'notpresent',
      },

      sysChassisTemp => '1.3.6.1.4.1.3375.2.1.3.2.3',
      sysChassisTempNumber => '1.3.6.1.4.1.3375.2.1.3.2.3.1.0',
      sysChassisTempTable => '1.3.6.1.4.1.3375.2.1.3.2.3.2',
      sysChassisTempEntry => '1.3.6.1.4.1.3375.2.1.3.2.3.2.1',
      sysChassisTempIndex => '1.3.6.1.4.1.3375.2.1.3.2.3.2.1.1',
      sysChassisTempTemperature => '1.3.6.1.4.1.3375.2.1.3.2.3.2.1.2',

      sysProduct => '1.3.6.1.4.1.3375.2.1.4',
      sysProductName => '1.3.6.1.4.1.3375.2.1.4.1.0',
      sysProductVersion => '1.3.6.1.4.1.3375.2.1.4.2.0',
      sysProductBuild => '1.3.6.1.4.1.3375.2.1.4.3.0',
      sysProductEdition => '1.3.6.1.4.1.3375.2.1.4.4.0',
      sysProductDate => '1.3.6.1.4.1.3375.2.1.4.5.0',

      sysSubMemory => '1.3.6.1.4.1.3375.2.1.5',
      sysSubMemoryResetStats => '1.3.6.1.4.1.3375.2.1.5.1.0',
      sysSubMemoryNumber => '1.3.6.1.4.1.3375.2.1.5.2.0',
      sysSubMemoryTable => '1.3.6.1.4.1.3375.2.1.5.3',
      sysSubMemoryEntry => '1.3.6.1.4.1.3375.2.1.5.3.1',
      sysSubMemoryName => '1.3.6.1.4.1.3375.2.1.5.3.1.1',
      sysSubMemoryAllocated => '1.3.6.1.4.1.3375.2.1.5.3.1.2',
      sysSubMemoryMaxAllocated => '1.3.6.1.4.1.3375.2.1.5.3.1.3',
      sysSubMemorySize => '1.3.6.1.4.1.3375.2.1.5.3.1.4',

      sysSystem => '1.3.6.1.4.1.3375.2.1.6',
      sysSystemName => '1.3.6.1.4.1.3375.2.1.6.1.0',
      sysSystemNodeName => '1.3.6.1.4.1.3375.2.1.6.2.0',
      sysSystemRelease => '1.3.6.1.4.1.3375.2.1.6.3.0',
      sysSystemVersion => '1.3.6.1.4.1.3375.2.1.6.4.0',
      sysSystemMachine => '1.3.6.1.4.1.3375.2.1.6.5.0',
      sysSystemUptime => '1.3.6.1.4.1.3375.2.1.6.6.0',
      bigipSystemGroups => '1.3.6.1.4.1.3375.2.5.2.1',
  },
  'HP-ICF-CHASSIS-MIB' => {
      hpicfSensorTable => '1.3.6.1.4.1.11.2.14.11.1.2.6',
      hpicfSensorEntry => '1.3.6.1.4.1.11.2.14.11.1.2.6.1',
      hpicfSensorIndex => '1.3.6.1.4.1.11.2.14.11.1.2.6.1.1',
      hpicfSensorObjectId => '1.3.6.1.4.1.11.2.14.11.1.2.6.1.2',
      hpicfSensorObjectIdDefinition => {
          1 => 'fan sensor',
          2 => 'power supply',
          3 => 'redundant power supply',
          4 => 'over-temperature sensor',
      },
      hpicfSensorNumber => '1.3.6.1.4.1.11.2.14.11.1.2.6.1.3',
      hpicfSensorStatus => '1.3.6.1.4.1.11.2.14.11.1.2.6.1.4',
      hpicfSensorStatusDefinition => {
          1 => 'unknown',
          2 => 'bad',
          3 => 'warning',
          4 => 'good',
          5 => 'notPresent',
      },
      hpicfSensorWarnings => '1.3.6.1.4.1.11.2.14.11.1.2.6.1.5',
      hpicfSensorFailures => '1.3.6.1.4.1.11.2.14.11.1.2.6.1.6',
      hpicfSensorDescr => '1.3.6.1.4.1.11.2.14.11.1.2.6.1.7',
#hpicfSensorObjectId.1 = icfFanSensor
#hpicfSensorObjectId.2 = icfPowerSupplySensor
#hpicfSensorObjectId.3 = icfPowerSupplySensor
#hpicfSensorObjectId.4 = icfTemperatureSensor

#hpicfSensorDescr.1 = Fan Sensor
#hpicfSensorDescr.2 = Power Supply Sensor
#hpicfSensorDescr.3 = Redundant Power Supply Sensor
#hpicfSensorDescr.4 = Over-temperature Sensor

  },
  'F5-BIGIP-LOCAL-MIB' => {
    ltmPoolNumber => '1.3.6.1.4.1.3375.2.2.5.1.1.0',
    ltmPoolTable => '1.3.6.1.4.1.3375.2.2.5.1.2',
    ltmPoolEntry => '1.3.6.1.4.1.3375.2.2.5.1.2.1',
    ltmPoolName => '1.3.6.1.4.1.3375.2.2.5.1.2.1.1',
    ltmPoolLbMode => '1.3.6.1.4.1.3375.2.2.5.1.2.1.2',
    ltmPoolActionOnServiceDown => '1.3.6.1.4.1.3375.2.2.5.1.2.1.3',
    ltmPoolMinUpMembers => '1.3.6.1.4.1.3375.2.2.5.1.2.1.4',
    ltmPoolMinUpMembersEnable => '1.3.6.1.4.1.3375.2.2.5.1.2.1.5',
    ltmPoolMinUpMemberAction => '1.3.6.1.4.1.3375.2.2.5.1.2.1.6',
    ltmPoolMinActiveMembers => '1.3.6.1.4.1.3375.2.2.5.1.2.1.7',
    ltmPoolActiveMemberCnt => '1.3.6.1.4.1.3375.2.2.5.1.2.1.8',
    ltmPoolDisallowSnat => '1.3.6.1.4.1.3375.2.2.5.1.2.1.9',
    ltmPoolDisallowNat => '1.3.6.1.4.1.3375.2.2.5.1.2.1.10',
    ltmPoolSimpleTimeout => '1.3.6.1.4.1.3375.2.2.5.1.2.1.11',
    ltmPoolIpTosToClient => '1.3.6.1.4.1.3375.2.2.5.1.2.1.12',
    ltmPoolIpTosToServer => '1.3.6.1.4.1.3375.2.2.5.1.2.1.13',
    ltmPoolLinkQosToClient => '1.3.6.1.4.1.3375.2.2.5.1.2.1.14',
    ltmPoolLinkQosToServer => '1.3.6.1.4.1.3375.2.2.5.1.2.1.15',
    ltmPoolDynamicRatioSum => '1.3.6.1.4.1.3375.2.2.5.1.2.1.16',
    ltmPoolMonitorRule => '1.3.6.1.4.1.3375.2.2.5.1.2.1.17',
    ltmPoolAvailabilityState => '1.3.6.1.4.1.3375.2.2.5.1.2.1.18',
    ltmPoolEnabledState => '1.3.6.1.4.1.3375.2.2.5.1.2.1.19',
    ltmPoolDisabledParentType => '1.3.6.1.4.1.3375.2.2.5.1.2.1.20',
    ltmPoolStatusReason => '1.3.6.1.4.1.3375.2.2.5.1.2.1.21',
    ltmPoolSlowRampTime => '1.3.6.1.4.1.3375.2.2.5.1.2.1.22',
    ltmPoolMemberCnt => '1.3.6.1.4.1.3375.2.2.5.1.2.1.23',

    ltmPoolMemberTable => '1.3.6.1.4.1.3375.2.2.5.3.2',
    ltmPoolMemberEntry => '1.3.6.1.4.1.3375.2.2.5.3.2.1',
    ltmPoolMemberPoolName => '1.3.6.1.4.1.3375.2.2.5.3.2.1.1',
    ltmPoolMemberAddrType => '1.3.6.1.4.1.3375.2.2.5.3.2.1.2',
    ltmPoolMemberAddr => '1.3.6.1.4.1.3375.2.2.5.3.2.1.3',
    ltmPoolMemberPort => '1.3.6.1.4.1.3375.2.2.5.3.2.1.4',
    ltmPoolMemberConnLimit => '1.3.6.1.4.1.3375.2.2.5.3.2.1.5',
    ltmPoolMemberRatio => '1.3.6.1.4.1.3375.2.2.5.3.2.1.6',
    ltmPoolMemberWeight => '1.3.6.1.4.1.3375.2.2.5.3.2.1.7',
    ltmPoolMemberPriority => '1.3.6.1.4.1.3375.2.2.5.3.2.1.8',
    ltmPoolMemberDynamicRatio => '1.3.6.1.4.1.3375.2.2.5.3.2.1.9',
    ltmPoolMemberMonitorState => '1.3.6.1.4.1.3375.2.2.5.3.2.1.10',
    ltmPoolMemberMonitorStateDefinition => 'F5-BIGIP-LOCAL-MIB::ltmPoolMemberMonitorState',
    ltmPoolMemberMonitorStatus => '1.3.6.1.4.1.3375.2.2.5.3.2.1.11',
    ltmPoolMemberMonitorStatusDefinition => 'F5-BIGIP-LOCAL-MIB::ltmPoolMemberMonitorStatus',
    ltmPoolMemberNewSessionEnable => '1.3.6.1.4.1.3375.2.2.5.3.2.1.12',
    ltmPoolMemberSessionStatus => '1.3.6.1.4.1.3375.2.2.5.3.2.1.13',
    ltmPoolMemberMonitorRule => '1.3.6.1.4.1.3375.2.2.5.3.2.1.14',
    ltmPoolMemberAvailabilityState => '1.3.6.1.4.1.3375.2.2.5.3.2.1.15',
    ltmPoolMemberEnabledState => '1.3.6.1.4.1.3375.2.2.5.3.2.1.16',
    ltmPoolMemberDisabledParentType => '1.3.6.1.4.1.3375.2.2.5.3.2.1.17',
    ltmPoolMemberStatusReason => '1.3.6.1.4.1.3375.2.2.5.3.2.1.18',

    ltmPoolStatusNumber => '1.3.6.1.4.1.3375.2.2.5.5.1.0',
    ltmPoolStatusTable => '1.3.6.1.4.1.3375.2.2.5.5.2',
    ltmPoolStatusEntry => '1.3.6.1.4.1.3375.2.2.5.5.2.1',
    ltmPoolStatusName => '1.3.6.1.4.1.3375.2.2.5.5.2.1.1',
    ltmPoolStatusAvailState => '1.3.6.1.4.1.3375.2.2.5.5.2.1.2',
    ltmPoolStatusAvailStateDefinition => 'F5-BIGIP-LOCAL-MIB::ltmPoolStatusAvailState',
    ltmPoolStatusEnabledState => '1.3.6.1.4.1.3375.2.2.5.5.2.1.3',
    ltmPoolStatusEnabledStateDefinition => 'F5-BIGIP-LOCAL-MIB::ltmPoolStatusEnabledState',
    ltmPoolStatusParentType => '1.3.6.1.4.1.3375.2.2.5.5.2.1.4',
    ltmPoolStatusDetailReason => '1.3.6.1.4.1.3375.2.2.5.5.2.1.5',

    ltmPoolMbrStatusNumber => '1.3.6.1.4.1.3375.2.2.5.6.1.0',
    ltmPoolMbrStatusTable => '1.3.6.1.4.1.3375.2.2.5.6.2',
    ltmPoolMbrStatusEntry => '1.3.6.1.4.1.3375.2.2.5.6.2.1',
    ltmPoolMbrStatusPoolName => '1.3.6.1.4.1.3375.2.2.5.6.2.1.1',
    ltmPoolMbrStatusAddrType => '1.3.6.1.4.1.3375.2.2.5.6.2.1.2',
    ltmPoolMbrStatusAddr => '1.3.6.1.4.1.3375.2.2.5.6.2.1.3',
    ltmPoolMbrStatusPort => '1.3.6.1.4.1.3375.2.2.5.6.2.1.4',
    ltmPoolMbrStatusAvailState => '1.3.6.1.4.1.3375.2.2.5.6.2.1.5',
    ltmPoolMbrStatusAvailStateDefinition => 'F5-BIGIP-LOCAL-MIB::ltmPoolMbrStatusAvailState',
    ltmPoolMbrStatusEnabledState => '1.3.6.1.4.1.3375.2.2.5.6.2.1.6',
    ltmPoolMbrStatusEnabledStateDefinition => 'F5-BIGIP-LOCAL-MIB::ltmPoolMbrStatusEnabledState',
    ltmPoolMbrStatusParentType => '1.3.6.1.4.1.3375.2.2.5.6.2.1.7',
    ltmPoolMbrStatusDetailReason => '1.3.6.1.4.1.3375.2.2.5.6.2.1.8',
    ltmPoolMbrStatusNodeName => '1.3.6.1.4.1.3375.2.2.5.6.2.1.9',

    ltmNodeAddrStatusTable => '1.3.6.1.4.1.3375.2.2.4.3.2',
    ltmNodeAddrStatusEntry => '1.3.6.1.4.1.3375.2.2.4.3.2.1',
    ltmNodeAddrStatusAddrType => '1.3.6.1.4.1.3375.2.2.4.3.2.1.1',
    ltmNodeAddrStatusAddr => '1.3.6.1.4.1.3375.2.2.4.3.2.1.2',
    ltmNodeAddrStatusAvailState => '1.3.6.1.4.1.3375.2.2.4.3.2.1.3',
    ltmNodeAddrStatusEnabledState => '1.3.6.1.4.1.3375.2.2.4.3.2.1.4',
    ltmNodeAddrStatusParentType => '1.3.6.1.4.1.3375.2.2.4.3.2.1.5',
    ltmNodeAddrStatusDetailReason => '1.3.6.1.4.1.3375.2.2.4.3.2.1.6',
    ltmNodeAddrStatusName => '1.3.6.1.4.1.3375.2.2.4.3.2.1.7',
  },
  'LOAD-BAL-SYSTEM-MIB' => {
    poolTable => '1.3.6.1.4.1.3375.1.1.7.2',
    poolEntry => '1.3.6.1.4.1.3375.1.1.7.2.1',
    poolName => '1.3.6.1.4.1.3375.1.1.7.2.1.1',
    poolLBMode => '1.3.6.1.4.1.3375.1.1.7.2.1.2',
    poolDependent => '1.3.6.1.4.1.3375.1.1.7.2.1.3',
    poolMemberQty => '1.3.6.1.4.1.3375.1.1.7.2.1.4',
    poolBitsin => '1.3.6.1.4.1.3375.1.1.7.2.1.5',
    poolBitsout => '1.3.6.1.4.1.3375.1.1.7.2.1.6',
    poolBitsinHi32 => '1.3.6.1.4.1.3375.1.1.7.2.1.7',
    poolBitsoutHi32 => '1.3.6.1.4.1.3375.1.1.7.2.1.8',
    poolPktsin => '1.3.6.1.4.1.3375.1.1.7.2.1.9',
    poolPktsout => '1.3.6.1.4.1.3375.1.1.7.2.1.10',
    poolPktsinHi32 => '1.3.6.1.4.1.3375.1.1.7.2.1.11',
    poolPktsoutHi32 => '1.3.6.1.4.1.3375.1.1.7.2.1.12',
    poolMaxConn => '1.3.6.1.4.1.3375.1.1.7.2.1.13',
    poolCurrentConn => '1.3.6.1.4.1.3375.1.1.7.2.1.14',
    poolTotalConn => '1.3.6.1.4.1.3375.1.1.7.2.1.15',
    poolPersistMode => '1.3.6.1.4.1.3375.1.1.7.2.1.16',
    poolSSLTimeout => '1.3.6.1.4.1.3375.1.1.7.2.1.17',
    poolSimpleTimeout => '1.3.6.1.4.1.3375.1.1.7.2.1.18',
    poolSimpleMask => '1.3.6.1.4.1.3375.1.1.7.2.1.19',
    poolStickyMask => '1.3.6.1.4.1.3375.1.1.7.2.1.20',
    poolCookieMode => '1.3.6.1.4.1.3375.1.1.7.2.1.21',
    poolCookieExpiration => '1.3.6.1.4.1.3375.1.1.7.2.1.22',
    poolCookieHashName => '1.3.6.1.4.1.3375.1.1.7.2.1.23',
    poolCookieHashOffset => '1.3.6.1.4.1.3375.1.1.7.2.1.24',
    poolCookieHashLength => '1.3.6.1.4.1.3375.1.1.7.2.1.25',
    poolMinActiveMembers => '1.3.6.1.4.1.3375.1.1.7.2.1.26',
    poolActiveMemberCount => '1.3.6.1.4.1.3375.1.1.7.2.1.27',
    poolPersistMirror => '1.3.6.1.4.1.3375.1.1.7.2.1.28',
    poolFallbackHost => '1.3.6.1.4.1.3375.1.1.7.2.1.29',
    poolMemberTable => '1.3.6.1.4.1.3375.1.1.8.2',
    poolMemberEntry => '1.3.6.1.4.1.3375.1.1.8.2.1',
    poolMemberPoolName => '1.3.6.1.4.1.3375.1.1.8.2.1.1',
    poolMemberIpAddress => '1.3.6.1.4.1.3375.1.1.8.2.1.2',
    poolMemberPort => '1.3.6.1.4.1.3375.1.1.8.2.1.3',
    poolMemberMaintenance => '1.3.6.1.4.1.3375.1.1.8.2.1.4',
    poolMemberRatio => '1.3.6.1.4.1.3375.1.1.8.2.1.5',
    poolMemberPriority => '1.3.6.1.4.1.3375.1.1.8.2.1.6',
    poolMemberWeight => '1.3.6.1.4.1.3375.1.1.8.2.1.7',
    poolMemberRipeness => '1.3.6.1.4.1.3375.1.1.8.2.1.8',
    poolMemberBitsin => '1.3.6.1.4.1.3375.1.1.8.2.1.9',
    poolMemberBitsout => '1.3.6.1.4.1.3375.1.1.8.2.1.10',
    poolMemberBitsinHi32 => '1.3.6.1.4.1.3375.1.1.8.2.1.11',
    poolMemberBitsoutHi32 => '1.3.6.1.4.1.3375.1.1.8.2.1.12',
    poolMemberPktsin => '1.3.6.1.4.1.3375.1.1.8.2.1.13',
    poolMemberPktsout => '1.3.6.1.4.1.3375.1.1.8.2.1.14',
    poolMemberPktsinHi32 => '1.3.6.1.4.1.3375.1.1.8.2.1.15',
    poolMemberPktsoutHi32 => '1.3.6.1.4.1.3375.1.1.8.2.1.16',
    poolMemberConnLimit => '1.3.6.1.4.1.3375.1.1.8.2.1.17',
    poolMemberMaxConn => '1.3.6.1.4.1.3375.1.1.8.2.1.18',
    poolMemberCurrentConn => '1.3.6.1.4.1.3375.1.1.8.2.1.19',
    poolMemberTotalConn => '1.3.6.1.4.1.3375.1.1.8.2.1.20',
    poolMemberStatus => '1.3.6.1.4.1.3375.1.1.8.2.1.21',
    poolMemberIpStatus => '1.3.6.1.4.1.3375.1.1.8.2.1.22',
  },
  'OLD-STATISTICS-MIB' => {
      hpSwitchCpuStat => '1.3.6.1.2.1.1.7.11.12.9.6.1.0',  # "The CPU utilization in percent(%)."
  },
  'STATISTICS-MIB' => {
      hpSwitchCpuStat => '1.3.6.1.4.1.11.2.14.11.5.1.9.6.1.0',  # "The CPU utilization in percent(%)."
  },
  'OLD-NETSWITCH-MIB' => {
      # hpLocalMemTotalBytes   1.3.6.1.4.1.11.2.14.11.5.1.1.2.1.1.1.5
      # hpLocalMemFreeBytes    1.3.6.1.4.1.11.2.14.11.5.1.1.2.1.1.1.6
      # hpLocalMemAllocBytes   1.3.6.1.4.1.11.2.14.11.5.1.1.2.1.1.1.7
      hpLocalMemTable => '1.3.6.1.2.1.1.7.11.12.1.2.1.1',
      hpLocalMemEntry => '1.3.6.1.2.1.1.7.11.12.1.2.1.1.1',
      hpLocalMemSlotIndex => '1.3.6.1.2.1.1.7.11.12.1.2.1.1.1.1',
      hpLocalMemSlabCnt => '1.3.6.1.2.1.1.7.11.12.1.2.1.1.1.2',
      hpLocalMemFreeSegCnt => '1.3.6.1.2.1.1.7.11.12.1.2.1.1.1.3',
      hpLocalMemAllocSegCnt => '1.3.6.1.2.1.1.7.11.12.1.2.1.1.1.4',
      hpLocalMemTotalBytes => '1.3.6.1.2.1.1.7.11.12.1.2.1.1.1.5',
      hpLocalMemFreeBytes => '1.3.6.1.2.1.1.7.11.12.1.2.1.1.1.6',
      hpLocalMemAllocBytes => '1.3.6.1.2.1.1.7.11.12.1.2.1.1.1.7',
      hpGlobalMemTable => '1.3.6.1.2.1.1.7.11.12.1.2.2.1',
      hpGlobalMemEntry => '1.3.6.1.2.1.1.7.11.12.1.2.2.1.1',
      hpGlobalMemSlotIndex => '1.3.6.1.2.1.1.7.11.12.1.2.2.1.1.1',
      hpGlobalMemSlabCnt => '1.3.6.1.2.1.1.7.11.12.1.2.2.1.1.2',
      hpGlobalMemFreeSegCnt => '1.3.6.1.2.1.1.7.11.12.1.2.2.1.1.3',
      hpGlobalMemAllocSegCnt => '1.3.6.1.2.1.1.7.11.12.1.2.2.1.1.4',
      hpGlobalMemTotalBytes => '1.3.6.1.2.1.1.7.11.12.1.2.2.1.1.5',
      hpGlobalMemFreeBytes => '1.3.6.1.2.1.1.7.11.12.1.2.2.1.1.6',
      hpGlobalMemAllocBytes => '1.3.6.1.2.1.1.7.11.12.1.2.2.1.1.7',
  },
  'NETSWITCH-MIB' => { #evt moderner
      hpLocalMemTable => '1.3.6.1.4.1.11.2.14.11.5.1.1.2.1.1',
      hpLocalMemEntry => '1.3.6.1.4.1.11.2.14.11.5.1.1.2.1.1.1',
      hpLocalMemSlotIndex => '1.3.6.1.4.1.11.2.14.11.5.1.1.2.1.1.1.1',
      hpLocalMemSlabCnt => '1.3.6.1.4.1.11.2.14.11.5.1.1.2.1.1.1.2',
      hpLocalMemFreeSegCnt => '1.3.6.1.4.1.11.2.14.11.5.1.1.2.1.1.1.3',
      hpLocalMemAllocSegCnt => '1.3.6.1.4.1.11.2.14.11.5.1.1.2.1.1.1.4',
      hpLocalMemTotalBytes => '1.3.6.1.4.1.11.2.14.11.5.1.1.2.1.1.1.5',
      hpLocalMemFreeBytes => '1.3.6.1.4.1.11.2.14.11.5.1.1.2.1.1.1.6',
      hpLocalMemAllocBytes => '1.3.6.1.4.1.11.2.14.11.5.1.1.2.1.1.1.7',
      hpGlobalMemTable => '1.3.6.1.4.1.11.2.14.11.5.1.1.2.2.1',
      hpGlobalMemEntry => '1.3.6.1.4.1.11.2.14.11.5.1.1.2.2.1.1',
      hpGlobalMemSlotIndex => '1.3.6.1.4.1.11.2.14.11.5.1.1.2.2.1.1.1',
      hpGlobalMemSlabCnt => '1.3.6.1.4.1.11.2.14.11.5.1.1.2.2.1.1.2',
      hpGlobalMemFreeSegCnt => '1.3.6.1.4.1.11.2.14.11.5.1.1.2.2.1.1.3',
      hpGlobalMemAllocSegCnt => '1.3.6.1.4.1.11.2.14.11.5.1.1.2.2.1.1.4',
      hpGlobalMemTotalBytes => '1.3.6.1.4.1.11.2.14.11.5.1.1.2.2.1.1.5',
      hpGlobalMemFreeBytes => '1.3.6.1.4.1.11.2.14.11.5.1.1.2.2.1.1.6',
      hpGlobalMemAllocBytes => '1.3.6.1.4.1.11.2.14.11.5.1.1.2.2.1.1.7',
  },
  'CHECKPOINT-MIB' => { #evt moderner
      svnProcGroup => '1.3.6.1.4.1.2620.1.6.7.2',
      procUsage => '1.3.6.1.4.1.2620.1.6.7.2.4.0',
      procQueue => '1.3.6.1.4.1.2620.1.6.7.2.5.0',

      haGroup => '1.3.6.1.4.1.2620.1.5',
      haProdName => '1.3.6.1.4.1.2620.1.5.1.0',
      haInstalled => '1.3.6.1.4.1.2620.1.5.2.0',
      haVerMajor => '1.3.6.1.4.1.2620.1.5.3.0',
      haVerMinor => '1.3.6.1.4.1.2620.1.5.4.0',
      haStarted => '1.3.6.1.4.1.2620.1.5.5.0',
      haState => '1.3.6.1.4.1.2620.1.5.6.0',
      haBlockState => '1.3.6.1.4.1.2620.1.5.7.0',
      haIdentifier => '1.3.6.1.4.1.2620.1.5.8.0',
      haProtoVersion => '1.3.6.1.4.1.2620.1.5.10.0',
      haWorkMode => '1.3.6.1.4.1.2620.1.5.11.0',
      haVersionSting => '1.3.6.1.4.1.2620.1.5.14.0',
      haStatCode => '1.3.6.1.4.1.2620.1.5.101.0',
      haStatShort => '1.3.6.1.4.1.2620.1.5.102.0',
      haStatLong => '1.3.6.1.4.1.2620.1.5.103.0',
      haServicePack => '1.3.6.1.4.1.2620.1.5.999.0',

      fwGroup => ' 1.3.6.1.4.1.2620.1.1',
      fwModuleState => '1.3.6.1.4.1.2620.1.1.1.0',
      fwFilterName => '1.3.6.1.4.1.2620.1.1.2.0',

      fwPolicyStatGroup => '1.3.6.1.4.1.2620.1.1.25',
      fwPolicyName => '1.3.6.1.4.1.2620.1.1.25.1.0',
      fwInstallTime => '1.3.6.1.4.1.2620.1.1.25.2.0',
      fwNumConn => '1.3.6.1.4.1.2620.1.1.25.3.0',
      fwPeakNumConn => '1.3.6.1.4.1.2620.1.1.25.4.0',

      svnStatShortDescr => '1.3.6.1.4.1.2620.1.6.102.0',
      svnStatLongDescr => '1.3.6.1.4.1.2620.1.6.103.0',

      mgStatShortDescr => '1.3.6.1.4.1.2620.1.7.102.0',
      mgStatLongDescr => '1.3.6.1.4.1.2620.1.7.103.0',

      memTotalVirtual64 => '1.3.6.1.4.1.2620.1.6.7.4.1.0',
      memActiveVirtual64 => '1.3.6.1.4.1.2620.1.6.7.4.2.0',
      memTotalReal64 => '1.3.6.1.4.1.2620.1.6.7.4.3.0',
      memActiveReal64 => '1.3.6.1.4.1.2620.1.6.7.4.4.0',
      memFreeReal64 => '1.3.6.1.4.1.2620.1.6.7.4.5.0',
      memSwapsSec64 => '1.3.6.1.4.1.2620.1.6.7.4.6.0',
      memDiskTransfers64 => '1.3.6.1.4.1.2620.1.6.7.4.7.0',

  },
  'NETSCREEN-RESOURCE-MIB' => {
      nsResCpuAvg => '1.3.6.1.4.1.3224.16.1.1.0',
      nsResCpuLast15Min => '1.3.6.1.4.1.3224.16.1.4.0',
      nsResCpuLast1Min => '1.3.6.1.4.1.3224.16.1.2.0',
      nsResCpuLast5Min => '1.3.6.1.4.1.3224.16.1.3.0',
      nsResMemAllocate => '1.3.6.1.4.1.3224.16.2.1.0',
      nsResMemFrag => '1.3.6.1.4.1.3224.16.2.3.0',
      nsResMemLeft => '1.3.6.1.4.1.3224.16.2.2.0',
      nsResSessAllocate => '1.3.6.1.4.1.3224.16.3.2.0',
      nsResSessFailed => '1.3.6.1.4.1.3224.16.3.4.0',
      nsResSessMaxium => '1.3.6.1.4.1.3224.16.3.3.0',
  },

  'ATTACK-MIB' => { # Blue Coat
      deviceAttackTable => '1.3.6.1.4.1.3417.2.3.1.1.1',
      deviceAttackEntry => '1.3.6.1.4.1.3417.2.3.1.1.1.1',
      deviceAttackIndex => '1.3.6.1.4.1.3417.2.3.1.1.1.1.1',
      deviceAttackName => '1.3.6.1.4.1.3417.2.3.1.1.1.1.2',
      deviceAttackStatus => '1.3.6.1.4.1.3417.2.3.1.1.1.1.3',
      deviceAttackStatusDefinition => {
          1 => 'no-attack',
          2 => 'under-attack',
      },
      deviceAttackTime => '1.3.6.1.4.1.3417.2.3.1.1.1.1.4',
  },
  'DISK-MIB' => {
      deviceDiskValueTable => '1.3.6.1.4.1.3417.2.2.1.1.1',
      deviceDiskValueEntry => '1.3.6.1.4.1.3417.2.2.1.1.1.1',
      deviceDiskIndex => '1.3.6.1.4.1.3417.2.2.1.1.1.1.1',
      deviceDiskTrapEnabled => '1.3.6.1.4.1.3417.2.2.1.1.1.1.2',
      deviceDiskStatus => '1.3.6.1.4.1.3417.2.2.1.1.1.1.3',
      deviceDiskStatusDefinition => {
      1 => 'present',
      2 => 'initializing',
      3 => 'inserted',
      4 => 'offline',
      5 => 'removed',
      6 => 'not-present',
      7 => 'empty',
      8 => 'bad',
      9 => 'unknown',
      },
      deviceDiskTimeStamp => '1.3.6.1.4.1.3417.2.2.1.1.1.1.4',
      deviceDiskVendor => '1.3.6.1.4.1.3417.2.2.1.1.1.1.5',
      deviceDiskProduct => '1.3.6.1.4.1.3417.2.2.1.1.1.1.6',
      deviceDiskRevision => '1.3.6.1.4.1.3417.2.2.1.1.1.1.7',
      deviceDiskSerialN => '1.3.6.1.4.1.3417.2.2.1.1.1.1.8',
      deviceDiskBlockSize => '1.3.6.1.4.1.3417.2.2.1.1.1.1.9',
      deviceDiskBlockCount => '1.3.6.1.4.1.3417.2.2.1.1.1.1.10',
  },
  'SENSOR-MIB' => {
      deviceSensorValueTable => '1.3.6.1.4.1.3417.2.1.1.1.1',
      deviceSensorValueEntry => '1.3.6.1.4.1.3417.2.1.1.1.1.1',
      deviceSensorIndex => '1.3.6.1.4.1.3417.2.1.1.1.1.1.1',
      deviceSensorTrapEnabled => '1.3.6.1.4.1.3417.2.1.1.1.1.1.2',
      deviceSensorUnits => '1.3.6.1.4.1.3417.2.1.1.1.1.1.3',
      deviceSensorUnitsDefinition => {
      1 => 'other',
      2 => 'truthvalue',
      3 => 'specialEnum',
      4 => 'volts',
      5 => 'celsius',
      6 => 'rpm',
      },
      deviceSensorScale => '1.3.6.1.4.1.3417.2.1.1.1.1.1.4',
      deviceSensorValue => '1.3.6.1.4.1.3417.2.1.1.1.1.1.5',
      deviceSensorCode => '1.3.6.1.4.1.3417.2.1.1.1.1.1.6',
      deviceSensorCodeDefinition => {
      1 => 'ok',
      2 => 'unknown',
      3 => 'not-installed',
      4 => 'voltage-low-warning',
      5 => 'voltage-low-critical',
      6 => 'no-power',
      7 => 'voltage-high-warning',
      8 => 'voltage-high-critical',
      9 => 'voltage-high-severe',
      10 => 'temperature-high-warning',
      11 => 'temperature-high-critical',
      12 => 'temperature-high-severe',
      13 => 'fan-slow-warning',
      14 => 'fan-slow-critical',
      15 => 'fan-stopped',
      },
      deviceSensorStatus => '1.3.6.1.4.1.3417.2.1.1.1.1.1.7',
      deviceSensorStatusDefinition => {
      1 => 'ok',
      2 => 'unavailable',
      3 => 'nonoperational',
      },
      deviceSensorTimeStamp => '1.3.6.1.4.1.3417.2.1.1.1.1.1.8',
      deviceSensorName => '1.3.6.1.4.1.3417.2.1.1.1.1.1.9',
  },
  'SYSTEM-RESOURCES-MIB' => {
      cpuIndex => '1.3.6.1.4.1.3417.2.8.1.1.0',
      cpuName => '1.3.6.1.4.1.3417.2.8.1.2.0',
      cpuUtilizationValue => '1.3.6.1.4.1.3417.2.8.1.3.0',
      cpuWarningThreshold => '1.3.6.1.4.1.3417.2.8.1.4.0',
      cpuWarningInterval => '1.3.6.1.4.1.3417.2.8.1.5.0',
      cpuCriticalThreshold => '1.3.6.1.4.1.3417.2.8.1.6.0',
      cpuCriticalInterval => '1.3.6.1.4.1.3417.2.8.1.7.0',
      cpuNotificationType => '1.3.6.1.4.1.3417.2.8.1.8.0',
      cpuCurrentState => '1.3.6.1.4.1.3417.2.8.1.9.0',
      cpuPreviousState => '1.3.6.1.4.1.3417.2.8.1.10.0',
      cpuLastChangeTime => '1.3.6.1.4.1.3417.2.8.1.11.0',
      cpuEvent => '1.3.6.1.4.1.3417.2.8.1.12',
      cpuTrap => '1.3.6.1.4.1.3417.2.8.1.12.1',
      memory => '1.3.6.1.4.1.3417.2.8.2',
      memIndex => '1.3.6.1.4.1.3417.2.8.2.1.0',
      memName => '1.3.6.1.4.1.3417.2.8.2.2.0',
      memPressureValue => '1.3.6.1.4.1.3417.2.8.2.3.0',
      memWarningThreshold => '1.3.6.1.4.1.3417.2.8.2.4.0',
      memWarningInterval => '1.3.6.1.4.1.3417.2.8.2.5.0',
      memCriticalThreshold => '1.3.6.1.4.1.3417.2.8.2.6.0',
      memCriticalInterval => '1.3.6.1.4.1.3417.2.8.2.7.0',
      memNotificationType => '1.3.6.1.4.1.3417.2.8.2.8.0',
      memCurrentState => '1.3.6.1.4.1.3417.2.8.2.9.0',
      memPreviousState => '1.3.6.1.4.1.3417.2.8.2.10.0',
      memLastChangeTime => '1.3.6.1.4.1.3417.2.8.2.11.0',
      memEvent => '1.3.6.1.4.1.3417.2.8.2.12',
      memTrap => '1.3.6.1.4.1.3417.2.8.2.12.1',
      network => '1.3.6.1.4.1.3417.2.8.3',
      netTable => '1.3.6.1.4.1.3417.2.8.3.1',
      netEntry => '1.3.6.1.4.1.3417.2.8.3.1.1',
      netIndex => '1.3.6.1.4.1.3417.2.8.3.1.1.1',
      netName => '1.3.6.1.4.1.3417.2.8.3.1.1.2',
      netUtilizationValue => '1.3.6.1.4.1.3417.2.8.3.1.1.3',
      netWarningThreshold => '1.3.6.1.4.1.3417.2.8.3.1.1.4',
      netWarningInterval => '1.3.6.1.4.1.3417.2.8.3.1.1.5',
      netCriticalThreshold => '1.3.6.1.4.1.3417.2.8.3.1.1.6',
      netCriticalInterval => '1.3.6.1.4.1.3417.2.8.3.1.1.7',
      netNotificationType => '1.3.6.1.4.1.3417.2.8.3.1.1.8',
      netCurrentState => '1.3.6.1.4.1.3417.2.8.3.1.1.9',
      netPreviousState => '1.3.6.1.4.1.3417.2.8.3.1.1.10',
      netLastChangeTime => '1.3.6.1.4.1.3417.2.8.3.1.1.11',
  },
  'USAGE-MIB' => {
      deviceUsageTable => '1.3.6.1.4.1.3417.2.4.1.1',
      deviceUsageEntry => '1.3.6.1.4.1.3417.2.4.1.1.1',
      deviceUsageIndex => '1.3.6.1.4.1.3417.2.4.1.1.1.1',
      deviceUsageTrapEnabled => '1.3.6.1.4.1.3417.2.4.1.1.1.2',
      deviceUsageName => '1.3.6.1.4.1.3417.2.4.1.1.1.3',
      deviceUsagePercent => '1.3.6.1.4.1.3417.2.4.1.1.1.4',
      deviceUsageHigh => '1.3.6.1.4.1.3417.2.4.1.1.1.5',
      deviceUsageStatus => '1.3.6.1.4.1.3417.2.4.1.1.1.6',
      deviceUsageStatusDefinition => {
          1 => 'ok',
          2 => 'high',
      },
      deviceUsageTime => '1.3.6.1.4.1.3417.2.4.1.1.1.7',
  },
  'BLUECOAT-SG-PROXY-MIB' => {
      sgProxyMemAvailable => '1.3.6.1.4.1.3417.2.11.2.3.1.0',
      sgProxyMemCacheUsage => '1.3.6.1.4.1.3417.2.11.2.3.2.0',
      sgProxyMemSysUsage => '1.3.6.1.4.1.3417.2.11.2.3.3.0',
      sgProxyMemPressure => '1.3.6.1.4.1.3417.2.11.2.3.4.0',
      sgProxyCpuCoreTable => '1.3.6.1.4.1.3417.2.11.2.4',
      sgProxyCpuCoreEntry => '1.3.6.1.4.1.3417.2.11.2.4.1',
      sgProxyCpuCoreIndex => '1.3.6.1.4.1.3417.2.11.2.4.1.1',
      sgProxyCpuCoreUpTime => '1.3.6.1.4.1.3417.2.11.2.4.1.2',
      sgProxyCpuCoreBusyTime => '1.3.6.1.4.1.3417.2.11.2.4.1.3',
      sgProxyCpuCoreIdleTime => '1.3.6.1.4.1.3417.2.11.2.4.1.4',
      sgProxyCpuCoreUpTimeSinceLastAccess => '1.3.6.1.4.1.3417.2.11.2.4.1.5',
      sgProxyCpuCoreBusyTimeSinceLastAccess => '1.3.6.1.4.1.3417.2.11.2.4.1.6',
      sgProxyCpuCoreIdleTimeSinceLastAccess => '1.3.6.1.4.1.3417.2.11.2.4.1.7',
      sgProxyCpuCoreBusyPerCent => '1.3.6.1.4.1.3417.2.11.2.4.1.8',
      sgProxyCpuCoreIdlePerCent => '1.3.6.1.4.1.3417.2.11.2.4.1.9',
  },
  'PROXY-MIB' => {
      proxyMemUsage => '1.3.6.1.3.25.17.1.1.0',
      proxyStorage => '1.3.6.1.3.25.17.1.2.0',
      proxyCpuUsage => '1.3.6.1.3.25.17.1.3.0',
      proxyUpTime => '1.3.6.1.3.25.17.1.4.0',
      proxyConfig => '1.3.6.1.3.25.17.2',
      proxyAdmin => '1.3.6.1.3.25.17.2.1.0',
      proxySoftware => '1.3.6.1.3.25.17.2.2.0',
      proxyVersion => '1.3.6.1.3.25.17.2.3.0',
      proxySysPerf => '1.3.6.1.3.25.17.3.1',
      proxyProtoPerf => '1.3.6.1.3.25.17.3.2',
      proxySysPerf => '1.3.6.1.3.25.17.3.1',
      proxyCpuLoad => '1.3.6.1.3.25.17.3.1.1.0',
      proxyNumObjects => '1.3.6.1.3.25.17.3.1.2.0',
  },
  'RESOURCE-MIB' => {
      cpuIndex => '1.3.6.1.4.1.3417.2.8.1.1.0',
      cpuName => '1.3.6.1.4.1.3417.2.8.1.2.0',
      cpuUtilizationValue => '1.3.6.1.4.1.3417.2.8.1.3.0',
      cpuWarningThreshold => '1.3.6.1.4.1.3417.2.8.1.4.0',
      cpuWarningInterval => '1.3.6.1.4.1.3417.2.8.1.5.0',
      cpuCriticalThreshold => '1.3.6.1.4.1.3417.2.8.1.6.0',
      cpuCriticalInterval => '1.3.6.1.4.1.3417.2.8.1.7.0',
      cpuNotificationType => '1.3.6.1.4.1.3417.2.8.1.8.0',
      cpuCurrentState => '1.3.6.1.4.1.3417.2.8.1.9.0',
      cpuPreviousState => '1.3.6.1.4.1.3417.2.8.1.10.0',
      cpuLastChangeTime => '1.3.6.1.4.1.3417.2.8.1.11.0',
      cpuEvent => '1.3.6.1.4.1.3417.2.8.1.12',
      cpuTrap => '1.3.6.1.4.1.3417.2.8.1.12.1',
      memory => '1.3.6.1.4.1.3417.2.8.2',
      memIndex => '1.3.6.1.4.1.3417.2.8.2.1.0',
      memName => '1.3.6.1.4.1.3417.2.8.2.2.0',
      memPressureValue => '1.3.6.1.4.1.3417.2.8.2.3.0',
      memWarningThreshold => '1.3.6.1.4.1.3417.2.8.2.4.0',
      memWarningInterval => '1.3.6.1.4.1.3417.2.8.2.5.0',
      memCriticalThreshold => '1.3.6.1.4.1.3417.2.8.2.6.0',
      memCriticalInterval => '1.3.6.1.4.1.3417.2.8.2.7.0',
      memNotificationType => '1.3.6.1.4.1.3417.2.8.2.8.0',
      memCurrentState => '1.3.6.1.4.1.3417.2.8.2.9.0',
      memPreviousState => '1.3.6.1.4.1.3417.2.8.2.10.0',
      memLastChangeTime => '1.3.6.1.4.1.3417.2.8.2.11.0',
      memEvent => '1.3.6.1.4.1.3417.2.8.2.12',
      memTrap => '1.3.6.1.4.1.3417.2.8.2.12.1',
      network => '1.3.6.1.4.1.3417.2.8.3',
      netTable => '1.3.6.1.4.1.3417.2.8.3.1',
      netEntry => '1.3.6.1.4.1.3417.2.8.3.1.1',
      netIndex => '1.3.6.1.4.1.3417.2.8.3.1.1.1',
      netName => '1.3.6.1.4.1.3417.2.8.3.1.1.2',
      netUtilizationValue => '1.3.6.1.4.1.3417.2.8.3.1.1.3',
      netWarningThreshold => '1.3.6.1.4.1.3417.2.8.3.1.1.4',
      netWarningInterval => '1.3.6.1.4.1.3417.2.8.3.1.1.5',
      netCriticalThreshold => '1.3.6.1.4.1.3417.2.8.3.1.1.6',
      netCriticalInterval => '1.3.6.1.4.1.3417.2.8.3.1.1.7',
      netNotificationType => '1.3.6.1.4.1.3417.2.8.3.1.1.8',
      netCurrentState => '1.3.6.1.4.1.3417.2.8.3.1.1.9',
      netPreviousState => '1.3.6.1.4.1.3417.2.8.3.1.1.10',
      netLastChangeTime => '1.3.6.1.4.1.3417.2.8.3.1.1.11',
  },
  'BLUECOAT-AV-MIB' => {
      avEngineVersion => '1.3.6.1.4.1.3417.2.10.1.5.0',
      avErrorCode => '1.3.6.1.4.1.3417.2.10.2.5.0',
      avErrorDetails => '1.3.6.1.4.1.3417.2.10.2.6.0',
      avFilesScanned => '1.3.6.1.4.1.3417.2.10.1.1.0',
      avICTMWarningReason => '1.3.6.1.4.1.3417.2.10.2.8.0',
      avInstalledFirmwareVersion => '1.3.6.1.4.1.3417.2.10.1.9.0',
      avLicenseDaysRemaining => '1.3.6.1.4.1.3417.2.10.1.7.0',
      avPatternDateTime => '1.3.6.1.4.1.3417.2.10.1.4.0',
      avPatternVersion => '1.3.6.1.4.1.3417.2.10.1.3.0',
      avPreviousFirmwareVersion => '1.3.6.1.4.1.3417.2.10.2.7.0',
      avPublishedFirmwareVersion => '1.3.6.1.4.1.3417.2.10.1.8.0',
      avSlowICAPConnections => '1.3.6.1.4.1.3417.2.10.1.10.0',
      avUpdateFailureReason => '1.3.6.1.4.1.3417.2.10.2.1.0',
      avUrl => '1.3.6.1.4.1.3417.2.10.2.2.0',
      avVendorName => '1.3.6.1.4.1.3417.2.10.1.6.0',
      avVirusDetails => '1.3.6.1.4.1.3417.2.10.2.4.0',
      avVirusesDetected => '1.3.6.1.4.1.3417.2.10.1.2.0',
      avVirusName => '1.3.6.1.4.1.3417.2.10.2.3.0',
  },
  'FOUNDRY-SN-AGENT-MIB' => {
      snAgGblCpuUtil1SecAvg => '1.3.6.1.4.1.1991.1.1.2.1.50.0',
      snAgGblCpuUtil5SecAvg => '1.3.6.1.4.1.1991.1.1.2.1.51.0',
      snAgGblCpuUtil1MinAvg => '1.3.6.1.4.1.1991.1.1.2.1.52.0',
      snAgGblDynMemUtil => '1.3.6.1.4.1.1991.1.1.2.1.53.0',
      snAgGblDynMemTotal => '1.3.6.1.4.1.1991.1.1.2.1.54.0',
      snAgGblDynMemFree => '1.3.6.1.4.1.1991.1.1.2.1.55.0',

      snAgentCpuUtilTable => '1.3.6.1.4.1.1991.1.1.2.11.1',
      snAgentCpuUtilEntry => '1.3.6.1.4.1.1991.1.1.2.11.1.1',
      snAgentCpuUtilSlotNum => '1.3.6.1.4.1.1991.1.1.2.11.1.1.1',
      snAgentCpuUtilCpuId => '1.3.6.1.4.1.1991.1.1.2.11.1.1.2',
      snAgentCpuUtilInterval => '1.3.6.1.4.1.1991.1.1.2.11.1.1.3',
      snAgentCpuUtilValue => '1.3.6.1.4.1.1991.1.1.2.11.1.1.4',
      snAgentCpuUtilPercent => '1.3.6.1.4.1.1991.1.1.2.11.1.1.5',
      snAgentCpuUtil100thPercent => '1.3.6.1.4.1.1991.1.1.2.11.1.1.6',

      snChasPwrSupplyTable => '1.3.6.1.4.1.1991.1.1.1.2.1',
      snChasPwrSupplyEntry => '1.3.6.1.4.1.1991.1.1.1.2.1.1',
      snChasPwrSupplyIndex => '1.3.6.1.4.1.1991.1.1.1.2.1.1.1',
      snChasPwrSupplyDescription => '1.3.6.1.4.1.1991.1.1.1.2.1.1.2',
      snChasPwrSupplyOperStatus => '1.3.6.1.4.1.1991.1.1.1.2.1.1.3',
      snChasPwrSupplyOperStatusDefinition => {
          1 => 'other',
          2 => 'normal',
          3 => 'failure',
      },
      snChasFan => '1.3.6.1.4.1.1991.1.1.1.3',
      snChasFanTable => '1.3.6.1.4.1.1991.1.1.1.3.1',
      snChasFanEntry => '1.3.6.1.4.1.1991.1.1.1.3.1.1',
      snChasFanIndex => '1.3.6.1.4.1.1991.1.1.1.3.1.1.1',
      snChasFanDescription => '1.3.6.1.4.1.1991.1.1.1.3.1.1.2',
      snChasFanOperStatus => '1.3.6.1.4.1.1991.1.1.1.3.1.1.3',
      snChasFanOperStatusDefinition => {
          1 => 'other',
          2 => 'normal',
          3 => 'failure',
      },
      snAgentTempTable => '1.3.6.1.4.1.1991.1.1.2.13.1',
      snAgentTempEntry => '1.3.6.1.4.1.1991.1.1.2.13.1.1',
      snAgentTempSlotNum => '1.3.6.1.4.1.1991.1.1.2.13.1.1.1',
      # sensor 1 - intake temperature, sensor 2 - exhaust-side temperature
      snAgentTempSensorId => '1.3.6.1.4.1.1991.1.1.2.13.1.1.2',
      snAgentTempSensorDescr => '1.3.6.1.4.1.1991.1.1.2.13.1.1.3',
      # This value is displayed in units of 0.5 Celsius. Valid: 110 - 250
      snAgentTempValue => '1.3.6.1.4.1.1991.1.1.2.13.1.1.4',
  },
  'JUNIPER-IVE-MIB' => {
      logFullPercent => '1.3.6.1.4.1.12532.1.0',
      signedInWebUsers => '1.3.6.1.4.1.12532.2.0',
      signedInMailUsers => '1.3.6.1.4.1.12532.3.0',
      blockedIP => '1.3.6.1.4.1.12532.4.0',
      authServerName => '1.3.6.1.4.1.12532.5.0',
      productName => '1.3.6.1.4.1.12532.6.0',
      productVersion => '1.3.6.1.4.1.12532.7.0',
      fileName => '1.3.6.1.4.1.12532.8.0',
      meetingUserCount => '1.3.6.1.4.1.12532.9.0',
      iveCpuUtil => '1.3.6.1.4.1.12532.10.0',
      iveMemoryUtil => '1.3.6.1.4.1.12532.11.0',
      iveConcurrentUsers => '1.3.6.1.4.1.12532.12.0',
      clusterConcurrentUsers => '1.3.6.1.4.1.12532.13.0',
      iveTotalHits => '1.3.6.1.4.1.12532.14.0',
      iveFileHits => '1.3.6.1.4.1.12532.15.0',
      iveWebHits => '1.3.6.1.4.1.12532.16.0',
      iveAppletHits => '1.3.6.1.4.1.12532.17.0',
      ivetermHits => '1.3.6.1.4.1.12532.18.0',
      iveSAMHits => '1.3.6.1.4.1.12532.19.0',
      iveNCHits => '1.3.6.1.4.1.12532.20.0',
      meetingHits => '1.3.6.1.4.1.12532.21.0',
      meetingCount => '1.3.6.1.4.1.12532.22.0',
      logName => '1.3.6.1.4.1.12532.23.0',
      iveSwapUtil => '1.3.6.1.4.1.12532.24.0',
      diskFullPercent => '1.3.6.1.4.1.12532.25.0',
      logID => '1.3.6.1.4.1.12532.27.0',
      logType => '1.3.6.1.4.1.12532.28.0',
      logDescription => '1.3.6.1.4.1.12532.29.0',
      ivsName => '1.3.6.1.4.1.12532.30.0',
      ocspResponderURL => '1.3.6.1.4.1.12532.31.0',
      fanDescription => '1.3.6.1.4.1.12532.32.0',
      psDescription => '1.3.6.1.4.1.12532.33.0',
      raidDescription => '1.3.6.1.4.1.12532.34.0',
      clusterName => '1.3.6.1.4.1.12532.35.0',
      nodeList => '1.3.6.1.4.1.12532.36.0',
      vipType => '1.3.6.1.4.1.12532.37.0',
      currentVIP => '1.3.6.1.4.1.12532.38.0',
      newVIP => '1.3.6.1.4.1.12532.39.0',
      nicEvent => '1.3.6.1.4.1.12532.40.0',
      nodeName => '1.3.6.1.4.1.12532.41.0',
      iveTemperature => '1.3.6.1.4.1.12532.42.0',
  },
};

$NWC::Device::definitions = {
  'CISCO-ENVMON-MIB' => {
     ciscoEnvMonState => {
       1 => 'normal',
       2 => 'warning',
       3 => 'critical',
       4 => 'shutdown',
       5 => 'notPresent',
       6 => 'notFunctioning',
     },
  },
  'CISCO-HSRP-MIB' => {
      HsrpState => {
        1 => 'initial',
        2 => 'learn',
        3 => 'listen',
        4 => 'speak',
        5 => 'standby',
        6 => 'active',
      },
  },
  'SNMPv2-TC-v1' => {
      'TruthValue' => {
        1 => 'true',
        2 => 'false',
      },
      'RowStatus' => {
        1 => 'active',
        2 => 'notInService',
        3 => 'notReady',
        4 => 'createAndGo',
        5 => 'createAndWait',
        6 => 'destroy',
      },
  },
  'CISCO-ENTITY-SENSOR-MIB' => {
      'SensorDataType' => {
        1 => 'other',
        2 => 'unknown',
        3 => 'voltsAC',
        4 => 'voltsDC',
        5 => 'amperes',
        6 => 'watts',
        7 => 'hertz',
        8 => 'celsius',
        9 => 'percentRH',
        10 => 'rpm',
        11 => 'cmm',
        12 => 'truthvalue',
        13 => 'specialEnum',
        14 => 'dBm',
      },
      'SensorStatus' => {
        1 => 'ok',
        2 => 'unavailable',
        3 => 'nonoperational',
      },
      'SensorDataScale' => {
        1 => 'yocto',
        2 => 'zepto',
        3 => 'atto',
        4 => 'femto',
        5 => 'pico',
        6 => 'nano',
        7 => 'micro',
        8 => 'milli',
        9 => 'units',
        10 => 'kilo',
        11 => 'mega',
        12 => 'giga',
        13 => 'tera',
        14 => 'exa',
        15 => 'peta',
        16 => 'zetta',
        17 => 'yotta',
      },
      'SensorThresholdSeverity' => {
        1 => 'other',
        10 => 'minor',
        20 => 'major',
        30 => 'critical',
      },
      'SensorThresholdRelation' => {
        1 => 'lessThan',
        2 => 'lessOrEqual',
        3 => 'greaterThan',
        4 => 'greaterOrEqual',
        5 => 'equalTo',
        6 => 'notEqualTo',
      },
  },
  'CISCO-L2L3-INTERFACE-CONFIG-MIB' => {
      'CL2L3InterfaceMode' => {
        1 => 'routed',
        2 => 'switchport',
      },
  },
  'CISCO-FIREWALL-MIB' => {
    'Services' => {
      1 => 'otherFWService',
      2 => 'fileXferFtp',
      3 => 'fileXferTftp',
      4 => 'fileXferFtps',
      5 => 'loginTelnet',
      6 => 'loginRlogin',
      7 => 'loginTelnets',
      8 => 'remoteExecSunRPC',
      9 => 'remoteExecMSRPC',
      10 => 'remoteExecRsh',
      11 => 'remoteExecXserver',
      12 => 'webHttp',
      13 => 'webHttps',
      14 => 'mailSmtp',
      15 => 'multimediaStreamworks',
      16 => 'multimediaH323',
      17 => 'multimediaNetShow',
      18 => 'multimediaVDOLive',
      19 => 'multimediaRealAV',
      20 => 'multimediaRTSP',
      21 => 'dbOracle',
      22 => 'dbMSsql',
      23 => 'contInspProgLang',
      24 => 'contInspUrl',
      25 => 'directoryNis',
      26 => 'directoryDns',
      27 => 'directoryNetbiosns',
      28 => 'directoryNetbiosdgm',
      29 => 'directoryNetbiosssn',
      30 => 'directoryWins',
      31 => 'qryWhois',
      32 => 'qryFinger',
      33 => 'qryIdent',
      34 => 'fsNfsStatus',
      35 => 'fsNfs',
      36 => 'fsCifs',
      37 => 'protoIcmp',
      38 => 'protoTcp',
      39 => 'protoUdp',
      40 => 'protoIp',
      41 => 'protoSnmp',
    },
  },
  'F5-BIGIP-LOCAL-MIB' => {
    ltmPoolLbMode => {
      0 => 'roundRobin',
      1 => 'ratioMember',
      2 => 'leastConnMember',
      3 => 'observedMember',
      4 => 'predictiveMember',
      5 => 'ratioNodeAddress',
      6 => 'leastConnNodeAddress',
      7 => 'fastestNodeAddress',
      8 => 'observedNodeAddress',
      9 => 'predictiveNodeAddress',
      10 => 'dynamicRatio',
      11 => 'fastestAppResponse',
      12 => 'leastSessions',
      13 => 'dynamicRatioMember',
      14 => 'l3Addr',
      15 => 'weightedLeastConnMember',
      16 => 'weightedLeastConnNodeAddr',
      17 => 'ratioSession',
    },
    ltmPoolAvailabilityState => {
      0 => 'none',
      1 => 'green',
      2 => 'yellow',
      3 => 'red',
      4 => 'blue',
    },
    ltmPoolMemberMonitorState => {
      0 => 'unchecked',
      1 => 'checking',
      2 => 'inband',
      3 => 'forced-up',
      4 => 'up',
      19 => 'down',
      20 => 'forced-down',
      22 => 'irule-down',
      23 => 'inband-down',
      24 => 'down-manual-resume',
      25 => 'disabled',
    },
    ltmPoolMemberMonitorStatus => {
      0 => 'unchecked',
      1 => 'checking',
      2 => 'inband',
      3 => 'forced-up',
      4 => 'up',
      18 => 'addr-down',
      19 => 'down',
      20 => 'forced-down',
      21 => 'maint',
      22 => 'irule-down',
      23 => 'inband-down',
      24 => 'down-manual-resume',
    },
    ltmPoolMemberEnabledState => {
      0 => 'none',
      1 => 'enabled',
      2 => 'disabled',
      3 => 'disabledbyparent',
    },
    ltmPoolStatusAvailState => {
      0 => 'none',
      1 => 'green',
      2 => 'yellow',
      3 => 'red',
      4 => 'blue',
      5 => 'grey',
    },
    ltmPoolStatusEnabledState =>  {
      0 => 'none',
      1 => 'enabled',
      2 => 'disabled',
      3 => 'disabledbyparent',
    },
    ltmPoolMbrStatusAvailState => {
      0 => 'none',
      1 => 'green',
      2 => 'yellow',
      3 => 'red',
      4 => 'blue',
      5 => 'gray',
    },
    ltmPoolMbrStatusEnabledState => {
      0 => 'none',
      1 => 'enabled',
      2 => 'disabled',
      3 => 'disabledbyparent',
    },
    ltmPoolMemberMonitorState => {
      0 => 'unchecked',
      1 => 'checking',
      2 => 'inband',
      3 => 'forced-up',
      4 => 'up',
      19 => 'down',
      20 => 'forced-down',
      22 => 'irule-down',
      23 => 'inband-down',
      24 => 'down-manual-resume',
      25 => 'disabled',
    },
    ltmPoolMemberMonitorStatus => {
      0 => 'unchecked',
      1 => 'checking',
      2 => 'inband',
      3 => 'forced-up',
      4 => 'up',
      18 => 'addr-down',
      19 => 'down',
      20 => 'forced-down',
      21 => 'maint',
      22 => 'irule-down',
      23 => 'inband-down',
      24 => 'down-manual-resume',
    },
  },
  'IFMIB' => {
    ifType => {
      1 => 'other',
      2 => 'regular1822',
      3 => 'hdh1822',
      4 => 'ddnX25',
      5 => 'rfc877x25',
      6 => 'ethernetCsmacd',
      7 => 'iso88023Csmacd',
      8 => 'iso88024TokenBus',
      9 => 'iso88025TokenRing',
      10 => 'iso88026Man',
      11 => 'starLan',
      12 => 'proteon10Mbit',
      13 => 'proteon80Mbit',
      14 => 'hyperchannel',
      15 => 'fddi',
      16 => 'lapb',
      17 => 'sdlc',
      18 => 'ds1',
      19 => 'e1',
      20 => 'basicISDN',
      21 => 'primaryISDN',
      22 => 'propPointToPointSerial',
      23 => 'ppp',
      24 => 'softwareLoopback',
      25 => 'eon',
      26 => 'ethernet3Mbit',
      27 => 'nsip',
      28 => 'slip',
      29 => 'ultra',
      30 => 'ds3',
      31 => 'sip',
      32 => 'frameRelay',
      33 => 'rs232',
      34 => 'para',
      35 => 'arcnet',
      36 => 'arcnetPlus',
      37 => 'atm',
      38 => 'miox25',
      39 => 'sonet',
      40 => 'x25ple',
      41 => 'iso88022llc',
      42 => 'localTalk',
      43 => 'smdsDxi',
      44 => 'frameRelayService',
      45 => 'v35',
      46 => 'hssi',
      47 => 'hippi',
      48 => 'modem',
      49 => 'aal5',
      50 => 'sonetPath',
      51 => 'sonetVT',
      52 => 'smdsIcip',
      53 => 'propVirtual',
      54 => 'propMultiplexor',
      55 => 'ieee80212',
      56 => 'fibreChannel',
      57 => 'hippiInterface',
      58 => 'frameRelayInterconnect',
      59 => 'aflane8023',
      60 => 'aflane8025',
      61 => 'cctEmul',
      62 => 'fastEther',
      63 => 'isdn',
      64 => 'v11',
      65 => 'v36',
      66 => 'g703at64k',
      67 => 'g703at2mb',
      68 => 'qllc',
      69 => 'fastEtherFX',
      70 => 'channel',
      71 => 'ieee80211',
      72 => 'ibm370parChan',
      73 => 'escon',
      74 => 'dlsw',
      75 => 'isdns',
      76 => 'isdnu',
      77 => 'lapd',
      78 => 'ipSwitch',
      79 => 'rsrb',
      80 => 'atmLogical',
      81 => 'ds0',
      82 => 'ds0Bundle',
      83 => 'bsc',
      84 => 'async',
      85 => 'cnr',
      86 => 'iso88025Dtr',
      87 => 'eplrs',
      88 => 'arap',
      89 => 'propCnls',
      90 => 'hostPad',
      91 => 'termPad',
      92 => 'frameRelayMPI',
      93 => 'x213',
      94 => 'adsl',
      95 => 'radsl',
      96 => 'sdsl',
      97 => 'vdsl',
      98 => 'iso88025CRFPInt',
      99 => 'myrinet',
      100 => 'voiceEM',
      101 => 'voiceFXO',
      102 => 'voiceFXS',
      103 => 'voiceEncap',
      104 => 'voiceOverIp',
      105 => 'atmDxi',
      106 => 'atmFuni',
      107 => 'atmIma',
      108 => 'pppMultilinkBundle',
      109 => 'ipOverCdlc',
      110 => 'ipOverClaw',
      111 => 'stackToStack',
      112 => 'virtualIpAddress',
      113 => 'mpc',
      114 => 'ipOverAtm',
      115 => 'iso88025Fiber',
      116 => 'tdlc',
      117 => 'gigabitEthernet',
      118 => 'hdlc',
      119 => 'lapf',
      120 => 'v37',
      121 => 'x25mlp',
      122 => 'x25huntGroup',
      123 => 'transpHdlc',
      124 => 'interleave',
      125 => 'fast',
      126 => 'ip',
      127 => 'docsCableMaclayer',
      128 => 'docsCableDownstream',
      129 => 'docsCableUpstream',
      130 => 'a12MppSwitch',
      131 => 'tunnel',
      132 => 'coffee',
      133 => 'ces',
      134 => 'atmSubInterface',
      135 => 'l2vlan',
      136 => 'l3ipvlan',
      137 => 'l3ipxvlan',
      138 => 'digitalPowerline',
      139 => 'mediaMailOverIp',
      140 => 'dtm',
      141 => 'dcn',
      142 => 'ipForward',
      143 => 'msdsl',
      144 => 'ieee1394',
      145 => 'if-gsn',
      146 => 'dvbRccMacLayer',
      147 => 'dvbRccDownstream',
      148 => 'dvbRccUpstream',
      149 => 'atmVirtual',
      150 => 'mplsTunnel',
      151 => 'srp',
      152 => 'voiceOverAtm',
      153 => 'voiceOverFrameRelay',
      154 => 'idsl',
      155 => 'compositeLink',
      156 => 'ss7SigLink',
      157 => 'propWirelessP2P',
      158 => 'frForward',
      159 => 'rfc1483',
      160 => 'usb',
      161 => 'ieee8023adLag',
      162 => 'bgppolicyaccounting',
      163 => 'frf16MfrBundle',
      164 => 'h323Gatekeeper',
      165 => 'h323Proxy',
      166 => 'mpls',
      167 => 'mfSigLink',
      168 => 'hdsl2',
      169 => 'shdsl',
      170 => 'ds1FDL',
      171 => 'pos',
      172 => 'dvbAsiIn',
      173 => 'dvbAsiOut',
      174 => 'plc',
      175 => 'nfas',
      176 => 'tr008',
      177 => 'gr303RDT',
      178 => 'gr303IDT',
      179 => 'isup',
      180 => 'propDocsWirelessMaclayer',
      181 => 'propDocsWirelessDownstream',
      182 => 'propDocsWirelessUpstream',
      183 => 'hiperlan2',
      184 => 'propBWAp2Mp',
      185 => 'sonetOverheadChannel',
      186 => 'digitalWrapperOverheadChannel',
      187 => 'aal2',
      188 => 'radioMAC',
      189 => 'atmRadio',
      190 => 'imt',
      191 => 'mvl',
      192 => 'reachDSL',
      193 => 'frDlciEndPt',
      194 => 'atmVciEndPt',
      195 => 'opticalChannel',
      196 => 'opticalTransport',
      197 => 'propAtm',
      198 => 'voiceOverCable',
      199 => 'infiniband',
      200 => 'teLink',
      201 => 'q2931',
      202 => 'virtualTg',
      203 => 'sipTg',
      204 => 'sipSig',
      205 => 'docsCableUpstreamChannel',
      206 => 'econet',
      207 => 'pon155',
      208 => 'pon622',
      209 => 'bridge',
      210 => 'linegroup',
      211 => 'voiceEMFGD',
      212 => 'voiceFGDEANA',
      213 => 'voiceDID',
      214 => 'mpegTransport',
      215 => 'sixToFour',
      216 => 'gtp',
      217 => 'pdnEtherLoop1',
      218 => 'pdnEtherLoop2',
      219 => 'opticalChannelGroup',
      220 => 'homepna',
      221 => 'gfp',
      222 => 'ciscoISLvlan',
      223 => 'actelisMetaLOOP',
      224 => 'fcipLink',
      225 => 'rpr',
      226 => 'qam',
      227 => 'lmp',
      228 => 'cblVectaStar',
      229 => 'docsCableMCmtsDownstream',
      230 => 'adsl2',
      231 => 'macSecControlledIF',
      232 => 'macSecUncontrolledIF',
      233 => 'aviciOpticalEther',
      234 => 'atmbond',
      235 => 'voiceFGDOS',
      236 => 'mocaVersion1',
      237 => 'ieee80216WMAN',
      238 => 'adsl2plus',
      239 => 'dvbRcsMacLayer',
      240 => 'dvbTdm',
      241 => 'dvbRcsTdma',
      242 => 'x86Laps',
      243 => 'wwanPP',
      244 => 'wwanPP2',
      245 => 'voiceEBS',
      246 => 'ifPwType',
      247 => 'ilan',
      248 => 'pip',
      249 => 'aluELP',
      250 => 'gpon',
      251 => 'vdsl2',
      252 => 'capwapDot11Profile',
      253 => 'capwapDot11Bss',
      254 => 'capwapWtpVirtualRadio',
      255 => 'bits',
      256 => 'docsCableUpstreamRfPort',
      257 => 'cableDownstreamRfPort',
      258 => 'vmwareVirtualNic',
      259 => 'ieee802154',
      260 => 'otnOdu',
      261 => 'otnOtu',
      262 => 'ifVfiType',
      263 => 'g9981',
      264 => 'g9982',
      265 => 'g9983',
      266 => 'aluEpon',
      267 => 'aluEponOnu',
      268 => 'aluEponPhysicalUni',
      269 => 'aluEponLogicalLink',
      270 => 'aluGponOnu',
      271 => 'aluGponPhysicalUni',
      272 => 'vmwareNicTeam',
      # 273 ... http://tools.ietf.org/html/rfc6825
    },
  },
};

package NWC::Generic;

use strict;

use constant { OK => 0, WARNING => 1, CRITICAL => 2, UNKNOWN => 3 };

our @ISA = qw(NWC::Device);


package NWC::Device;

use strict;
use IO::File;
use File::Basename;
use Digest::MD5  qw(md5_hex);
use Errno;
use AutoLoader;
our $AUTOLOAD;

use constant { OK => 0, WARNING => 1, CRITICAL => 2, UNKNOWN => 3 };

{
  our $mode = undef;
  our $plugin = undef;
  our $blacklist = undef;
  our $session = undef;
  our $rawdata = {};
  our $info = [];
  our $extendedinfo = [];
  our $summary = [];
  our $statefilesdir = '/var/tmp/check_nwc_health';
  our $oidtrace = [];
  our $uptime = 0;
}

sub new {
  my $class = shift;
  my %params = @_;
  my $self = {
    productname => 'unknown',
  };
  bless $self, $class;
  if (! ($self->opts->hostname || $self->opts->snmpwalk)) {
    die "wie jetzt??!?!";
  } else {
    if ($self->opts->servertype && $self->opts->servertype eq 'linuxlocal') {
    } elsif ($self->opts->port && $self->opts->port == 49000) {
      $self->{productname} = 'upnp';
    } else {
      $self->check_snmp_and_model();
    }
    if ($self->opts->servertype) {
      $self->{productname} = 'cisco' if $self->opts->servertype eq 'cisco';
      $self->{productname} = 'huawei' if $self->opts->servertype eq 'huawei';
      $self->{productname} = 'hp' if $self->opts->servertype eq 'hp';
      $self->{productname} = 'brocade' if $self->opts->servertype eq 'brocade';
      $self->{productname} = 'netscreen' if $self->opts->servertype eq 'netscreen';
      $self->{productname} = 'linuxlocal' if $self->opts->servertype eq 'linuxlocal';
      $self->{productname} = 'procurve' if $self->opts->servertype eq 'procurve';
      $self->{productname} = 'bluecoat' if $self->opts->servertype eq 'bluecoat';
      $self->{productname} = 'checkpoint' if $self->opts->servertype eq 'checkpoint';
      $self->{productname} = 'ifmib' if $self->opts->servertype eq 'ifmib';
    }
    if (! $NWC::Device::plugin->check_messages()) {
      if ($self->opts->verbose && $self->opts->verbose) {
        printf "I am a %s\n", $self->{productname};
      }
      # Brocade 4100 SilkWorm also sold as IBM 2005-B32 & EMC DS-4100
      # Brocade 4900 Switch also sold as IBM 2005-B64(3) & EMC DS4900B
      # Brocade M4700 (McData name Sphereon 4700) also sold as IBM 2026-432 & EMC DS-4700M
      if ($self->{productname} =~ /Cisco/i) {
        bless $self, 'NWC::Cisco';
        $self->debug('using NWC::Cisco');
      } elsif ($self->{productname} =~ /Nortel/i) {
        bless $self, 'NWC::Nortel';
        $self->debug('using NWC::Nortel');
      } elsif ($self->{productname} =~ /AT-GS/i) {
        bless $self, 'NWC::AlliedTelesyn';
        $self->debug('using NWC::AlliedTelesyn');
      } elsif ($self->{productname} =~ /AT-\d+GB/i) {
        bless $self, 'NWC::AlliedTelesyn';
        $self->debug('using NWC::AlliedTelesyn');
      } elsif ($self->{productname} =~ /Allied Telesyn Ethernet Switch/i) {
        bless $self, 'NWC::AlliedTelesyn';
        $self->debug('using NWC::AlliedTelesyn');
      } elsif ($self->{productname} =~ /DS_4100/i) {
        bless $self, 'NWC::Brocade';
        $self->debug('using NWC::Brocade');
      } elsif ($self->{productname} =~ /Connectrix DS_4900B/i) {
        bless $self, 'NWC::Brocade';
        $self->debug('using NWC::Brocade');
      } elsif ($self->{productname} =~ /EMC\s*DS.*4700M/i) {
        bless $self, 'NWC::Brocade';
        $self->debug('using NWC::Brocade');
      } elsif ($self->{productname} =~ /EMC\s*DS-24M2/i) {
        bless $self, 'NWC::Brocade';
        $self->debug('using NWC::Brocade');
      } elsif ($self->{productname} =~ /Brocade.*ICX/i) {
        bless $self, 'NWC::Brocade';
        $self->debug('using NWC::Brocade');
      } elsif ($self->{productname} =~ /Fibre Channel Switch/i) {
        bless $self, 'NWC::Brocade';
        $self->debug('using NWC::Brocade');
      } elsif ($self->{productname} =~ /Juniper.*MAG\-\d+/i) {
        # Juniper Networks,Inc,MAG-4610,7.2R10
        bless $self, 'NWC::Juniper';
        $self->debug('using NWC::Juniper');
      } elsif ($self->{productname} =~ /NetScreen/i) {
        bless $self, 'NWC::Juniper';
        $self->debug('using NWC::Juniper');
      } elsif ($self->{productname} =~ /^(GS|FS)/i) {
        bless $self, 'NWC::Juniper';
        $self->debug('using NWC::Juniper');
      } elsif ($self->{productname} =~ /SecureOS/i) {
        bless $self, 'NWC::SecureOS';
        $self->debug('using NWC::SecureOS');
      } elsif ($self->{productname} =~ /Linux.*((el6.f5.x86_64)|(el5.1.0.f5app)) .*/i) {
        bless $self, 'NWC::F5';
        $self->debug('using NWC::F5');
      } elsif ($self->{productname} =~ /Procurve/i) {
        bless $self, 'NWC::HP';
        $self->debug('using NWC::HP');
      } elsif ($self->{productname} =~ /(cpx86_64)|(Check\s*Point)|(Linux.*\dcp )/i) {
        bless $self, 'NWC::CheckPoint';
        $self->debug('using NWC::CheckPoint');
      } elsif ($self->{productname} =~ /Blue\s*Coat/i) {
        bless $self, 'NWC::Bluecoat';
        $self->debug('using NWC::Bluecoat');
      } elsif ($self->{productname} =~ /linuxlocal/i) {
        bless $self, 'Server::Linux';
        $self->debug('using Server::Linux');
      } elsif ($self->{productname} =~ /upnp/i) {
        bless $self, 'UPNP';
        $self->debug('using UPNP');
      } elsif ($self->{productname} eq "ifmib") {
        bless $self, 'NWC::Generic';
        $self->debug('using NWC::Generic');
      } else {
        $self->add_message(CRITICAL,
            sprintf('unknown device%s', $self->{productname} eq 'unknown' ?
                '' : '('.$self->{productname}.')'));
      }
    }
  }
  $self->{method} = 'snmp';
  if ($self->opts->blacklist &&
      -f $self->opts->blacklist) {
    $self->opts->blacklist = do {
        local (@ARGV, $/) = $self->opts->blacklist; <> };
  }
  $NWC::Device::statefilesdir = $self->opts->statefilesdir;
  return $self;
}

sub init {
  my $self = shift;
  if ($self->mode =~ /device::walk/) {
    my @trees = ();
    my $name = $0;
    $name =~ s/.*\///g;
    $name = sprintf "/tmp/snmpwalk_%s_%s", $name, $self->opts->hostname;
    if ($self->opts->oids) {
      # create pid filename
      # already running?;x
      @trees = split(",", $self->opts->oids);

    } elsif ($self->can("trees")) {
      @trees = $self->trees;
    }
    if ($self->opts->snmpdump) {
      $name = $self->opts->snmpdump;
    }
    if (defined $self->opts->offline) {
      $self->{pidfile} = $name.".pid";
      if (! $self->check_pidfile()) {
        $self->trace("Exiting because another walk is already running");
        printf STDERR "Exiting because another walk is already running\n";
        exit 3;
      }
      $self->write_pidfile();
      my $timedout = 0;
      my $snmpwalkpid = 0;
      $SIG{'ALRM'} = sub {
        $timedout = 1;
        printf "UNKNOWN - check_nwc_health timed out after %d seconds\n",
            $self->opts->timeout;
        kill 9, $snmpwalkpid;
      };
      alarm($self->opts->timeout);
      unlink $name.".partial";
      while (! $timedout && @trees) {
        my $tree = shift @trees;
        $SIG{CHLD} = 'IGNORE';
        my $cmd = sprintf "snmpwalk -ObentU -v%s -c %s %s %s >> %s", 
            $self->opts->protocol,
            $self->opts->community,
            $self->opts->hostname,
            $tree, $name.".partial";
        $self->trace($cmd);
        $snmpwalkpid = fork;
        if (not $snmpwalkpid) {
          exec($cmd);
        } else {
          wait();
        }
      }
      rename $name.".partial", $name if ! $timedout;
      -f $self->{pidfile} && unlink $self->{pidfile};
      if ($timedout) {
        printf "CRITICAL - timeout. There are still %d snmpwalks left\n", scalar(@trees);
        exit 3;
      } else {
        printf "OK - all requested oids are in %s\n", $name;
      }
    } else {
      printf "rm -f %s\n", $name;
      foreach ($self->trees) {
        printf "snmpwalk -ObentU -v%s -c %s %s %s >> %s\n", 
            $self->opts->protocol,
            $self->opts->community,
            $self->opts->hostname,
            $_, $name;
      }
    }
    exit 0;
  } elsif ($self->mode =~ /device::uptime/) {
    $self->{uptime} /= 60;
    my $info = sprintf 'device is up since %d minutes', $self->{uptime};
    $self->add_info($info);
    $self->set_thresholds(warning => '15:', critical => '5:');
    $self->add_message($self->check_thresholds($self->{uptime}), $info);
    $self->add_perfdata(
        label => 'uptime',
        value => $self->{uptime},
        warning => $self->{warning},
        critical => $self->{critical},
    );
    my ($code, $message) = $self->check_messages(join => ', ', join_all => ', ');
    $NWC::Device::plugin->nagios_exit($code, $message);
  } elsif ($self->mode =~ /device::interfaces::aggregation::availability/) {
    my $aggregation = NWC::IFMIB::Component::LinkAggregation->new();
    #$self->analyze_interface_subsystem();
    $aggregation->check();
  } elsif ($self->mode =~ /device::interfaces/) {
    $self->analyze_interface_subsystem();
    $self->check_interface_subsystem();
  }
}

sub check_snmp_and_model {
# uptime pruefen
# dann whoami
  my $self = shift;
  if ($self->opts->snmpwalk) {
    my $response = {};
    if (! -f $self->opts->snmpwalk) {
      $self->add_message(CRITICAL, 
          sprintf 'file %s not found',
          $self->opts->snmpwalk);
    } elsif (-x $self->opts->snmpwalk) {
      my $cmd = sprintf "%s -On -v%s -c%s %s 1.3.6.1.4.1.232 2>&1",
          $self->opts->snmpwalk,
          $self->opts->protocol,
          $self->opts->community,
          $self->opts->hostname;
      open(WALK, "$cmd |");
      while (<WALK>) {
        if (/^.*?\.(232\.[\d\.]+) = .*?: (\-*\d+)/) {
          $response->{'1.3.6.1.4.1.'.$1} = $2;
        } elsif (/^.*?\.(232\.[\d\.]+) = .*?: "(.*?)"/) {
          $response->{'1.3.6.1.4.1.'.$1} = $2;
          $response->{'1.3.6.1.4.1.'.$1} =~ s/\s+$//;
        }
      }
      close WALK;
    } else {
      if (defined $self->opts->offline) {
        if ((time - (stat($self->opts->snmpwalk))[9]) > $self->opts->offline) {
          $self->add_message(UNKNOWN,
              sprintf 'snmpwalk file %s is too old', $self->opts->snmpwalk);
        }
      }
      $self->opts->override_opt('hostname', 'walkhost');
      open(MESS, $self->opts->snmpwalk);
      while(<MESS>) {
        # SNMPv2-SMI::enterprises.232.6.2.6.7.1.3.1.4 = INTEGER: 6
        if (/^([\d\.]+) = .*?INTEGER: .*\((\-*\d+)\)/) {
          # .1.3.6.1.2.1.2.2.1.8.1 = INTEGER: down(2)
          $response->{$1} = $2;
        } elsif (/^([\d\.]+) = .*?Opaque:.*?Float:.*?([\-\.\d]+)/) {
          # .1.3.6.1.4.1.2021.10.1.6.1 = Opaque: Float: 0.938965
          $response->{$1} = $2;
        } elsif (/^([\d\.]+) = STRING:\s*$/) {
          $response->{$1} = "";
        } elsif (/^([\d\.]+) = Network Address: (.*)/) {
          $response->{$1} = $2;
        } elsif (/^([\d\.]+) = Hex-STRING: (.*)/) {
          $response->{$1} = "0x".$2;
          $response->{$1} =~ s/\s+$//;
        } elsif (/^([\d\.]+) = \w+: (\-*\d+)/) {
          $response->{$1} = $2;
        } elsif (/^([\d\.]+) = \w+: "(.*?)"/) {
          $response->{$1} = $2;
          $response->{$1} =~ s/\s+$//;
        } elsif (/^([\d\.]+) = \w+: (.*)/) {
          $response->{$1} = $2;
          $response->{$1} =~ s/\s+$//;
        } elsif (/^([\d\.]+) = (\-*\d+)/) {
          $response->{$1} = $2;
        } elsif (/^([\d\.]+) = "(.*?)"/) {
          $response->{$1} = $2;
          $response->{$1} =~ s/\s+$//;
        }
      }
      close MESS;
    }
    foreach my $oid (keys %$response) {
      if ($oid =~ /^\./) {
        my $nodot = $oid;
        $nodot =~ s/^\.//g;
        $response->{$nodot} = $response->{$oid};
        delete $response->{$oid};
      }
    }
    map { $response->{$_} =~ s/^\s+//; $response->{$_} =~ s/\s+$//; }
        keys %$response;
    #printf "%s\n", Data::Dumper::Dumper($response);
    $self->set_rawdata($response);
    #if (! $self->get_snmp_object('MIB-II', 'sysDescr', 0)) {
    #  $self->add_rawdata('1.3.6.1.2.1.1.1.0', 'Cisco');
    #}
    $self->whoami();
  } else {
    if (eval "require Net::SNMP") {
      my %params = ();
      my $net_snmp_version = Net::SNMP->VERSION(); # 5.002000 or 6.000000
      #$params{'-translate'} = [
      #  -all => 0x0
      #];
      #lausser#$params{'-timeout'} = $self->opts->timeout;
      $params{'-hostname'} = $self->opts->hostname;
      $params{'-version'} = $self->opts->protocol;
      if ($self->opts->port) {
        $params{'-port'} = $self->opts->port;
      }
      if ($self->opts->domain) {
        $params{'-domain'} = $self->opts->domain;
      }
      if ($self->opts->protocol eq '3') {
        $params{'-username'} = $self->opts->username;
        if ($self->opts->authpassword) {
          $params{'-authpassword'} = $self->opts->authpassword;
        }
        if ($self->opts->authprotocol) {
          $params{'-authprotocol'} = $self->opts->authprotocol;
        }
        if ($self->opts->privpassword) {
          $params{'-privpassword'} = $self->opts->privpassword;
        }
        if ($self->opts->privprotocol) {
          $params{'-privprotocol'} = $self->opts->privprotocol;
        }
      } else {
        $params{'-community'} = $self->opts->community;
      }
      my ($session, $error) = Net::SNMP->session(%params);
      if (! defined $session) {
        $self->add_message(CRITICAL, 
            sprintf 'cannot create session object: %s', $error);
        $self->debug(Data::Dumper::Dumper(\%params));
      } else {
        my $max_msg_size = $session->max_msg_size();
        $session->max_msg_size(4 * $max_msg_size);
        $NWC::Device::session = $session;
        my $sysUpTime = '1.3.6.1.2.1.1.3.0';
        my $uptime = $self->get_snmp_object('MIB-II', 'sysUpTime', 0);
        if (my $uptime = $self->get_snmp_object('MIB-II', 'sysUpTime', 0)) {
          $self->debug(sprintf 'snmp agent answered: %s', $uptime);
          $self->whoami();
        } else {
          $self->add_message(CRITICAL,
              'could not contact snmp agent');
          $session->close;
        }
      }
    } else {
      $self->add_message(CRITICAL,
          'could not find Net::SNMP module');
    }
  }
}

sub whoami {
  my $self = shift;
  my $productname = undef;
  my $sysDescr = '1.3.6.1.2.1.1.1.0';
  my $dummy = '1.3.6.1.2.1.1.5.0';
  if ($productname = $self->get_snmp_object('MIB-II', 'sysDescr', 0)) {
    $self->{productname} = $productname;
    $self->{uptime} = $self->timeticks(
        $self->get_snmp_object('MIB-II', 'sysUpTime', 0));
    $self->debug(sprintf 'uptime: %s', $self->{uptime});
    $self->debug(sprintf 'up since: %s',
        scalar localtime (time - $self->{uptime}));
    $NWC::Device::uptime = $self->{uptime};
  } else {
    $self->add_message(CRITICAL,
        'snmpwalk returns no product name (sysDescr)');
    if (! $self->opts->snmpwalk) {
      $NWC::Device::session->close;
    }
  }
  $self->debug('whoami: '.$self->{productname});
}

sub timeticks {
  my $self = shift;
  my $timestr = shift;
  if ($timestr =~ /\((\d+)\)/) {
    # Timeticks: (20718727) 2 days, 9:33:07.27
    $timestr = $1 / 100;
  } elsif ($timestr =~ /(\d+)\s*days.*?(\d+):(\d+):(\d+)\.(\d+)/) {
    # Timeticks: 2 days, 9:33:07.27
    $timestr = $1 * 24 * 3600 + $2 * 3600 + $3 * 60 + $4;
  } elsif ($timestr =~ /(\d+):(\d+):(\d+)\.(\d+)/) {
    # Timeticks: 9:33:07.27
    $timestr = $1 * 3600 + $2 * 60 + $3;
  } elsif ($timestr =~ /(\d+)\s*hour[s]*.*?(\d+):(\d+)\.(\d+)/) {
    # Timeticks: 3 hours, 42:17.98
    $timestr = $1 * 3600 + $2 * 60 + $3;
  } elsif ($timestr =~ /(\d+)\s*minute[s]*.*?(\d+)\.(\d+)/) {
    # Timeticks: 36 minutes, 01.96
    $timestr = $1 * 60 + $2;
  } elsif ($timestr =~ /(\d+)\.\d+\s*second[s]/) {
    # Timeticks: 01.02 seconds
    $timestr = $1;
  }
  return $timestr;
}

sub human_timeticks {
  my $self = shift;
  my $timeticks = shift;
  my $days = int($timeticks / 86400); 
  $timeticks -= ($days * 86400); 
  my $hours = int($timeticks / 3600); 
  $timeticks -= ($hours * 3600); 
  my $minutes = int($timeticks / 60); 
  my $seconds = $timeticks % 60; 
  $days = $days < 1 ? '' : $days .'d '; 
  return $days . sprintf "%02d:%02d:%02d", $hours, $minutes, $seconds;
}

sub get_snmp_object {
  my $self = shift;
  my $mib = shift;
  my $mo = shift;
  my $index = shift;
  if (exists $NWC::Device::mibs_and_oids->{$mib} &&
      exists $NWC::Device::mibs_and_oids->{$mib}->{$mo}) {
    my $oid = $NWC::Device::mibs_and_oids->{$mib}->{$mo}.
        (defined $index ? '.'.$index : '');
    my $response = $self->get_request(-varbindlist => [$oid]);
    if (defined $response->{$oid}) {
      if (my @symbols = $self->make_symbolic($mib, $response, [[$index]])) {
        $response->{$oid} = $symbols[0]->{$mo};
      }
    }
    return $response->{$oid};
  }
  return undef;
}

sub get_single_request_iq {
  my $self = shift;
  my %params = @_;
  my @oids = ();
  my $result = $self->get_request_iq(%params);
  foreach (keys %{$result}) {
    return $result->{$_};
  }
  return undef;
}

sub get_request_iq {
  my $self = shift;
  my %params = @_;
  my @oids = ();
  my $mib = $params{'-mib'};
  foreach my $oid (@{$params{'-molist'}}) {
    if (exists $NWC::Device::mibs_and_oids->{$mib} &&
        exists $NWC::Device::mibs_and_oids->{$mib}->{$oid}) {
      push(@oids, (exists $params{'-index'}) ?
          $NWC::Device::mibs_and_oids->{$mib}->{$oid}.'.'.$params{'-index'} :
          $NWC::Device::mibs_and_oids->{$mib}->{$oid});
    }
  }
  return $self->get_request(
      -varbindlist => \@oids);
}

sub valid_response {
  my $self = shift;
  my $mib = shift;
  my $oid = shift;
  my $index = shift;
  if (exists $NWC::Device::mibs_and_oids->{$mib} &&
      exists $NWC::Device::mibs_and_oids->{$mib}->{$oid}) {
    # make it numerical
    my $oid = $NWC::Device::mibs_and_oids->{$mib}->{$oid};
    if (defined $index) {
      $oid .= '.'.$index;
    }
    my $result = $self->get_request(
        -varbindlist => [$oid]
    );
    if (!defined($result) ||
        ! defined $result->{$oid} ||
        $result->{$oid} eq 'noSuchInstance' ||
        $result->{$oid} eq 'noSuchObject' ||
        $result->{$oid} eq 'endOfMibView') {
      return undef;
    } else {
      $self->add_rawdata($oid, $result->{$oid});
      return $result->{$oid};
    }
  } else {
    return undef;
  }
}

sub debug {
  my $self = shift;
  my $format = shift;
  $self->{trace} = -f "/tmp/check_nwc_health.trace" ? 1 : 0;
  if ($self->opts->verbose && $self->opts->verbose > 10) {
    printf("%s: ", scalar localtime);
    printf($format, @_);
    printf "\n";
  }
  if ($self->{trace}) {
    my $logfh = new IO::File;
    $logfh->autoflush(1);
    if ($logfh->open("/tmp/check_nwc_health.trace", "a")) {
      $logfh->printf("%s: ", scalar localtime);
      $logfh->printf($format, @_);
      $logfh->printf("\n");
      $logfh->close();
    }
  }
}

sub filter_name {
  my $self = shift;
  my $name = shift;
  if ($self->opts->name) {
    if ($self->opts->regexp) {
      my $pattern = $self->opts->name;
      if ($name =~ /$pattern/i) {
        return 1;
      }
    } else {
      if (lc $self->opts->name eq lc $name) {
        return 1;
      }
    }
  } else {
    return 1;
  }
  return 0;
}

sub blacklist {
  my $self = shift;
  my $type = shift;
  my $name = shift;
  $self->{blacklisted} = $self->is_blacklisted($type, $name);
}

sub add_blacklist {
  my $self = shift;
  my $list = shift;
  $NWC::Device::blacklist = join('/',
      (split('/', $self->opts->blacklist), $list));
}

sub is_blacklisted {
  my $self = shift;
  my $type = shift;
  my $name = shift;
  my $blacklisted = 0;
#  $name =~ s/\:/-/g;
  foreach my $bl_items (split(/\//, $self->opts->blacklist)) {
    if ($bl_items =~ /^(\w+):([\:\d\-,]+)$/) {
      my $bl_type = $1;
      my $bl_names = $2;
      foreach my $bl_name (split(/,/, $bl_names)) {
        if ($bl_type eq $type && $bl_name eq $name) {
          $blacklisted = 1;
        }
      }
    } elsif ($bl_items =~ /^(\w+)$/) {
      my $bl_type = $1;
      if ($bl_type eq $type) {
        $blacklisted = 1;
      }
    }
  }
  return $blacklisted;
}

sub mode {
  my $self = shift;
  return $NWC::Device::mode;
}

sub uptime {
  my $self = shift;
  return $NWC::Device::uptime;
}

sub add_message {
  my $self = shift;
  my $level = shift;
  my $message = shift;
  $NWC::Device::plugin->add_message($level, $message) 
      unless $self->{blacklisted};
  if (exists $self->{failed}) {
    if ($level == UNKNOWN && $self->{failed} == OK) {
      $self->{failed} = $level;
    } elsif ($level > $self->{failed}) {
      $self->{failed} = $level;
    }
  }
}

sub check_messages {
  my $self = shift;
  return $NWC::Device::plugin->check_messages(@_);
}

sub clear_messages {
  my $self = shift;
  return $NWC::Device::plugin->clear_messages(@_);
}

sub add_perfdata {
  my $self = shift;
  $NWC::Device::plugin->add_perfdata(@_);
}

sub set_thresholds {
  my $self = shift;
  $NWC::Device::plugin->set_thresholds(@_);
}

sub force_thresholds {
  my $self = shift;
  $NWC::Device::plugin->force_thresholds(@_);
}

sub check_thresholds {
  my $self = shift;
  my @params = @_;
  ($self->{warning}, $self->{critical}) =
      $NWC::Device::plugin->get_thresholds(@params);
  return $NWC::Device::plugin->check_thresholds(@params);
}

sub get_thresholds {
  my $self = shift;
  my @params = @_;
  my @thresholds = $NWC::Device::plugin->get_thresholds(@params);
  my($warning, $critical) = $NWC::Device::plugin->get_thresholds(@params);
  $self->{warning} = $thresholds[0];
  $self->{critical} = $thresholds[1];
  return @thresholds;
}

sub has_failed {
  my $self = shift;
  return $self->{failed};
}

sub add_info {
  my $self = shift;
  my $info = shift;
  $info = $self->{blacklisted} ? $info.' (blacklisted)' : $info;
  $self->{info} = $info;
  push(@{$NWC::Device::info}, $info);
}

sub annotate_info {
  my $self = shift;
  my $annotation = shift;
  my $lastinfo = pop(@{$NWC::Device::info});
  $lastinfo .= sprintf ' (%s)', $annotation;
  push(@{$NWC::Device::info}, $lastinfo);
}

sub add_extendedinfo {
  my $self = shift;
  my $info = shift;
  $self->{extendedinfo} = $info;
  return if ! $self->opts->extendedinfo;
  push(@{$NWC::Device::extendedinfo}, $info);
}

sub get_extendedinfo {
  my $self = shift;
  return join(' ', @{$NWC::Device::extendedinfo});
}

sub add_summary {
  my $self = shift;
  my $summary = shift;
  push(@{$NWC::Device::summary}, $summary);
}

sub get_summary {
  my $self = shift;
  return join(', ', @{$NWC::Device::summary});
}

sub opts {
  my $self = shift;
  return $NWC::Device::plugin->opts();
}

sub set_rawdata {
  my $self = shift;
  $NWC::Device::rawdata = shift;
}

sub add_rawdata {
  my $self = shift;
  my $oid = shift;
  my $value = shift;
  $NWC::Device::rawdata->{$oid} = $value;
}

sub rawdata {
  my $self = shift;
  return $NWC::Device::rawdata;
}

sub add_oidtrace {
  my $self = shift;
  my $oid = shift;
  $self->debug("cache: ".$oid);
  push(@{$NWC::Device::oidtrace}, $oid);
}

sub get_snmp_table_attributes {
  my $self = shift;
  my $mib = shift;
  my $table = shift;
  my $indices = shift || [];
  my @entries = ();
  my $augmenting_table;
  if ($table =~ /^(.*?)\+(.*)/) {
    $table = $1;
    $augmenting_table = $2;
  }
  my $entry = $table;
  $entry =~ s/Table/Entry/g;
  if (exists $NWC::Device::mibs_and_oids->{$mib} &&
      exists $NWC::Device::mibs_and_oids->{$mib}->{$table}) {
    my $toid = $NWC::Device::mibs_and_oids->{$mib}->{$table}.'.';
    my $toidlen = length($toid);
    my @columns = grep {
      substr($NWC::Device::mibs_and_oids->{$mib}->{$_}, 0, $toidlen) eq
          $NWC::Device::mibs_and_oids->{$mib}->{$table}.'.'
    } keys %{$NWC::Device::mibs_and_oids->{$mib}};
    if ($augmenting_table &&
        exists $NWC::Device::mibs_and_oids->{$mib}->{$augmenting_table}) {
      my $toid = $NWC::Device::mibs_and_oids->{$mib}->{$augmenting_table}.'.';
      my $toidlen = length($toid);
      push(@columns, grep {
        substr($NWC::Device::mibs_and_oids->{$mib}->{$_}, 0, $toidlen) eq
            $NWC::Device::mibs_and_oids->{$mib}->{$augmenting_table}.'.'
      } keys %{$NWC::Device::mibs_and_oids->{$mib}});
    }
    return @columns;
  } else {
    return ();
  }
}

sub get_request {
  my $self = shift;
  my %params = @_;
  my @notcached = ();
  foreach my $oid (@{$params{'-varbindlist'}}) {
    $self->add_oidtrace($oid);
    if (! exists NWC::Device::rawdata->{$oid}) {
      push(@notcached, $oid);
    }
  }
  if (! $self->opts->snmpwalk && (scalar(@notcached) > 0)) {
    my $result = ($NWC::Device::session->version() == 0) ?
        $NWC::Device::session->get_request(
            -varbindlist => \@notcached,
        )
        :
        $NWC::Device::session->get_request(  # get_bulk_request liefert next
            #-nonrepeaters => scalar(@notcached),
            -varbindlist => \@notcached,
        );
    foreach my $key (%{$result}) {
      $self->add_rawdata($key, $result->{$key});
    }
  }
  my $result = {};
  map { $result->{$_} = $NWC::Device::rawdata->{$_} }
      @{$params{'-varbindlist'}};
  return $result;
}

# Level1
# get_snmp_table_objects('MIB-Name', 'Table-Name', 'Table-Entry', [indices])
#
# returns array of hashrefs
# evt noch ein weiterer parameter fuer ausgewaehlte oids
#
sub get_snmp_table_objects_with_cache {
  my $self = shift;
  my $mib = shift;
  my $table = shift;
  my $key_attr = shift;
  #return $self->get_snmp_table_objects($mib, $table);
  $self->update_entry_cache(0, $mib, $table, $key_attr);
  my @indices = $self->get_cache_indices($mib, $table, $key_attr);
  my @entries = ();
  foreach ($self->get_snmp_table_objects($mib, $table, \@indices)) {
    push(@entries, $_);
  }
  return @entries;
}

sub get_snmp_table_objects {
  my $self = shift;
  my $mib = shift;
  my $table = shift;
  my $indices = shift || [];
  my @entries = ();
  my $augmenting_table;
  $self->debug(sprintf "get_snmp_table_objects %s %s", $mib, $table);
  if ($table =~ /^(.*?)\+(.*)/) {
    $table = $1;
    $augmenting_table = $2;
  }
  my $entry = $table;
  $entry =~ s/Table/Entry/g;
  if (scalar(@{$indices}) == 1) {
    if (exists $NWC::Device::mibs_and_oids->{$mib} &&
        exists $NWC::Device::mibs_and_oids->{$mib}->{$table}) {
      my $eoid = $NWC::Device::mibs_and_oids->{$mib}->{$entry}.'.';
      my $eoidlen = length($eoid);
      my @columns = map {
          $NWC::Device::mibs_and_oids->{$mib}->{$_}
      } grep {
        substr($NWC::Device::mibs_and_oids->{$mib}->{$_}, 0, $eoidlen) eq
            $NWC::Device::mibs_and_oids->{$mib}->{$entry}.'.'
      } keys %{$NWC::Device::mibs_and_oids->{$mib}};
      my $index = join('.', @{$indices->[0]});
      if ($augmenting_table && 
          exists $NWC::Device::mibs_and_oids->{$mib}->{$augmenting_table}) {
        my $augmenting_entry = $augmenting_table;
        $augmenting_entry =~ s/Table/Entry/g;
        my $eoid = $NWC::Device::mibs_and_oids->{$mib}->{$augmenting_entry}.'.';
        my $eoidlen = length($eoid);
        push(@columns, map {
            $NWC::Device::mibs_and_oids->{$mib}->{$_}
        } grep {
          substr($NWC::Device::mibs_and_oids->{$mib}->{$_}, 0, $eoidlen) eq
              $NWC::Device::mibs_and_oids->{$mib}->{$augmenting_table}.'.'
        } keys %{$NWC::Device::mibs_and_oids->{$mib}});
      }
      my  $result = $self->get_entries(
          -startindex => $index,
          -endindex => $index,
          -columns => \@columns,
      );
      @entries = $self->make_symbolic($mib, $result, $indices);
      @entries = map { $_->{indices} = shift @{$indices}; $_ } @entries;
    }
  } elsif (scalar(@{$indices}) > 1) {
    # man koennte hier pruefen, ob die indices aufeinanderfolgen
    # und dann get_entries statt get_table aufrufen
    if (exists $NWC::Device::mibs_and_oids->{$mib} &&
        exists $NWC::Device::mibs_and_oids->{$mib}->{$table}) {
      my $result = {};
      my $eoid = $NWC::Device::mibs_and_oids->{$mib}->{$entry}.'.';
      my $eoidlen = length($eoid);
      my @columns = map {
          $NWC::Device::mibs_and_oids->{$mib}->{$_}
      } grep {
        substr($NWC::Device::mibs_and_oids->{$mib}->{$_}, 0, $eoidlen) eq
            $NWC::Device::mibs_and_oids->{$mib}->{$entry}.'.'
      } keys %{$NWC::Device::mibs_and_oids->{$mib}};
      my @sortedindices = map { $_->[0] }
          sort { $a->[1] cmp $b->[1] }
              map { [$_,
                  join '', map { sprintf("%30d",$_) } split( /\./, $_)
              ] } map { join('.', @{$_})} @{$indices};
      my $startindex = $sortedindices[0];
      my $endindex = $sortedindices[$#sortedindices];
      if (0) {
        # holzweg. dicke ciscos liefern unvollstaendiges resultat, d.h.
        # bei 138,19,157 kommt nur 138..144, dann ist schluss.
        # maxrepetitions bringt nichts.
        $result = $self->get_entries(
            -startindex => $startindex,
            -endindex => $endindex,
            -columns => \@columns,
        );
        if (! $result) {
          $result = $self->get_entries(
              -startindex => $startindex,
              -endindex => $endindex,
              -columns => \@columns,
              -maxrepetitions => 0,
          );
        }
      } else {
        foreach my $ifidx (@sortedindices) {
          my $ifresult = $self->get_entries(
              -startindex => $ifidx,
              -endindex => $ifidx,
              -columns => \@columns,
          );
          map { $result->{$_} = $ifresult->{$_} }
              keys %{$ifresult};
        }
      }
      if ($augmenting_table &&
          exists $NWC::Device::mibs_and_oids->{$mib}->{$augmenting_table}) {
        my $entry = $augmenting_table;
        $entry =~ s/Table/Entry/g;
        my $eoid = $NWC::Device::mibs_and_oids->{$mib}->{$entry}.'.';
        my $eoidlen = length($eoid);
        my @columns = map {
            $NWC::Device::mibs_and_oids->{$mib}->{$_}
        } grep {
          substr($NWC::Device::mibs_and_oids->{$mib}->{$_}, 0, $eoidlen) eq
              $NWC::Device::mibs_and_oids->{$mib}->{$entry}.'.'
        } keys %{$NWC::Device::mibs_and_oids->{$mib}};
        foreach my $ifidx (@sortedindices) {
          my $ifresult = $self->get_entries(
              -startindex => $ifidx,
              -endindex => $ifidx,
              -columns => \@columns,
          );
          map { $result->{$_} = $ifresult->{$_} }
              keys %{$ifresult};
        }
      }
      # now we have numerical_oid+index => value
      # needs to become symboic_oid => value
      #my @indices =
      # $self->get_indices($NWC::Device::mibs_and_oids->{$mib}->{$entry});
      @entries = $self->make_symbolic($mib, $result, $indices);
      @entries = map { $_->{indices} = shift @{$indices}; $_ } @entries;
    }
  } else {
    if (exists $NWC::Device::mibs_and_oids->{$mib} &&
        exists $NWC::Device::mibs_and_oids->{$mib}->{$table}) {
      $self->debug(sprintf "get_snmp_table_objects calls get_table %s",
          $NWC::Device::mibs_and_oids->{$mib}->{$table});
      my $result = $self->get_table(
          -baseoid => $NWC::Device::mibs_and_oids->{$mib}->{$table});
      $self->debug(sprintf "get_snmp_table_objects get_table returns %d oids",
          scalar(keys %{$result}));
      # now we have numerical_oid+index => value
      # needs to become symboic_oid => value
      my @indices = 
          $self->get_indices(
              -baseoid => $NWC::Device::mibs_and_oids->{$mib}->{$entry},
              -oids => [keys %{$result}]);
      $self->debug(sprintf "get_snmp_table_objects get_table returns %d indices",
          scalar(@indices));
      @entries = $self->make_symbolic($mib, $result, \@indices);
      @entries = map { $_->{indices} = shift @indices; $_ } @entries;
    }
  }
  @entries = map { $_->{flat_indices} = join(".", @{$_->{indices}}); $_ } @entries;
  return @entries;
}

# make_symbolic
# mib is the name of a mib (must be in mibs_and_oids)
# result is a hash-key oid->value
# indices is a array ref of array refs. [[1],[2],...] or [[1,0],[1,1],[2,0]..
sub make_symbolic {
  my $self = shift;
  my $mib = shift;
  my $result = shift;
  my $indices = shift;
  my @entries = ();
  foreach my $index (@{$indices}) {
    # skip [], [[]], [[undef]]
    if (ref($index) eq "ARRAY") {
      if (scalar(@{$index}) == 0) {
        next;
      } elsif (!defined $index->[0]) {
        next;
      }
    }
    my $mo = {};
    my $idx = join('.', @{$index}); # index can be multi-level
    foreach my $symoid
        (keys %{$NWC::Device::mibs_and_oids->{$mib}}) {
      my $oid = $NWC::Device::mibs_and_oids->{$mib}->{$symoid};
      if (ref($oid) ne 'HASH') {
        my $fulloid = $oid . '.'.$idx;
        if (exists $result->{$fulloid}) {
          if (exists $NWC::Device::mibs_and_oids->{$mib}->{$symoid.'Definition'}) {
            if (ref($NWC::Device::mibs_and_oids->{$mib}->{$symoid.'Definition'}) eq 'HASH') {
              if (exists $NWC::Device::mibs_and_oids->{$mib}->{$symoid.'Definition'}->{$result->{$fulloid}}) {
                $mo->{$symoid} = $NWC::Device::mibs_and_oids->{$mib}->{$symoid.'Definition'}->{$result->{$fulloid}};
              } else {
                $mo->{$symoid} = 'unknown_'.$result->{$fulloid};
              }
            } elsif ($NWC::Device::mibs_and_oids->{$mib}->{$symoid.'Definition'} =~ /^(.*?)::(.*)/) {
              my $mib = $1;
              my $definition = $2;
              if  (exists $NWC::Device::definitions->{$mib} && exists $NWC::Device::definitions->{$mib}->{$definition}
                  && exists $NWC::Device::definitions->{$mib}->{$definition}->{$result->{$fulloid}}) {
                $mo->{$symoid} = $NWC::Device::definitions->{$mib}->{$definition}->{$result->{$fulloid}};
              } else {
                $mo->{$symoid} = 'unknown_'.$result->{$fulloid};
              }
            } else {
              $mo->{$symoid} = 'unknown_'.$result->{$fulloid};
              # oder $NWC::Device::mibs_and_oids->{$mib}->{$symoid.'Definition'}?
            }
          } else {
            $mo->{$symoid} = $result->{$fulloid};
          }
        }
      }
    }
    push(@entries, $mo);
  }
  if (@{$indices} and scalar(@{$indices}) == 1 and !defined $indices->[0]->[0]) {
    my $mo = {};
    foreach my $symoid
        (keys %{$NWC::Device::mibs_and_oids->{$mib}}) {
      my $oid = $NWC::Device::mibs_and_oids->{$mib}->{$symoid};
      if (ref($oid) ne 'HASH') {
        if (exists $result->{$oid}) {
          if (exists $NWC::Device::mibs_and_oids->{$mib}->{$symoid.'Definition'}) {
            if (ref($NWC::Device::mibs_and_oids->{$mib}->{$symoid.'Definition'}) eq 'HASH') {
              if (exists $NWC::Device::mibs_and_oids->{$mib}->{$symoid.'Definition'}->{$result->{$oid}}) {
                $mo->{$symoid} = $NWC::Device::mibs_and_oids->{$mib}->{$symoid.'Definition'}->{$result->{$oid}};
                push(@entries, $mo);
              }
            }
          }
        }
      }
    }
  }
  return @entries;
}

# Level2
# - get_table from Net::SNMP
# - get all baseoid-matching oids from rawdata
sub get_table {
  my $self = shift;
  my %params = @_;
  $self->add_oidtrace($params{'-baseoid'});
  if (! $self->opts->snmpwalk) {
    my @notcached = ();
    $self->debug(sprintf "get_table %s", Data::Dumper::Dumper(\%params));
    my $result = $NWC::Device::session->get_table(%params);
    $self->debug(sprintf "get_table returned %d oids", scalar(keys %{$result}));
    if (scalar(keys %{$result}) == 0) {
      $self->debug(sprintf "get_table error: %s", 
          $NWC::Device::session->error());
      $self->debug("get_table error: try fallback");
      $params{'-maxrepetitions'} = 1;
      $self->debug(sprintf "get_table %s", Data::Dumper::Dumper(\%params));
      $result = $NWC::Device::session->get_table(%params);
      $self->debug(sprintf "get_table returned %d oids", scalar(keys %{$result}));
      if (scalar(keys %{$result}) == 0) {
        $self->debug(sprintf "get_table error: %s", 
            $NWC::Device::session->error());
        $self->debug("get_table error: no more fallbacks. Try --protocol 1");
      }
    }
    foreach my $key (keys %{$result}) {
      $self->add_rawdata($key, $result->{$key});
    }
  }
  return $self->get_matching_oids(
      -columns => [$params{'-baseoid'}]);
}

sub get_entries {
  my $self = shift;
  my %params = @_;
  # [-startindex]
  # [-endindex]
  # -columns
  my $result = {};
  $self->debug(sprintf "get_entries %s", Data::Dumper::Dumper(\%params));
  if (! $self->opts->snmpwalk) {
    my %newparams = ();
    $newparams{'-startindex'} = $params{'-startindex'}
        if defined $params{'-startindex'};
    $newparams{'-endindex'} = $params{'-endindex'}     
        if defined $params{'-endindex'};
    $newparams{'-columns'} = $params{'-columns'};
    $result = $NWC::Device::session->get_entries(%newparams);
    if (! $result) {
      $newparams{'-maxrepetitions'} = 0;
      $result = $NWC::Device::session->get_entries(%newparams);
      if (! $result) {
        $self->debug(sprintf "get_entries tries last fallback");
        delete $newparams{'-endindex'};
        delete $newparams{'-startindex'};
        delete $newparams{'-maxrepetitions'};
        $result = $NWC::Device::session->get_entries(%newparams);
      }
    }
    foreach my $key (keys %{$result}) {
      $self->add_rawdata($key, $result->{$key});
    }
  } else {
    my $preresult = $self->get_matching_oids(
        -columns => $params{'-columns'});
    foreach (keys %{$preresult}) {
      $result->{$_} = $preresult->{$_};
    }
    my @sortedkeys = map { $_->[0] }
        sort { $a->[1] cmp $b->[1] }
            map { [$_,
                    join '', map { sprintf("%30d",$_) } split( /\./, $_)
                  ] } keys %{$result};
    my @to_del = ();
    if ($params{'-startindex'}) {
      foreach my $resoid (@sortedkeys) {
        foreach my $oid (@{$params{'-columns'}}) {
          my $poid = $oid.'.';
          my $lpoid = length($poid);
          if (substr($resoid, 0, $lpoid) eq $poid) {
            my $oidpattern = $poid;
            $oidpattern =~ s/\./\\./g;
            if ($resoid =~ /^$oidpattern(.+)$/) {
              if ($1 lt $params{'-startindex'}) {
                push(@to_del, $oid.'.'.$1);
              }
            }
          }
        }
      }
    }
    if ($params{'-endindex'}) {
      foreach my $resoid (@sortedkeys) {
        foreach my $oid (@{$params{'-columns'}}) {
          my $poid = $oid.'.';
          my $lpoid = length($poid);
          if (substr($resoid, 0, $lpoid) eq $poid) {
            my $oidpattern = $poid;
            $oidpattern =~ s/\./\\./g;
            if ($resoid =~ /^$oidpattern(.+)$/) {
              if ($1 gt $params{'-endindex'}) {
                push(@to_del, $oid.'.'.$1);
              }
            }
          }
        }
      } 
    }
    foreach (@to_del) {
      delete $result->{$_};
    }
  }
  return $result;
}

# Level2
# helper function
sub get_matching_oids {
  my $self = shift;
  my %params = @_;
  my $result = {};
  $self->debug(sprintf "get_matching_oids %s", Data::Dumper::Dumper(\%params));
  foreach my $oid (@{$params{'-columns'}}) {
    my $oidpattern = $oid;
    $oidpattern =~ s/\./\\./g;
    map { $result->{$_} = $NWC::Device::rawdata->{$_} }
        grep /^$oidpattern(?=\.|$)/, keys %{$NWC::Device::rawdata};
  }
  $self->debug(sprintf "get_matching_oids returns %d from %d oids", 
      scalar(keys %{$result}), scalar(keys %{$NWC::Device::rawdata}));
  return $result;
}

sub valdiff {
  my $self = shift;
  my $pparams = shift;
  my %params = %{$pparams};
  my @keys = @_;
  my $now = time;
  my $newest_history_set = {};
  my $last_values = $self->load_state(%params) || eval {
    my $empty_events = {};
    foreach (@keys) {
      if (ref($self->{$_}) eq "ARRAY") {
        $empty_events->{$_} = [];
      } else {
        $empty_events->{$_} = 0;
      }
    }
    $empty_events->{timestamp} = 0;
    if ($self->opts->lookback) {
      $empty_events->{lookback_history} = {};
    }
    $empty_events;
  };
  foreach (@keys) {
    if ($self->opts->lookback) {
      # find a last_value in the history which fits lookback best
      # and overwrite $last_values->{$_} with historic data
      if (exists $last_values->{lookback_history}->{$_}) {
        foreach my $date (sort {$a <=> $b} keys %{$last_values->{lookback_history}->{$_}}) {
            $newest_history_set->{$_} = $last_values->{lookback_history}->{$_}->{$date};
            $newest_history_set->{timestamp} = $date;
        }
        foreach my $date (sort {$a <=> $b} keys %{$last_values->{lookback_history}->{$_}}) {
          if ($date >= ($now - $self->opts->lookback)) {
            $last_values->{$_} = $last_values->{lookback_history}->{$_}->{$date};
            $last_values->{timestamp} = $date;
            last;
          } else {
            delete $last_values->{lookback_history}->{$_}->{$date};
          }
        }
      }
    }
    if ($self->{$_} =~ /^\d+$/) {
      $last_values->{$_} = 0 if ! exists $last_values->{$_};
      if ($self->{$_} >= $last_values->{$_}) {
        $self->{'delta_'.$_} = $self->{$_} - $last_values->{$_};
      } else {
        # vermutlich db restart und zaehler alle auf null
        $self->{'delta_'.$_} = $self->{$_};
      }
      $self->debug(sprintf "delta_%s %f", $_, $self->{'delta_'.$_});
    } elsif (ref($self->{$_}) eq "ARRAY") {
      if ((! exists $last_values->{$_} || ! defined $last_values->{$_}) && exists $params{lastarray}) {
        # innerhalb der lookback-zeit wurde nichts in der lookback_history
        # gefunden. allenfalls irgendwas aelteres. normalerweise
        # wuerde jetzt das array als [] initialisiert.
        # d.h. es wuerde ein delta geben, @found s.u.
        # wenn man das nicht will, sondern einfach aktuelles array mit
        # dem array des letzten laufs vergleichen will, setzt man lastarray
        $last_values->{$_} = %{$newest_history_set} ?
            $newest_history_set->{$_} : []
      } elsif ((! exists $last_values->{$_} || ! defined $last_values->{$_}) && ! exists $params{lastarray}) {
        $last_values->{$_} = [] if ! exists $last_values->{$_};
      } elsif (exists $last_values->{$_} && ! defined $last_values->{$_}) {
        # $_ kann es auch ausserhalb des lookback_history-keys als normalen
        # key geben. der zeigt normalerweise auf den entspr. letzten 
        # lookback_history eintrag. wurde der wegen ueberalterung abgeschnitten
        # ist der hier auch undef.
        $last_values->{$_} = %{$newest_history_set} ?
            $newest_history_set->{$_} : []
      }
      my %saved = map { $_ => 1 } @{$last_values->{$_}};
      my %current = map { $_ => 1 } @{$self->{$_}};
      my @found = grep(!defined $saved{$_}, @{$self->{$_}});
      my @lost = grep(!defined $current{$_}, @{$last_values->{$_}});
      $self->{'delta_found_'.$_} = \@found;
      $self->{'delta_lost_'.$_} = \@lost;
    }
  }
  $self->{'delta_timestamp'} = $now - $last_values->{timestamp};
  $params{save} = eval {
    my $empty_events = {};
    foreach (@keys) {
      $empty_events->{$_} = $self->{$_};
    }
    $empty_events->{timestamp} = $now;
    if ($self->opts->lookback) {
      $empty_events->{lookback_history} = $last_values->{lookback_history};
      foreach (@keys) {
        $empty_events->{lookback_history}->{$_}->{$now} = $self->{$_};
      }
    }
    $empty_events;
  };
  $self->save_state(%params);
}

sub create_statefilesdir {
  my $self = shift;
  if (! -d $NWC::Device::statefilesdir) {
    eval {
      use File::Path;
      mkpath $NWC::Device::statefilesdir;
    };
    if ($@ || ! -w $NWC::Device::statefilesdir) {
      $self->add_message(UNKNOWN,
        sprintf "cannot create status dir %s! check your filesystem (permissions/usage/integrity) and disk devices", $NWC::Device::statefilesdir);
    }
  } elsif (! -w $NWC::Device::statefilesdir) {
    $self->add_message(UNKNOWN,
        sprintf "cannot write status dir %s! check your filesystem (permissions/usage/integrity) and disk devices", $NWC::Device::statefilesdir);
  }
}

sub create_statefile {
  my $self = shift;
  my %params = @_;
  my $extension = "";
  $extension .= $params{name} ? '_'.$params{name} : '';
  if ($self->opts->community) { 
    $extension .= md5_hex($self->opts->community);
  }
  $extension =~ s/\//_/g;
  $extension =~ s/\(/_/g;
  $extension =~ s/\)/_/g;
  $extension =~ s/\*/_/g;
  $extension =~ s/\s/_/g;
  if ($self->opts->snmpwalk && ! $self->opts->hostname) {
    return sprintf "%s/%s_%s%s", $NWC::Device::statefilesdir,
        'snmpwalk.file'.md5_hex($self->opts->snmpwalk),
        $self->opts->mode, lc $extension;
  } elsif ($self->opts->snmpwalk && $self->opts->hostname eq "walkhost") {
    return sprintf "%s/%s_%s%s", $NWC::Device::statefilesdir,
        'snmpwalk.file'.md5_hex($self->opts->snmpwalk),
        $self->opts->mode, lc $extension;
  } else {
    return sprintf "%s/%s_%s%s", $NWC::Device::statefilesdir,
        $self->opts->hostname, $self->opts->mode, lc $extension;
  }
}

sub schimpf {
  my $self = shift;
  printf "statefilesdir %s is not writable.\nYou didn't run this plugin as root, didn't you?\n", $NWC::Device::statefilesdir;
}

sub save_state {
  my $self = shift;
  my %params = @_;
  $self->create_statefilesdir();
  my $statefile = $self->create_statefile(%params);
  if ((ref($params{save}) eq "HASH") && exists $params{save}->{timestamp}) {
    $params{save}->{localtime} = scalar localtime $params{save}->{timestamp};
  } 
  my $seekfh = new IO::File;
  if ($seekfh->open($statefile, "w")) {
    $seekfh->printf("%s", Data::Dumper::Dumper($params{save}));
    $seekfh->close();
    $self->debug(sprintf "saved %s to %s",
        Data::Dumper::Dumper($params{save}), $statefile);
  } else {
    $self->add_message(UNKNOWN,
        sprintf "cannot write status file %s! check your filesystem (permissions/usage/integrity) and disk devices", $statefile);
  }
}

sub load_state {
  my $self = shift;
  my %params = @_;
  my $statefile = $self->create_statefile(%params);
  if ( -f $statefile) {
    our $VAR1;
    eval {
      require $statefile;
    };
    if($@) {
      printf "rumms\n";
    }
    $self->debug(sprintf "load %s", Data::Dumper::Dumper($VAR1));
    return $VAR1;
  } else { 
    return undef;
  }
}

sub create_interface_cache_file {
  my $self = shift;
  my $extension = "";
  if ($self->opts->snmpwalk && ! $self->opts->hostname) {
    $self->opts->override_opt('hostname',
        'snmpwalk.file'.md5_hex($self->opts->snmpwalk))
  }
  if ($self->opts->community) { 
    $extension .= md5_hex($self->opts->community);
  }
  $extension =~ s/\//_/g;
  $extension =~ s/\(/_/g;
  $extension =~ s/\)/_/g;
  $extension =~ s/\*/_/g;
  $extension =~ s/\s/_/g;
  return sprintf "%s/%s_interface_cache_%s", $NWC::Device::statefilesdir,
      $self->opts->hostname, lc $extension;
}

sub dumper {
  my $self = shift;
  my $object = shift;
  my $run = $object->{runtime};
  delete $object->{runtime};
  printf STDERR "%s\n", Data::Dumper::Dumper($object);
  $object->{runtime} = $run;
}

sub no_such_mode {
  my $self = shift;
  my %params = @_;
  printf "Mode %s is not implemented for this type of device\n",
      $self->opts->mode;
  exit 0;
}

# get_cached_table_entries
#   get_table nur die table-basoid
#   mit liste von indices
#     get_entries -startindex x -endindex x konsekutive indices oder einzeln

sub get_table_entries {
  my $self = shift;
  my $mib = shift;
  my $table = shift;
  my $elements = shift;
  my $oids = {};
  my $entry;
  if (exists $NWC::Device::mibs_and_oids->{$mib} &&
      exists $NWC::Device::mibs_and_oids->{$mib}->{$table}) {
    foreach my $key (keys %{$NWC::Device::mibs_and_oids->{$mib}}) {
      if ($NWC::Device::mibs_and_oids->{$mib}->{$key} =~
          /^$NWC::Device::mibs_and_oids->{$mib}->{$table}/) {
        $oids->{$key} = $NWC::Device::mibs_and_oids->{$mib}->{$key};
      }
    }
  }
  ($entry = $table) =~ s/Table/Entry/g;
  return $self->get_entries($oids, $entry);
}


sub xget_entries {
  my $self = shift;
  my $oids = shift;
  my $entry = shift;
  my $fallback = shift;
  my @params = ();
  my @indices = $self->get_indices($oids->{$entry});
  foreach (@indices) {
    my @idx = @{$_};
    my %params = ();
    my $maxdimension = scalar(@idx) - 1;
    foreach my $idxnr (1..scalar(@idx)) {
      $params{'index'.$idxnr} = $_->[$idxnr - 1];
    }
    foreach my $oid (keys %{$oids}) {
      next if $oid =~ /Table$/;
      next if $oid =~ /Entry$/;
      # there may be scalar oids ciscoEnvMonTemperatureStatusValue = curr. temp.
      next if ($oid =~ /Value$/ && ref ($oids->{$oid}) eq 'HASH');
      if (exists $oids->{$oid.'Value'}) {
        $params{$oid} = $self->get_object_value(
            $oids->{$oid}, $oids->{$oid.'Value'}, @idx);
      } else {
        $params{$oid} = $self->get_object($oids->{$oid}, @idx);
      }
    }     
    push(@params, \%params);
  }
  if (! $fallback && scalar(@params) == 0) {
    if ($NWC::Device::session) {
      my $table = $entry;
      $table =~ s/(.*)\.\d+$/$1/;
      my $result = $self->get_table(
          -baseoid => $oids->{$table}
      );
      if ($result) {
        foreach my $key (keys %{$result}) {
          $self->add_rawdata($key, $result->{$key});
        }
        @params = $self->get_entries($oids, $entry, 1);
      }
      #printf "%s\n", Data::Dumper::Dumper($result);
    }
  }
  return @params;
}

sub get_indices {
  my $self = shift;
  my %params = @_;
  # -baseoid : entry
  # find all oids beginning with $entry
  # then skip one field for the sequence
  # then read the next numindices fields
  my $entrypat = $params{'-baseoid'};
  $entrypat =~ s/\./\\\./g;
  my @indices = map {
      /^$entrypat\.\d+\.(.*)/ && $1;
  } grep {
      /^$entrypat/
  } keys %{$NWC::Device::rawdata};
  my %seen = ();
  my @o = map {[split /\./]} sort grep !$seen{$_}++, @indices;
  return @o;
}

sub get_size {
  my $self = shift;
  my $entry = shift;
  my $entrypat = $entry;
  $entrypat =~ s/\./\\\./g;
  my @entries = grep {
      /^$entrypat/
  } keys %{$NWC::Device::rawdata};
  return scalar(@entries);
}

sub get_object {
  my $self = shift;
  my $object = shift;
  my @indices = @_;
  #my $oid = $object.'.'.join('.', @indices);
  my $oid = $object;
  $oid .= '.'.join('.', @indices) if (@indices);
  return $NWC::Device::rawdata->{$oid};
}

sub get_object_value {
  my $self = shift;
  my $object = shift;
  my $values = shift;
  my @indices = @_;
  my $key = $self->get_object($object, @indices);
  if (defined $key) {
    return $values->{$key};
  } else {
    return undef;
  }
}

#SNMP::Utils::counter([$idxs1, $idxs2], $idx1, $idx2),
# this flattens a n-dimensional array and returns the absolute position
# of the element at position idx1,idx2,...,idxn
# element 1,2 in table 0,0 0,1 0,2 1,0 1,1 1,2 2,0 2,1 2,2 is at pos 6
sub get_number {
  my $self = shift;
  my $indexlists = shift; #, zeiger auf array aus [1, 2]
  my @element = @_;
  my $dimensions = scalar(@{$indexlists->[0]});
  my @sorted = ();
  my $number = 0;
  if ($dimensions == 1) {
    @sorted =
        sort { $a->[0] <=> $b->[0] } @{$indexlists};
  } elsif ($dimensions == 2) {
    @sorted =
        sort { $a->[0] <=> $b->[0] || $a->[1] <=> $b->[1] } @{$indexlists};
  } elsif ($dimensions == 3) {
    @sorted =
        sort { $a->[0] <=> $b->[0] ||
               $a->[1] <=> $b->[1] ||
               $a->[2] <=> $b->[2] } @{$indexlists};
  }
  foreach (@sorted) {
    if ($dimensions == 1) {
      if ($_->[0] == $element[0]) {
        last;
      }
    } elsif ($dimensions == 2) {
      if ($_->[0] == $element[0] && $_->[1] == $element[1]) {
        last;
      }
    } elsif ($dimensions == 3) {
      if ($_->[0] == $element[0] &&
          $_->[1] == $element[1] &&
          $_->[2] == $element[2]) {
        last;
      }
    }
    $number++;
  }
  return ++$number;
}

sub mib {
  my $self = shift;
  my $mib = shift;
  my $condition = {
      0 => 'other',
      1 => 'ok',
      2 => 'degraded',
      3 => 'failed',
  };
  my $MibRevMajor = $mib.'.1.0';
  my $MibRevMinor = $mib.'.2.0';
  my $MibRevCondition = $mib.'.3.0';
  return (
      $self->SNMP::Utils::get_object($MibRevMajor),
      $self->SNMP::Utils::get_object($MibRevMinor),
      $self->SNMP::Utils::get_object_value($MibRevCondition, $condition));
};

sub update_entry_cache {
  my $self = shift;
  my $force = shift;
  my $mib = shift;
  my $table = shift;
  my $key_attr = shift;
  if (ref($key_attr) ne "ARRAY") {
    $key_attr = [$key_attr];
  }
  my $cache = sprintf "%s_%s_%s_cache", 
      $mib, $table, join('#', @{$key_attr});
  my $statefile = lc sprintf "%s/%s_%s_%s-%s_%s_cache",
      $NWC::Device::statefilesdir, $self->opts->hostname,
      $self->opts->mode, $mib, $table, join('#', @{$key_attr});
  my $update = time - 3600;
  #my $update = time - 1;
  if ($force || ! -f $statefile || ((stat $statefile)[9]) < ($update)) {
    $self->debug(sprintf 'force update of %s %s %s %s cache',
        $self->opts->hostname, $self->opts->mode, $mib, $table);
    $self->{$cache} = {};
    foreach my $entry ($self->get_snmp_table_objects($mib, $table)) {
      my $key = join('#', map { $entry->{$_} } @{$key_attr});
      my $hash = $key . '-//-' . join('.', @{$entry->{indices}});
      $self->{$cache}->{$hash} = $entry->{indices};
    }
    $self->save_cache($mib, $table, $key_attr);
  }
  $self->load_cache($mib, $table, $key_attr);
}

#  $self->update_entry_cache(0, $mib, $table, $key_attr);
#  my @indices = $self->get_cache_indices();
sub get_cache_indices {
  my $self = shift;
  my $mib = shift;
  my $table = shift;
  my $key_attr = shift;
  if (ref($key_attr) ne "ARRAY") {
    $key_attr = [$key_attr];
  }
  my $cache = sprintf "%s_%s_%s_cache", 
      $mib, $table, join('#', @{$key_attr});
  my @indices = ();
  foreach my $key (keys %{$self->{$cache}}) {
    my ($descr, $index) = split('-//-', $key, 2);
    if ($self->opts->name) {
      if ($self->opts->regexp) {
        my $pattern = $self->opts->name;
        if ($descr =~ /$pattern/i) {
          push(@indices, $self->{$cache}->{$key});
        }
      } else {
        if ($self->opts->name =~ /^\d+$/) {
          if ($index == 1 * $self->opts->name) {
            push(@indices, [1 * $self->opts->name]);
          }
        } else {
          if (lc $descr eq lc $self->opts->name) {
            push(@indices, $self->{$cache}->{$key});
          }
        }
      }
    } else {
      push(@indices, $self->{$cache}->{$key});
    }
  }
  return @indices;
  return map { join('.', ref($_) eq "ARRAY" ? @{$_} : $_) } @indices;
}

sub save_cache {
  my $self = shift;
  my $mib = shift;
  my $table = shift;
  my $key_attr = shift;
  if (ref($key_attr) ne "ARRAY") {
    $key_attr = [$key_attr];
  }
  $self->create_statefilesdir();
  my $cache = sprintf "%s_%s_%s_cache", 
      $mib, $table, join('#', @{$key_attr});
  my $statefile = lc sprintf "%s/%s_%s_%s-%s_%s_cache",
      $NWC::Device::statefilesdir, $self->opts->hostname,
      $self->opts->mode, $mib, $table, join('#', @{$key_attr});
  open(STATE, ">".$statefile.".".$$);
  printf STATE Data::Dumper::Dumper($self->{$cache});
  close STATE;
  rename $statefile.".".$$, $statefile;
  $self->debug(sprintf "saved %s to %s",
      Data::Dumper::Dumper($self->{$cache}), $statefile);
}

sub load_cache {
  my $self = shift;
  my $mib = shift;
  my $table = shift;
  my $key_attr = shift;
  if (ref($key_attr) ne "ARRAY") {
    $key_attr = [$key_attr];
  }
  my $cache = sprintf "%s_%s_%s_cache", 
      $mib, $table, join('#', @{$key_attr});
  my $statefile = lc sprintf "%s/%s_%s_%s-%s_%s_cache",
      $NWC::Device::statefilesdir, $self->opts->hostname,
      $self->opts->mode, $mib, $table, join('#', @{$key_attr});
  $self->{$cache} = {};
  if ( -f $statefile) {
    our $VAR1;
    our $VAR2;
    eval {
      require $statefile;
    };
    if($@) {
      printf "rumms\n";
    }
    # keinesfalls mehr require verwenden!!!!!!
    # beim require enthaelt VAR1 andere werte als beim slurp
    # und zwar diejenigen, die beim letzten save_cache geschrieben wurden.
    my $content = do { local (@ARGV, $/) = $statefile; my $x = <>; close ARGV; $x };
    $VAR1 = eval "$content";
    $self->debug(sprintf "load %s", Data::Dumper::Dumper($VAR1));
    $self->{$cache} = $VAR1;
  }
}

sub check_pidfile {
  my $self = shift;
  my $fh = new IO::File;
  if ($fh->open($self->{pidfile}, "r")) {
    my $pid = $fh->getline();
    $fh->close();
    if (! $pid) {
      $self->debug("Found pidfile %s with no valid pid. Exiting.",
          $self->{pidfile});
      return 0;
    } else {
      $self->debug("Found pidfile %s with pid %d", $self->{pidfile}, $pid);
      kill 0, $pid;
      if ($! == Errno::ESRCH) {
        $self->debug("This pidfile is stale. Writing a new one");
        $self->write_pidfile();
        return 1;
      } else {
        $self->debug("This pidfile is held by a running process. Exiting");
        return 0;
      }
    }
  } else {
    $self->debug("Found no pidfile. Writing a new one");
    $self->write_pidfile();
    return 1;
  }
}

sub write_pidfile {
  my $self = shift;
  if (! -d dirname($self->{pidfile})) {
    eval "require File::Path;";
    if (defined(&File::Path::mkpath)) {
      import File::Path;
      eval { mkpath(dirname($self->{pidfile})); };
    } else {
      my @dirs = ();
      map {
          push @dirs, $_;
          mkdir(join('/', @dirs))
              if join('/', @dirs) && ! -d join('/', @dirs);
      } split(/\//, dirname($self->{pidfile}));
    }
  }
  my $fh = new IO::File;
  $fh->autoflush(1);
  if ($fh->open($self->{pidfile}, "w")) {
    $fh->printf("%s", $$);
    $fh->close();
  } else {
    $self->debug("Could not write pidfile %s", $self->{pidfile});
    die "pid file could not be written";
  }
}

sub analyze_interface_subsystem {
  my $self = shift;
  $self->{components}->{interface_subsystem} =
      NWC::IFMIB::Component::InterfaceSubsystem->new();
}

sub shinken_interface_subsystem {
  my $self = shift;
  my $attr = sprintf "%s", join(',', map {
      sprintf '%s$(%s)$$()$', $_->{ifDescr}, $_->{ifIndex}
  } @{$self->{components}->{interface_subsystem}->{interfaces}});
  printf <<'EOEO', $self->opts->hostname(), $self->opts->hostname(), $attr;
define host {
  host_name                     %s
  address                       %s
  use                           default-host
  _interfaces                   %s

}
EOEO
  printf <<'EOEO', $self->opts->hostname();
define service {
  host_name                     %s
  service_description           net_cpu
  check_command                 check_nwc_health!cpu-load!80%%!90%%
}
EOEO
  printf <<'EOEO', $self->opts->hostname();
define service {
  host_name                     %s
  service_description           net_mem
  check_command                 check_nwc_health!memory-usage!80%%!90%%
}
EOEO
  printf <<'EOEO', $self->opts->hostname();
define service {
  host_name                     %s
  service_description           net_ifusage_$KEY$
  check_command                 check_nwc_health!interface-usage!$VALUE1$!$VALUE2$
  duplicate_foreach             _interfaces
  default_value                 80%%|90%%
}
EOEO
}



sub AUTOLOAD {
  my $self = shift;
  return if ($AUTOLOAD =~ /DESTROY/);    
  if ($AUTOLOAD =~ /^(.*)::check_(.*)_subsystem$/) {
    my $class = $1;
    my $subsystem = sprintf "%s_subsystem", $2;
    $self->{components}->{$subsystem}->check();
    $self->{components}->{$subsystem}->dump()
        if $self->opts->verbose >= 2;
  }
}

package main;
#! /usr/local/bin/perl

use strict;
use Digest::MD5 qw(md5_hex);;

use vars qw ($PROGNAME $REVISION $CONTACT $TIMEOUT $STATEFILESDIR $needs_restart %commandline);

$PROGNAME = "check_nwc_health";
$REVISION = '$Revision: 2.5.1.2 $';
$CONTACT = 'gerhard.lausser@consol.de';
$TIMEOUT = 60;
$STATEFILESDIR = '/var/tmp/check_nwc_health';

use constant OK         => 0;
use constant WARNING    => 1;
use constant CRITICAL   => 2;
use constant UNKNOWN    => 3;
use constant DEPENDENT  => 4;

my @modes = (
  ['device::uptime',
      'uptime', undef,
      'Check the uptime of the device' ],
  ['device::hardware::health',
      'hardware-health', undef,
      'Check the status of environmental equipment (fans, temperatures, power)' ],
  ['device::hardware::load',
      'cpu-load', ['cpu-usage'],
      'Check the CPU load of the device' ],
  ['device::hardware::memory',
      'memory-usage', undef,
      'Check the memory usage of the device' ],
#  ['device::interfaces::traffic',
#      'interface-traffic', undef,
#      'Check the in- and outgoing traffic on interfaces' ],
  ['device::interfaces::usage',
      'interface-usage', undef,
      'Check the utilization of interfaces' ],
  ['device::interfaces::errors',
      'interface-errors', undef,
      'Check the error-rate of interfaces (errors+discards per sec)' ],
  ['device::interfaces::operstatus',
      'interface-status', undef,
      'Check the status of interfaces' ],
  ['device::interfaces::list',
      'list-interfaces', undef,
      'Show the interfaces of the device and update the name cache' ],
  ['device::interfaces::listdetail',
      'list-interfaces-detail', undef,
      'Show the interfaces of the device and some details' ],
  ['device::interfaces::availability',
      'interface-availability', undef,
      'Show the availability (oper != up) of interfaces' ],
  ['device::interfaces::aggregation::availability',
      'link-aggregation-availability', undef,
      'Check the percentage of up interfaces in a link aggregation' ],
  ['device::shinken::interface',
      'create-shinken-service', undef,
      'Create a Shinken service definition' ],
  ['device::hsrp::state',
      'hsrp-state', undef,
      'Check the state in a HSRP group' ],
  ['device::hsrp::failover',
      'hsrp-failover', undef,
      'Check if a HSRP group\'s nodes have changed their roles' ],
  ['device::hsrp::list',
      'list-hsrp-groups', undef,
      'Show the HSRP groups configured on this device' ],
  ['device::ha::role',
      'ha-role', undef,
      'Check the role in a ha group' ],
  ['device::svn::status',
      'svn-status', undef,
      'Check the status of the svn subsystem' ],
  ['device::mngmt::status',
      'mngmt-status', undef,
      'Check the status of the management subsystem' ],
  ['device::fw::policy::installed',
      'fw-policy', undef,
      'Check the installed firewall policy' ],
  ['device::fw::policy::connections',
      'fw-connections', undef,
      'Check the number of firewall policy connections' ],
  ['device::lb::pool::completeness',
      'pool-completeness', undef,
      'Check the members of a load balancer pool' ],
  ['device::security',
      'security-status', undef,
      'Check if there are security-relevant incidents' ],
  ['device::lb::pool::list',
      'list-pools', undef,
      'List load balancer pools' ],
  ['device::licenses::validate',
      'check-licenses', undef,
      'Check the installed licences/keys' ],
  ['device::users::count',
      'count-users', ['count-sessions', 'count-connections'],
      'Count the (connected) users/sessions' ],
  ['device::connections::check',
      'check-connections', undef,
      'Check the quality of connections' ],
  ['device::wlan::aps::status',
      'accesspoint-status', undef,
      'Check the status of access points' ],
  ['device::wlan::aps::count',
      'count-accesspoints', undef,
      'Check if the number of access points is within a certain range' ],
  ['device::wlan::aps::watch',
      'watch-accesspoints', undef,
      'Check if access points appear and disappear (use --lookup)' ],
  ['device::wlan::aps::list',
      'list-accesspoints', undef,
      'List access points managed by this device' ],
  ['device::smarthome::device::list',
      'list-smart-home-devices', undef,
      'List Fritz!DECT 200 plugs managed by this device' ],
  ['device::smarthome::device::status',
      'smart-home-device-status', undef,
      'Check if a Fritz!DECT 200 plug is on' ],
  ['device::smarthome::device::energy',
      'smart-home-device-energy', undef,
      'Show the current power consumption of a Fritz!DECT 200 plug' ],
  ['device::smarthome::device::consumption',
      'smart-home-device-consumption', undef,
      'Show the cumulated power consumption of a Fritz!DECT 200 plug' ],
  ['device::walk',
      'walk', undef,
      'Show snmpwalk command with the oids necessary for a simulation' ],
  # todo device::modules::{filtering,management,ha,svn}
);
my $modestring = "";
my $longest = length ((reverse sort {length $a <=> length $b} map { $_->[1] } @modes)[0]);
my $format = "       %-".
  (length ((reverse sort {length $a <=> length $b} map { $_->[1] } @modes)[0])).
  "s\t(%s)\n";
foreach (@modes) {
  $modestring .= sprintf $format, $_->[1], $_->[3];
}
$modestring .= sprintf "\n";


my $plugin = Nagios::MiniPlugin->new(
    shortname => '',
    usage => 'Usage: %s [ -v|--verbose ] [ -t <timeout> ] '.
        '--mode <what-to-do> '.
        '--hostname <network-component> --community <snmp-community>'.
        '  ...]',
    version => $REVISION,
    blurb => 'This plugin checks various parameters of network components ',
    url => 'http://labs.consol.de/nagios/check_nwc_health',
    timeout => 60,
    shortname => '',
);
$plugin->add_arg(
    spec => 'blacklist|b=s',
    help => '--blacklist
   Blacklist some (missing/failed) components',
    required => 0,
    default => '',
);
#$plugin->add_arg(
#    spec => 'customthresholds|c=s',
#    help => '--customthresholds
#   Use custom thresholds for certain temperatures',
#    required => 0,
#);
#$plugin->add_arg(
#    spec => 'perfdata=s',
#    help => '--perfdata=[short]
#   Output performance data. If your performance data string becomes
#   too long and is truncated by Nagios, then you can use --perfdata=short
#   instead. This will output temperature tags without location information',
#    required => 0,
#);
$plugin->add_arg(
    spec => 'hostname|H=s',
    help => '--hostname
   Hostname or IP-address of the switch or router',
    required => 0,
);
$plugin->add_arg(
    spec => 'port=i',
    help => '--port
   The SNMP port to use (default: 161)',
    required => 0,
    default => 161,
);
$plugin->add_arg(
    spec => 'domain=s',
    help => '--domain
   The transport domain to use (default: udp/ipv4, other possible values: udp6, udp/ipv6, tcp, tcp4, tcp/ipv4, tcp6, tcp/ipv6)',
    required => 0,
    default => 'udp',
);
$plugin->add_arg(
    spec => 'protocol|P=s',
    help => '--protocol
   The SNMP protocol to use (default: 2c, other possibilities: 1,3)',
    required => 0,
    default => '2c',
);
$plugin->add_arg(
    spec => 'community|C=s',
    help => '--community
   SNMP community of the server (SNMP v1/2 only)',
    required => 0,
    default => 'public',
);
$plugin->add_arg(
    spec => 'username=s',
    help => '--username
   The securityName for the USM security model (SNMPv3 only)',
    required => 0,
);
$plugin->add_arg(
    spec => 'authpassword=s',
    help => '--authpassword
   The authentication password for SNMPv3',
    required => 0,
);
$plugin->add_arg(
    spec => 'authprotocol=s',
    help => '--authprotocol
   The authentication protocol for SNMPv3 (md5|sha)',
    required => 0,
);
$plugin->add_arg(
    spec => 'privpassword=s',
    help => '--privpassword
   The password for authPriv security level',
    required => 0,
);
$plugin->add_arg(
    spec => 'privprotocol=s',
    help => '--privprotocol
   The private protocol for SNMPv3 (des|aes|aes128|3des|3desde)',
    required => 0,
);
$plugin->add_arg(
    spec => 'warning=s',
    help => '--warning
   The warning threshold',
    required => 0,
);
$plugin->add_arg(
    spec => 'mode=s',
    help => "--mode
   A keyword which tells the plugin what to do
$modestring",
    required => 1,
);
$plugin->add_arg(
    spec => 'name=s',
    help => "--name
   The name of an interface (ifDescr)",
    required => 0,
);
$plugin->add_arg(
    spec => 'alias=s',
    help => "--alias
   The alias name of a 64bit-interface (ifAlias)",
    required => 0,
);
$plugin->add_arg(
    spec => 'regexp',
    help => "--regexp
   A flag indicating that --name is a regular expression",
    required => 0,
);
$plugin->add_arg(
    spec => 'ifspeedin=i',
    help => "--ifspeedin
   Override the ifspeed oid of an interface (only inbound)",
    required => 0,
);
$plugin->add_arg(
    spec => 'ifspeedout=i',
    help => "--ifspeedout
   Override the ifspeed oid of an interface (only outbound)",
    required => 0,
);
$plugin->add_arg(
    spec => 'ifspeed=i',
    help => "--ifspeed
   Override the ifspeed oid of an interface",
    required => 0,
);
$plugin->add_arg(
    spec => 'units=s',
    help => "--units
   One of %, B, KB, MB, GB, Bit, KBi, MBi, GBi. (used for e.g. mode interface-usage)",
    required => 0,
);
$plugin->add_arg(
    spec => 'role=s',
    help => "--role
   The role of this device in a hsrp group (active/standby/listen)",
    required => 0,
);
$plugin->add_arg(
    spec => 'report=s',
    help => "--report
   Can be used to shorten the output",
    required => 0,
    default => 'long',
);
$plugin->add_arg(
    spec => 'lookback=s',
    help => "--lookback
   The amount of time you want to look back when calculating average rates.
   Use it for mode interface-errors or interface-usage. Without --lookback
   the time between two runs of check_nwc_health is the base for calculations.
   If you want your checkresult to be based for example on the past hour,
   use --lookback 3600. ",
    required => 0,
);
$plugin->add_arg(
    spec => 'critical=s',
    help => '--critical
   The critical threshold',
    required => 0,
);
$plugin->add_arg(
    spec => 'mitigation=s',
    help => "--mitigation
   The parameter allows you to change a critical error to a warning.",
    required => 0,
);
$plugin->add_arg(
    spec => 'servertype=s',
    help => '--servertype
   The type of the network device: cisco (default). Use it if auto-detection
   is not possible',
    required => 0,
);
$plugin->add_arg(
    spec => 'statefilesdir=s',
    help => '--statefilesdir
   An alternate directory where the plugin can save files',
    required => 0,
);
$plugin->add_arg(
    spec => 'snmpwalk=s',
    help => '--snmpwalk
   A file with the output of a snmpwalk (used for simulation)
   Use it instead of --hostname',
    required => 0,
);
$plugin->add_arg(
    spec => 'oids=s',
    help => '--oids
   A list of oids which are downloaded and written to a cache file.
   Use it together with --mode oidcache',
    required => 0,
);
$plugin->add_arg(
    spec => 'offline:i',
    help => '--offline
   The maximum number of seconds since the last update of cache file before
   it is considered too old',
    required => 0,
);
$plugin->add_arg(
    spec => 'multiline',
    help => '--multiline
   Multiline output',
    required => 0,
);

$plugin->getopts();
if ($plugin->opts->multiline) {
  $ENV{NRPE_MULTILINESUPPORT} = 1;
} else {
  $ENV{NRPE_MULTILINESUPPORT} = 0;
}
if ($plugin->opts->community) {
  if ($plugin->opts->community =~ /^snmpv3(.)(.+)/) {
    my $separator = $1;
    my ($authprotocol, $authpassword, $privprotocol, $privpassword, $username) =
        split(/$separator/, $2);
    $plugin->override_opt('authprotocol', $authprotocol) 
        if defined($authprotocol) && $authprotocol;
    $plugin->override_opt('authpassword', $authpassword) 
        if defined($authpassword) && $authpassword;
    $plugin->override_opt('privprotocol', $privprotocol) 
        if defined($privprotocol) && $privprotocol;
    $plugin->override_opt('privpassword', $privpassword) 
        if defined($privpassword) && $privpassword;
    $plugin->override_opt('username', $username) 
        if defined($username) && $username;
    $plugin->override_opt('protocol', '3') ;
  }
}
if ($plugin->opts->mode eq 'walk') {
  if ($plugin->opts->snmpwalk && $plugin->opts->hostname) {
    # snmp agent wird abgefragt, die ergebnisse landen in einem file
    # opts->snmpwalk ist der filename. da sich die ganzen get_snmp_table/object-aufrufe
    # an das walkfile statt an den agenten halten wuerden, muss opts->snmpwalk geloescht
    # werden. stattdessen wird opts->snmpdump als traeger des dateinamens mitgegeben.
    # nur sinnvoll mit mode=walk
    $plugin->create_opt('snmpdump');
    $plugin->override_opt('snmpdump', $plugin->opts->snmpwalk);
    $plugin->override_opt('snmpwalk', undef);
  } elsif (! $plugin->opts->snmpwalk && $plugin->opts->hostname && $plugin->opts->mode eq 'walk') {
    # snmp agent wird abgefragt, die ergebnisse landen in einem file, dessen name
    # nicht vorgegeben ist
    $plugin->create_opt('snmpdump');
  }
} else {
  if (exists $ENV{NAGIOS__HOSTSNMPWALK} || exists $ENV{NAGIOS__SERVICESNMPWALK}) {
    $plugin->override_opt('snmpwalk', $ENV{NAGIOS__SERVICESNMPWALK} || $ENV{NAGIOS__HOSTSNMPWALK});
    $plugin->override_opt('offline', $ENV{NAGIOS__SERVICEOFFLINE} || $ENV{NAGIOS__HOSTOFFLIN});
  }
  if ($plugin->opts->snmpwalk && ! $plugin->opts->hostname) {
    # normaler aufruf, mode != walk, oid-quelle ist eine datei
    $plugin->override_opt('hostname', 'snmpwalk.file'.md5_hex($plugin->opts->snmpwalk)) 
  } elsif ($plugin->opts->snmpwalk && $plugin->opts->hostname) {
    # snmpwalk hat vorrang
    $plugin->override_opt('hostname', undef);
  }
}

if ($plugin->opts->snmpwalk && $plugin->opts->hostname && $plugin->opts->mode eq 'walk') {
}
if (! $plugin->opts->statefilesdir) {
  if (exists $ENV{OMD_ROOT}) {
    $plugin->override_opt('statefilesdir', $ENV{OMD_ROOT}."/var/tmp/check_nwc_health");
  } else {
    $plugin->override_opt('statefilesdir', $STATEFILESDIR);
  }
}


$plugin->{messages}->{unknown} = []; # wg. add_message(UNKNOWN,...)

$plugin->{info} = []; # gefrickel

if ($plugin->opts->mode =~ /^my-([^\-.]+)/) {
  my $param = $plugin->opts->mode;
  $param =~ s/\-/::/g;
  push(@modes, [$param, $plugin->opts->mode, undef, 'my extension']);
} elsif ($plugin->opts->mode eq 'encode') {
  my $input = <>;
  chomp $input;
  $input =~ s/([^A-Za-z0-9])/sprintf("%%%02X", ord($1))/seg;
  printf "%s\n", $input;
  exit 0;
} elsif ((! grep { $plugin->opts->mode eq $_ } map { $_->[1] } @modes) &&
    (! grep { $plugin->opts->mode eq $_ } map { defined $_->[2] ? @{$_->[2]} : () } @modes)) {
  printf "UNKNOWN - mode %s\n", $plugin->opts->mode;
  $plugin->opts->print_help();
  exit 3;
}
if ($plugin->opts->name && $plugin->opts->name =~ /(%22)|(%27)/) {
  my $name = $plugin->opts->name;
  $name =~ s/\%([A-Fa-f0-9]{2})/pack('C', hex($1))/seg;
  $plugin->override_opt('name', $name);
}

$SIG{'ALRM'} = sub {
  printf "UNKNOWN - check_nwc_health timed out after %d seconds\n", 
      $plugin->opts->timeout;
  exit $ERRORS{UNKNOWN};
};
alarm($plugin->opts->timeout);

$NWC::Device::plugin = $plugin;
$NWC::Device::mode = (
    map { $_->[0] }
    grep {
       ($plugin->opts->mode eq $_->[1]) ||
       ( defined $_->[2] && grep { $plugin->opts->mode eq $_ } @{$_->[2]})
    } @modes
)[0];
my $server = NWC::Device->new( runtime => {

    plugin => $plugin,
    options => {
        servertype => $plugin->opts->servertype,
        verbose => $plugin->opts->verbose,
        customthresholds => $plugin->opts->get('customthresholds'),
        blacklist => $plugin->opts->blacklist,
#        celsius => $CELSIUS,
#        perfdata => $PERFDATA,
#        extendedinfo => $EXTENDEDINFO,
#        hwinfo => $HWINFO,
#        noinstlevel => $NOINSTLEVEL,
    },
},);
#$server->dumper();
if (! $plugin->check_messages()) {
  $server->init();
  if (! $plugin->check_messages()) {
    $plugin->add_message(OK, $server->get_summary()) 
        if $server->get_summary();
    $plugin->add_message(OK, $server->get_extendedinfo()) 
        if $server->get_extendedinfo();
  } 
} elsif ($plugin->opts->snmpwalk && $plugin->opts->offline) {
  ;
} else {
  $plugin->add_message(CRITICAL, 'wrong device');
}
my ($code, $message) = $plugin->opts->multiline ? 
    $plugin->check_messages(join => "\n", join_all => ', ') :
    $plugin->check_messages(join => ', ', join_all => ', ');
$message .= sprintf "\n%s\n", join("\n", @{$NWC::Device::info})
    if $plugin->opts->verbose >= 1;
#printf "%s\n", Data::Dumper::Dumper($plugin->{info});
$plugin->nagios_exit($code, $message);

