#!/bin/env python26

import urllib2
from BeautifulSoup import BeautifulSoup
import sys
import os
import time
import datetime

from optparse import OptionParser

# Default Nagios Exit Codes
EXIT_OK = 0
EXIT_WARN = 1
EXIT_CRIT = 2
EXIT_UNK = 3

#Predefined Timeout Variable
TimeOut = 60

def pretty_time_format(time_value):
    # Function to print time in human readable format
    pretty_time = time.strftime('%Y-%m-%d %H:%M:%S',time.localtime(time_value))
    return pretty_time

def chose_table(arr, tag, keyword):
    """Function accepts list of records generated by BeautifulSoup.findAll method.
	   Second parameter HTML tag used for parsing.
	   Third parameter exact name to exclude"""

    for i in xrange(len(arr)):
        tmp = arr[i].findAll(tag)
        if keyword not in tmp:
            result = arr[i]

    return result

def remove_table_headers(arr, tag='th'):
    tmp = []
    if options.verbose:
        print ">>> DEBUG : Function 'Remove_Table_headers' is called "
    for i in xrange(len(arr)):
        if arr[i].findAll(tag):
            tmp.append(i)
    if tmp:
        for i in tmp:
            del arr[i]
    return arr


def get_events_list(arr, event_type, host_event, tag='td'):
    """ Function selects events from list. 
        Passed list is divided into table records using specified tag.(tag parameterr)
        Only events of "event_type" and for host_event are choosen."""

    tmp_arr = []
    for i in xrange(len(arr)):
        tmp_host = arr[i].findAll(tag)[5].text
        tmp_event = arr[i].findAll(tag)[4].text
        if tmp_host == host_event and tmp_event == event_type:
            tmp_arr.append(arr[i])

    return tmp_arr

def get_file_exist(filename):
    """Function checks if filename exists"""
    if (os.path.exists(os.path.abspath(filename))):
        if options.verbose:
            print "File %s exists " % (os.path.abspath(filename))
        return True
    else:
        if options.verbose:
            print "File %s does not exist" % (os.path.abspath(filename))
        print "Might be 1st run"
        return False

def read_data_from_file(filename):
    """
        Trying to  open file for reading.
        If successfully - returns previous counter's value and previous timestamp.
    """

    try:
        fileid = open(filename, 'r' )
    except (IOError, EOFError), err:
        print "Error Opening File".center(80, '-')
        print ("Type: %s\nValue: %s\nError: %s" % (sys.exc_info())) if options.verbose else ("Error Message: %s" % err)
        print "Error Opening File".center(80, '-')
        print "UNKNOWN. Cannot open file %s for reading" % filename
        sys.exit(EXIT_UNK)
    else:
        read_values = fileid.readlines()
        if len(read_values) == 0:
            print "No Data read from file"
            print "Assuming 1st run. Assigning 0(zero) for counter's value variable"
            event_read = event_from_page
            event_time = str(time_from_page)
        else:
            event_read = int(read_values[0].splitlines()[0])
            event_time = read_values[1].splitlines()[0]
        fileid.close()
        return event_read, event_time 

def store_data_to_file(filename, counter_value, timestamp):
    """Storing data to file"""
    try:
        fileid = open(filename, 'w' )
    except IOError, err:
        print "Error Opening File For Data Storing".center(80, '-')
        print ("Type: %s\nValue: %s\nError: %s" % (sys.exc_info())) if options.verbose else ("Error Message: %s" % err)
        print "Error Opening File For Data Storing".center(80, '-')
        print "UNKNOWN. Cannot open file %s for data storing" % filename
        sys.exit(EXIT_UNK)
    else:
        fileid.writelines(str(counter_value) + '\n')
        fileid.writelines(str(timestamp) + '\n')
        fileid.close()

# Dictitonary with daeamon's name and port
# apache was added for testing purposes
daemon_list = {'publisher':10181, 'packager':10180, 'apache':80}

# Dictionary with Daemon's name and Application
application_list = {'publisher':'merlin_publisher', 'packager':'merlin_packager'}


parser = OptionParser()

parser.add_option("-H", "--host", dest="host",
                        help="Hostname where to look for counters")
parser.add_option("-d", "--daemon", dest="daemon",
                        help="Daemon's name. Could be either \"publisher\" or \"packager\"")
parser.add_option("-e", "--event", dest="event",
                        help="Event type to look for. Supported \"app_startup\" or \"app_shutdown\"")
parser.add_option("-v", "--verbose", action="store_true", dest="verbose",
                        default=False, help="Verbose output")
parser.add_option("-N", "--node-events", dest="nodeevents", default="/node_events",
                        help="Page where node-events table is located. Default : node_events")
parser.add_option("-w", "--warning", type="int", dest="warning", default=0,
                        help="Warning threshold. Default = 0.")
parser.add_option("-c", "--critical", type="int", dest="critical", default=0,
                        help="Critical threshold. Default = 0.")

options, args = parser.parse_args()

if options.daemon not in sorted(daemon_list.keys()):
    print "Supported daemon are %s" % ','.join(i for i in sorted(daemon_list.keys()))
    print "UNKNOWN. Not supported method %s " % options.daemon
    sys.exit(EXIT_UNK)

if options.host == '' or options.host == None\
    or options.event == '' or options.event == None:
    print "UNKNOWN.Options Hostname and Event type are mandatory"
    sys.exit(EXIT_UNK)

if options.event != 'app_startup' and options.event != 'app_shutdown':
    print "Unknown event %s " % options.event
    sys.exit(EXIT_UNK)

if not options.nodeevents.startswith('/'):
    options.nodeevents = '/' + options.nodeevents

# Generating file name
filename = os.path.join('/tmp', (os.path.splitext(os.path.split(sys.argv[0])[1])[0]  + '-' + options.host + '-' + options.daemon + '-' +options.event + '.txt'))

if options.verbose:
    print "Generated Filename is :: %s " % filename

url = "http://" + options.host + ":" + str(daemon_list[options.daemon]) + options.nodeevents

try:
    if options.verbose:
        print "URL Downloading Start".center(80, '-')
        print "URL : %s " % url
        print "URL Downloading End".center(80, '-')
    page = urllib2.urlopen(url, None, TimeOut).read()
except (urllib2.HTTPError, urllib2.URLError) as err:
    print "UNKNOWN. Problem retrieving data from %s. Error: %s " % (url, err)
    sys.exit(EXIT_UNK)

# converting retrieved page to BeautifulSoup format
if options.verbose:
    print "Converting read data to SOUP format"

soup = BeautifulSoup(page)

# parsing soup object for tables
if options.verbose:
    print "Parsing SOUP object for tables"

tables_list = soup.findAll('table')

if not tables_list:
    if options.vebose:
        print "HTML Tables records not found"
    print "UNKNOWN. HTML Tables records not found at %s " % url
    sys.exit(EXIT_UNK)

# table with status details is not needed
# parsing list of tables to find table with node_events records
work_table = chose_table(tables_list, 'th', 'App Name')

# parsing table for event rows. <tr> html tag is used

events_list = work_table.findAll('tr')
events_list = remove_table_headers(events_list)
valid_records = get_events_list(events_list, options.event, options.host, 'td')

if options.verbose:
    print "*" * 80
    print "DEBUG DATA FOR ERROR HANDLING"
    print "VALID RECORDS: "
    print "\n".join(str(i) for i in valid_records)
    print "*" * 80

if not valid_records:
    if options.verbose:
        print ">>> DEBUG "
        print ">>> NO VALID RECORDS FOUND"
        print ">>> Assuming No events has happened and NodeEvent table is empty"
    print "OK. NO EVENTS %s found " % options.event
    sys.exit(EXIT_OK)

# Getting time of last event on the page
event_from_page = int(valid_records[0].findAll('td')[0].text)
time_from_page = str(valid_records[0].findAll('td')[-1].text)
timestamp_from_page = time.mktime(time.strptime(time_from_page, '%Y-%m-%d %H:%M:%S'))

if options.verbose:
    print "Event ID and Time From Page".center(80, '-')
    print "Event ID read from page for \"%s\" event is %d " % (options.event, event_from_page)
    print "Time of event #%d is \'%s\'" % (event_from_page, time_from_page)
    print "Timestamp %s " % timestamp_from_page
    print "Event ID and Time From Page".center(80, '-')

# Now trying to read event id and time from the previous run

if get_file_exist(filename):
    event_id, event_timestamp = read_data_from_file(filename)
    if options.verbose:
        print "READ VALUES".center(80, '-')
        print "Event Number read from file : %s " % event_id
        print "Timestamp read from file : %s " % event_timestamp
        print "Human Readable Time : %s " % time.strftime('%Y-%m-%d %H:%M:%S',time.localtime(float(event_timestamp)))
        print "READ VALUES".center(80, '-')
else:
    #Assuming this is first run and file does not exist yet
    event_id = event_from_page
    event_timestamp = str(time_from_page)
    if options.verbose:
        print "Assigned VALUES".center(80, '-')
        print "Event Number read from file : %s " % event_id
        print "Human Readable Time : %s " % event_timestamp
        print "Assigned VALUES".center(80, '-')
    store_data_to_file(filename, event_id, timestamp_from_page)


# checking if new events has happened.

if int(event_from_page) > int(event_id):
    if options.verbose:
        print "Event At Page is newer than last stored in the file"
        print "Read Event %s " % event_from_page
        print "Stored Event %s " % event_id
    #now cheking how many event happened since last stored event
    event_new_list = []
    for i in xrange(len(valid_records)):
        if int(valid_records[i].findAll('td')[0].text) == int(event_id):
            break
        else:
            event_new_list.append(valid_records[i])
    if options.verbose:
        print "New Events"
        for i in xrange(len(event_new_list)):
            print "-".center(80, '-')
            # for j in (event_new_list[i].findAll('td')):
            print ' | '.join(j.text for j in (event_new_list[i].findAll('td')))
            print "-".center(80, '-')
    if len(event_new_list) >= options.critical:
        store_data_to_file(filename, event_from_page, timestamp_from_page)
        if options.verbose:
            time_pretty_formatted = pretty_time_format(timestamp_from_page)
            print "Last %s event was at %s " % (options.event, time_pretty_formatted)
            print "Event Number %d " % event_from_page

        print "CRITICAL. Amount of \"%s\" events is %d and CRITICAL threshold is %s" % (options.event, len(event_new_list), options.critical)
        sys.exit(EXIT_CRIT)
    if len(event_new_list) >= options.warning:
        store_data_to_file(filename, event_from_page, timestamp_from_page)
        if options.verbose:
            time_pretty_formatted = pretty_time_format(timestamp_from_page)
            print "Last %s event was at %s " % (options.event, time_pretty_formatted)
            print "Event Number %d " % event_from_page

        print "WARNING. Amount of \"%s\" events is %d and WARNING threshold is %s" % (options.event, len(event_new_list), options.warning)
        sys.exit(EXIT_WARN)
    else:
        store_data_to_file(filename, event_from_page, timestamp_from_page)
        print "OK. Thresholds are not exceed. Amount of events is %d | WARNING : %d | CRITICAL %d " % (len(event_new_list), options.warning, options.critical)
        sys.exit(EXIT_OK)

else:
    time_pretty_formatted = pretty_time_format(timestamp_from_page)
    print "OK. Retrieved and Read Events IDs are equal. Last \"%s\" was at %s" % (options.event, time_pretty_formatted)
    sys.exit(EXIT_OK)
